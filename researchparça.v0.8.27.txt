```python
# automate_classification.py
# automate_classification
# This should be agnostic to changes inside features and techniques:
import sqlite3
import json
import argparse
import time
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import queue
import threading
import signal

import globals  #globals.py for global settings and variables used by multiple files.

# Using a simple boolean guarded by a lock for absolute immediacy
shutdown_lock = threading.Lock()
shutdown_flag = False

def build_prompt(paper_data, template_content):
    """Builds the prompt string for a single paper using a loaded template."""
    format_data = {
        'title': paper_data.get('title', ''),
        'abstract': paper_data.get('abstract', ''),
        'keywords': paper_data.get('keywords', ''),
        'authors': paper_data.get('authors', ''),
        'year': paper_data.get('year', ''),
        'type': paper_data.get('type', ''),
        'journal': paper_data.get('journal', ''),
    }
    try:
        return template_content.format(**format_data)
    except KeyError as e:
        print(f"Error formatting prompt: Missing key {e} in paper data or template expects it.")
        raise

def update_paper_from_llm(db_path, paper_id, llm_data, changed_by="LLM", reasoning_trace=None):
    """Updates paper classification fields in the database based on LLM output."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    changed_timestamp = datetime.utcnow().isoformat() + 'Z'
    update_fields = []
    update_values = []
    
    if reasoning_trace is not None:
        update_fields.append("reasoning_trace = ?")
        update_values.append(reasoning_trace)

    # Main Boolean Fields
    main_bool_fields = ['is_survey', 'is_offtopic', 'is_through_hole', 'is_smt', 'is_x_ray']
    for field in main_bool_fields:
        if field in llm_data:
            value = llm_data[field]
            update_fields.append(f"{field} = ?")
            update_values.append(1 if value is True else 0 if value is False else None)

    # Research Area and Relevance
    if 'research_area' in llm_data:
        update_fields.append("research_area = ?")
        update_values.append(llm_data['research_area'])

    if 'relevance' in llm_data:  # Add this line
        update_fields.append("relevance = ?")
        update_values.append(llm_data['relevance'])

    # Features
    cursor.execute("SELECT features FROM papers WHERE id = ?", (paper_id,))
    row = cursor.fetchone()
    current_features = json.loads(row[0]) if row and row[0] else {}
    if 'features' in llm_data and isinstance(llm_data['features'], dict):
        current_features.update(llm_data['features'])
        update_fields.append("features = ?")
        update_values.append(json.dumps(current_features))
    
    # Techniques
    cursor.execute("SELECT technique FROM papers WHERE id = ?", (paper_id,))
    row = cursor.fetchone()
    current_technique = json.loads(row[0]) if row and row[0] else {}
    if 'technique' in llm_data and isinstance(llm_data['technique'], dict):
        current_technique.update(llm_data['technique'])
        update_fields.append("technique = ?")
        update_values.append(json.dumps(current_technique))

    # Reset verification fields when classification is updated
    # This ensures verified status is cleared after re-classification
    update_fields.append("verified = ?")
    update_values.append(None)
    update_fields.append("estimated_score = ?")
    update_values.append(None)
    update_fields.append("verified_by = ?")
    update_values.append("")
    update_fields.append("verifier_trace = ?")
    update_values.append("")
    
    # Audit fields
    update_fields.append("changed = ?")
    update_values.append(changed_timestamp)
    update_fields.append("changed_by = ?")
    update_values.append(changed_by)
    
    if update_fields:
        update_query = f"UPDATE papers SET {', '.join(update_fields)} WHERE id = ?"
        update_values.append(paper_id)
        cursor.execute(update_query, update_values)
        conn.commit()
        rows_affected = cursor.rowcount
    else:
        rows_affected = 0
    conn.close()
    return rows_affected > 0

def process_paper_worker(db_path, grammar_content, prompt_template_content, paper_id_queue, progress_lock, processed_count, total_papers, model_alias):
    """Worker function executed by each thread."""
    while True:
        try:
            # Use timeout to periodically check for shutdown
            paper_id = paper_id_queue.get(timeout=1)
        except queue.Empty:
            # Check if we should shutdown periodically
            if globals.is_shutdown_flag_set():
                return
            continue

        # Poison pill - time to die
        if paper_id is None:
            return

        # Check for shutdown before processing
        if globals.is_shutdown_flag_set():
            return

        print(f"[Thread-{threading.get_ident()}] Processing paper ID: {paper_id}")
        
        try:
            paper_data = globals.get_paper_by_id(db_path, paper_id)
            if not paper_data:
                print(f"[Thread-{threading.get_ident()}] Error: Paper {paper_id} not found in DB.")
                continue
                
            prompt_text = build_prompt(paper_data, prompt_template_content)
            if globals.is_shutdown_flag_set():
                return
                
            json_result_str, model_name_used, reasoning_trace = globals.send_prompt_to_llm(
                prompt_text, 
                grammar_text=grammar_content, 
                server_url_base=globals.LLM_SERVER_URL, 
                model_name=model_alias,
                is_verification=False
            )
            
            if globals.is_shutdown_flag_set():
                return
                
            if json_result_str:
                try:
                    llm_classification = json.loads(json_result_str)
                    # Prepend model info to reasoning_trace
                    if reasoning_trace:
                        reasoning_trace = f"As classified by {model_name_used}\n\n{reasoning_trace}"
                    else:
                        reasoning_trace = f"As classified by {model_name_used}"

                    success = update_paper_from_llm(
                        db_path, 
                        paper_id, 
                        llm_classification, 
                        changed_by=model_name_used,
                        reasoning_trace=reasoning_trace
                    )
                    if success:
                        print(f"[Thread-{threading.get_ident()}] Updated paper {paper_id} (Model: {model_name_used})")
                    else:
                        print(f"[Thread-{threading.get_ident()}] No changes for paper {paper_id}")
                except json.JSONDecodeError as e:
                    print(f"[Thread-{threading.get_ident()}] Error parsing LLM output for {paper_id}: {e}")
                    print(f"LLM Output: {json_result_str}")
                except Exception as e:
                    print(f"[Thread-{threading.get_ident()}] Error updating DB for {paper_id}: {e}")
            else:
                if not globals.is_shutdown_flag_set():
                    print(f"[Thread-{threading.get_ident()}] No LLM response for {paper_id}")
        except Exception as e:
            if not globals.is_shutdown_flag_set():
                print(f"[Thread-{threading.get_ident()}] Error processing {paper_id}: {e}")
        finally:
            if globals.is_shutdown_flag_set():
                return
            with progress_lock:
                processed_count[0] += 1
                print(f"[Progress] Processed {processed_count[0]}/{total_papers} papers.")

def run_classification(mode='remaining', paper_id=None, db_file=None, grammar_file=None, prompt_template=None, server_url=None):
    """
    Runs the LLM classification process.

    Args:
        mode (str): 'all', 'remaining', or 'id'. Defaults to 'remaining'.
        paper_id (int, optional): The specific paper ID to classify (required if mode='id').
        db_file (str): Path to the SQLite database.
        grammar_file (str): Path to the GBNF grammar file.
        prompt_template (str): Path to the prompt template file.
        server_url (str): Base URL of the LLM server.
    """
    # Use globals for defaults if not provided
    if db_file is None:
        db_file = globals.DATABASE_FILE
    if grammar_file is None:
        grammar_file = globals.GRAMMAR_FILE
    if prompt_template is None:
        prompt_template = globals.PROMPT_TEMPLATE
    if server_url is None:
        server_url = globals.LLM_SERVER_URL

    if not os.path.exists(db_file):
        print(f"Error: Database file '{db_file}' not found.")
        return False

    try:
        prompt_template_content = globals.load_prompt_template(prompt_template)
        print(f"Loaded prompt template from '{prompt_template}'")
    except Exception as e:
        print(f"Failed to load prompt template: {e}")
        return False

    grammar_content = None
    if grammar_file:
        try:
            grammar_content = globals.load_grammar(grammar_file)
            print(f"Loaded GBNF grammar from '{grammar_file}'")
        except Exception as e:
            print(f"Error reading grammar file '{grammar_file}': {e}")
            grammar_content = None

    print("Fetching model alias from LLM server...")
    model_alias = globals.get_model_alias(server_url)
    if not model_alias:
        print("Error: Could not determine model alias. Exiting.")
        return False

    print(f"Connecting to database '{db_file}'...")
    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        
        if mode == 'all':
            print("Fetching ALL papers for re-classification...")
            cursor.execute("SELECT id FROM papers")
        elif mode == 'id':
            if paper_id is None:
                print("Error: Mode 'id' requires a specific paper ID.")
                conn.close()
                return False
            print(f"Fetching specific paper ID: {paper_id} for classification...")
            cursor.execute("SELECT id FROM papers WHERE id = ?", (paper_id,))
            if not cursor.fetchone():
                 print(f"Warning: Paper ID {paper_id} not found in the database.")
                 conn.close()
                 return True
            cursor.execute("SELECT id FROM papers WHERE id = ?", (paper_id,))

        elif mode == 'no_features':
            # Goal: Re-classify on-topic papers that LLM failed to assign any defect/features to.
            # Off-topic papers are excluded by design (they have no features intentionally).        
            print("Fetching on-topic papers with no boolean features set to true...")
            conditions = [
                f"(JSON_EXTRACT(features, '$.{key}') IS NULL OR JSON_EXTRACT(features, '$.{key}') = 0)"
                for key in globals.BOOLEAN_FEATURE_KEYS
            ]
            # Group all "no features" cases
            no_features_expr = f"""
                (features IS NULL 
                 OR features = '' 
                 OR features = '{{}}'
                 OR ({' AND '.join(conditions)}))
            """
            # Only include if NOT off-topic (i.e., on-topic or unreviewed)
            where_clause = f"""
                {no_features_expr}
                AND (is_offtopic = 0 OR is_offtopic IS NULL)
            """
            cursor.execute(f"SELECT id FROM papers WHERE {where_clause}")
        
        elif mode == 'on_topic_implementation':
            # Goal: Re-classify papers that are currently marked as on-topic AND non-survey.
            print("Fetching papers marked as on-topic and non-survey for re-classification...")
            # Query for papers where is_offtopic is NULL or 0 AND is_survey is NULL or 0
            cursor.execute("""
                SELECT id FROM papers
                WHERE (is_offtopic = 0 OR is_offtopic IS NULL)
                AND (is_survey = 0 OR is_survey IS NULL)
            """)
            
        else: # Default to 'remaining'
            print("Fetching unprocessed papers (changed_by IS NULL or blank)...")
            cursor.execute("SELECT id FROM papers WHERE changed_by IS NULL OR changed_by = '' OR is_offtopic = '' OR is_offtopic IS NULL ") #set to reclassify when manually removing offtopic status
            
        paper_ids = [row[0] for row in cursor.fetchall()]
        conn.close()
        total_papers = len(paper_ids)
        print(f"Found {total_papers} paper(s) to process based on mode '{mode}'.")

        if not paper_ids:
            print("No papers found matching the criteria. Nothing to process.")
            return True

        paper_id_queue = queue.Queue()
        for pid in paper_ids:
            paper_id_queue.put(pid)

        # Add poison pills for each worker thread
        for _ in range(globals.MAX_CONCURRENT_WORKERS):
            paper_id_queue.put(None)

    except Exception as e:
        print(f"Error fetching paper IDs: {e}")
        return False

    progress_lock = threading.Lock()
    processed_count = [0]

    print(f"Starting ThreadPoolExecutor with {globals.MAX_CONCURRENT_WORKERS} workers...")
    start_time = time.time()
    
    try:
        with ThreadPoolExecutor(max_workers=globals.MAX_CONCURRENT_WORKERS) as executor:
            # Submit worker tasks
            futures = []
            for _ in range(globals.MAX_CONCURRENT_WORKERS):
                future = executor.submit(
                    process_paper_worker,
                    db_file,
                    grammar_content,
                    prompt_template_content,
                    paper_id_queue,
                    progress_lock,
                    processed_count,
                    total_papers,
                    model_alias
                )
                futures.append(future)
            
            print("Processing started. Press Ctrl+C to abort.")
            
            while not globals.is_shutdown_flag_set():
                if all(f.done() for f in futures):
                    break
                time.sleep(0.1)
            
            if globals.is_shutdown_flag_set():
                print("\nShutdown signal received. Waiting for threads to finish...")

    except KeyboardInterrupt:
        print("\nKeyboardInterrupt caught in run_classification. Setting shutdown flag.")
        globals.set_shutdown_flag()
    except Exception as e:
        print(f"Error in main execution loop: {e}")
        globals.set_shutdown_flag()
    finally:
        end_time = time.time()
        final_count = 0
        if progress_lock:
            with progress_lock:
                final_count = processed_count[0] if processed_count else 0
        print(f"\n--- Classification Summary ---")
        print(f"Papers processed: {final_count}/{total_papers}")
        print(f"Time taken: {end_time - start_time:.2f} seconds")
        print("Classification run finished.")
        return not globals.is_shutdown_flag_set()
    
    
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Automate LLM classification for papers in the database.')
    parser.add_argument('--mode', '-m',
                choices=['all', 'remaining', 'id', 'no_features', 'on_topic_implementation'], # <-- Updated choices
                default='remaining',
                help="Processing mode: 'all', 'remaining', 'id', 'no_features' (papers with no features set), or 'on_topic_implementation' (papers classified as on-topic and non-survey). Default: 'remaining'.") # <-- Updated help text
    parser.add_argument('--paper_id', '-i', type=int, help='Paper ID to classify (required if --mode id).')
    parser.add_argument('--db_file', default=globals.DATABASE_FILE,
                       help=f'SQLite database file path (default: {globals.DATABASE_FILE})')
    parser.add_argument('--grammar_file', '-g', default=globals.GRAMMAR_FILE,
                       help=f'Path to the GBNF grammar file (default: {globals.GRAMMAR_FILE})')
    parser.add_argument('--prompt_template', '-t', default=globals.PROMPT_TEMPLATE,
                       help=f'Path to the prompt template file (default: {globals.PROMPT_TEMPLATE})')
    parser.add_argument('--server_url', default=globals.LLM_SERVER_URL,
                       help=f'Base URL of the LLM server (default: {globals.LLM_SERVER_URL})')
    
    args = parser.parse_args()

    signal.signal(signal.SIGINT, globals.signal_handler)

    if args.mode == 'id' and args.paper_id is None:
        parser.error("--mode 'id' requires --paper_id to be specified.")

    success = run_classification(
        mode=args.mode,
        paper_id=args.paper_id,
        db_file=args.db_file,
        grammar_file=args.grammar_file,
        prompt_template=args.prompt_template,
        server_url=args.server_url
    )

    # Exit code is less critical now as signal_handler does os._exit(1)
    # But good practice to indicate success/failure for non-abort cases
    if not success and not globals.is_shutdown_flag_set():
        exit(1) 
    # If shutdown_flag is set, signal_handler already called os._exit(1)
    # Normal exit code 0 is implicit
```

```python
# browse_db.py
# browse_db.py
import sqlite3
import json
import argparse
from datetime import datetime
from flask import Flask, render_template, request, jsonify, abort, send_from_directory, Response, send_file
from markupsafe import Markup 
import argparse
import tempfile
import os
import sys
import threading
import webbrowser
from collections import Counter
import rcssmin
import rjsmin
import io
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill 
from openpyxl.worksheet.table import Table, TableStyleInfo
from werkzeug.utils import secure_filename # Ensure this is imported
import gzip
import base64
import zstandard as zstd
import tarfile
import shutil

# Import globals, the classification and verification modules
import globals
import automate_classification
import verify_classification

# Define default year range - For this app:
DEFAULT_YEAR_FROM = 2011
DEFAULT_YEAR_TO = 2025
DEFAULT_MIN_PAGE_COUNT = 4

app = Flask(__name__)
DATABASE = None # Will be set from command line argument

def render_papers_table(hide_offtopic_param=None, year_from_param=None, year_to_param=None, min_page_count_param=None, search_query_param=None):
    """Fetches papers based on filters and renders the papers_table.html template. 
       Used for initial render from / and XHR updates."""
    # Determine hide_offtopic state
    hide_offtopic = True # Default
    if hide_offtopic_param is not None:
        hide_offtopic = hide_offtopic_param.lower() in ['1', 'true', 'yes', 'on']

    # Determine filter values, using defaults if not provided or invalid
    year_from_value = int(year_from_param) if year_from_param is not None else DEFAULT_YEAR_FROM
    year_to_value = int(year_to_param) if year_to_param is not None else DEFAULT_YEAR_TO
    min_page_count_value = int(min_page_count_param) if min_page_count_param is not None else DEFAULT_MIN_PAGE_COUNT

    # Fetch papers with ALL the filters applied
    papers = fetch_papers(
        hide_offtopic=hide_offtopic,
        year_from=year_from_value,
        year_to=year_to_value,
        min_page_count=min_page_count_value,
    )

    # Render the table template fragment, passing the search query value for the input field
    rendered_table = render_template(
        'papers_table.html',
        papers=papers,
        type_emojis=globals.TYPE_EMOJIS,
        default_type_emoji=globals.DEFAULT_TYPE_EMOJI,
        pdf_emojis=globals.PDF_EMOJIS, # Pass the PDF emojis dictionary
        hide_offtopic=hide_offtopic,
        # Pass the *string representations* of the values to the template for input fields
        year_from_value=str(year_from_value),
        year_to_value=str(year_to_value),
        min_page_count_value=str(min_page_count_value)
    )
    return rendered_table

# DB functions:
def get_db_connection():
    """Create a connection to the SQLite database and ensure FTS tables."""
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row 
    return conn

def fetch_papers(hide_offtopic=True, year_from=None, year_to=None, min_page_count=None, search_query=None):
    """Fetch papers from the database, applying various optional filters."""
    conn = get_db_connection()
    base_query = "SELECT p.* FROM papers p"
    conditions = []
    params = []

    if hide_offtopic:
        conditions.append("(p.is_offtopic = 0 OR p.is_offtopic IS NULL)")
    if year_from is not None:
        try:
            year_from = int(year_from)
            conditions.append("p.year >= ?")
            params.append(year_from)
        except (ValueError, TypeError):
            pass
    if year_to is not None:
        try:
            year_to = int(year_to)
            conditions.append("p.year <= ?")
            params.append(year_to)
        except (ValueError, TypeError):
            pass
    if min_page_count is not None:
        try:
            min_page_count = int(min_page_count)
            conditions.append("(p.page_count IS NULL OR p.page_count = '' OR p.page_count >= ?)")
            params.append(min_page_count)
        except (ValueError, TypeError):
            pass

    # --- Build Final Query ---
    # Start with base query
    query_parts = [base_query]
    # Add WHERE clause if conditions exist
    if conditions:
        query_parts.append("WHERE " + " AND ".join(conditions))
    # Combine all parts
    query = " ".join(query_parts)

    try:
        papers = conn.execute(query, params).fetchall()
    except sqlite3.Error as e:
        conn.close()
        print(f"Database error during fetch_papers: {e}")
        raise # Re-raise to be caught by the calling function (e.g., render_papers_table)
    finally:
        conn.close()

    # --- Process Results (Same as before) ---
    paper_list = []
    for paper in papers:
        paper_dict = dict(paper)
        try:
            paper_dict['features'] = json.loads(paper_dict['features'])
        except (json.JSONDecodeError, TypeError):
            paper_dict['features'] = {}
        try:
            paper_dict['technique'] = json.loads(paper_dict['technique'])
        except (json.JSONDecodeError, TypeError):
            paper_dict['technique'] = {}

        paper_dict['pdf_filename'] = paper_dict.get('pdf_filename')     # Could be None or a string
        paper_dict['pdf_state'] = paper_dict.get('pdf_state', 'none')   # Default state if not present
        paper_dict['changed_formatted'] = format_changed_timestamp(paper_dict.get('changed'))
        # paper_dict['authors_truncated'] = truncate_authors(paper_dict.get('authors', ''))
        paper_list.append(paper_dict)
    
    return paper_list

def update_paper_custom_fields(paper_id, data, changed_by="user"):
    """Update the custom classification fields for a paper and audit fields.
       Handles partial updates based on keys present in `data`."""

    conn = get_db_connection()
    cursor = conn.cursor()
    
    changed_timestamp = datetime.utcnow().isoformat() + 'Z'

    update_fields = []
    update_values = []

    # Handle Main Boolean Fields (Partial Update)
    main_bool_fields = ['is_survey', 'is_offtopic', 'is_through_hole', 'is_smt', 'is_x_ray']
    for field in main_bool_fields:
        if field in data:
            value = data[field]
            if isinstance(value, str):
                if value.lower() in ('true', '1', 'on'):
                    update_fields.append(f"{field} = ?")
                    update_values.append(1)
                elif value.lower() in ('false', '0'):
                    update_fields.append(f"{field} = ?")
                    update_values.append(0)
                else: # 'unknown', '', None, etc.
                    update_fields.append(f"{field} = ?")
                    update_values.append(None)
            elif value is True:
                update_fields.append(f"{field} = ?")
                update_values.append(1)
            elif value is False:
                update_fields.append(f"{field} = ?")
                update_values.append(0)
            else: # value is None or numeric
                update_fields.append(f"{field} = ?")
                update_values.append(int(bool(value)) if value is not None else None)

    # Handle Research Area (Partial Update)
    if 'research_area' in data:
        update_fields.append("research_area = ?")
        update_values.append(data['research_area'])


    page_count_value_for_pages_update = None # Variable to hold the value for potential 'pages' update
    if 'page_count' in data:
        page_count_value = data['page_count']
        if page_count_value is not None:
            try:
                page_count_value = int(page_count_value)
                # Store the integer value for potential 'pages' update
                page_count_value_for_pages_update = page_count_value 
            except (ValueError, TypeError):
                page_count_value = None
                page_count_value_for_pages_update = None # Reset if invalid
        else:
            page_count_value_for_pages_update = None # Reset if None
        
        update_fields.append("page_count = ?")
        update_values.append(page_count_value)

        cursor.execute("SELECT pages FROM papers WHERE id = ?", (paper_id,))
        row = cursor.fetchone()
        if row:
            current_pages_value = row['pages']
            # Check if 'pages' is effectively empty/blank/null
            # This checks for None, empty string, or string with only whitespace
            if current_pages_value is None or (isinstance(current_pages_value, str) and current_pages_value.strip() == ""):
                # If 'pages' is blank and we have a valid page_count to set
                if page_count_value_for_pages_update is not None:
                    # Add the update for the 'pages' column
                    update_fields.append("pages = ?")
                    # Convert the integer page count back to string for the 'pages' TEXT column
                    update_values.append(str(page_count_value_for_pages_update)) 
        # --- END NEW LOGIC ---

    # Handle Verified By (Partial Update)
    if 'verified_by' in data:
        verified_by_value = data['verified_by']
        # Ensure value is either 'user' or None. Others (like model names) are treated as None.
        # This enforces that the UI can only set 'user' or clear it.
        if verified_by_value != 'user':
            verified_by_value = None
        update_fields.append("verified_by = ?")
        update_values.append(verified_by_value)
        

    # Handle Features (Partial Update)
    # Fetch current features JSON from DB to merge changes
    cursor.execute("SELECT features FROM papers WHERE id = ?", (paper_id,))
    row = cursor.fetchone()
    if row:
        try:
            current_features = json.loads(row['features']) if row['features'] else {}
        except (json.JSONDecodeError, TypeError):
            current_features = {}
    else:
        current_features = {}

    # Check for feature fields in the incoming data
    feature_updates = {}
    for key in list(data.keys()): # Iterate over a copy to safely modify data
        if key.startswith('features_'):
            feature_key = key.split('features_')[1]
            value = data.pop(key) # Remove from main data dict
            if feature_key == 'other':
                feature_updates[feature_key] = value # Text field
            else:
                # Handle radio button group for 3-state (true/false/unknown)
                if isinstance(value, str):
                    if value == 'true':
                        feature_updates[feature_key] = True
                    elif value == 'false':
                        feature_updates[feature_key] = False
                    else: # 'unknown' or anything else
                        feature_updates[feature_key] = None
                elif isinstance(value, bool):
                    feature_updates[feature_key] = value
                else: # None or numeric
                    feature_updates[feature_key] = bool(value) if value is not None else None

    if feature_updates:
        current_features.update(feature_updates)
        update_fields.append("features = ?")
        update_values.append(json.dumps(current_features))

    # Handle Techniques (Partial Update)
    # Fetch current technique JSON from DB to merge changes
    cursor.execute("SELECT technique FROM papers WHERE id = ?", (paper_id,))
    row = cursor.fetchone()
    if row:
        try:
            current_technique = json.loads(row['technique']) if row['technique'] else {}
        except (json.JSONDecodeError, TypeError):
            current_technique = {}
    else:
        current_technique = {}

    # Check for technique fields in the (potentially modified) data
    technique_updates = {}
    for key in list(data.keys()):
        if key.startswith('technique_'):
            technique_key = key.split('technique_')[1]
            value = data.pop(key) # Remove from main data dict
            if technique_key == 'model':
                technique_updates[technique_key] = value # Text field
            elif technique_key == 'available_dataset':
                 # Handle radio button group for 3-state (true/false/unknown)
                if isinstance(value, str):
                    if value == 'true':
                        technique_updates[technique_key] = True
                    elif value == 'false':
                        technique_updates[technique_key] = False
                    else: # 'unknown' or anything else
                        technique_updates[technique_key] = None
                elif isinstance(value, bool):
                    technique_updates[technique_key] = value
                else: # None or numeric
                    technique_updates[technique_key] = bool(value) if value is not None else None
            else: # classic_computer_vision_based, machine_learning_based, hybrid
                 # Handle radio button group for 3-state (true/false/unknown)
                if isinstance(value, str):
                    if value == 'true':
                        technique_updates[technique_key] = True
                    elif value == 'false':
                        technique_updates[technique_key] = False
                    else: # 'unknown' or anything else
                        technique_updates[technique_key] = None
                elif isinstance(value, bool):
                    technique_updates[technique_key] = value
                else: # None or numeric
                    technique_updates[technique_key] = bool(value) if value is not None else None

    # Merge updates into current technique
    if technique_updates:
        current_technique.update(technique_updates)
        update_fields.append("technique = ?")
        update_values.append(json.dumps(current_technique))

    # Always update audit fields for any change
    update_fields.append("changed = ?")
    update_values.append(changed_timestamp)
    update_fields.append("changed_by = ?")
    update_values.append(changed_by)

    # Any remaining keys in 'data' are assumed to be direct column names
    for key, value in data.items(): # Iterate over the potentially modified data dict
        # Skip keys already handled or special keys
        if key in ['id', 'changed', 'changed_by', 'verified_by'] or key in main_bool_fields or key.startswith(('features_', 'technique_')):
            continue
        # Treat remaining keys as direct column updates
        update_fields.append(f"{key} = ?")
        update_values.append(value)

    if update_fields:
        update_query = f"UPDATE papers SET {', '.join(update_fields)} WHERE id = ?"
        update_values.append(paper_id)
        # --- Debug prints ---
        # print(f"DEBUG: Updating paper {paper_id}")
        # print(f"DEBUG: SQL Query: {update_query}")
        # print(f"DEBUG: Values: {update_values}")
        # --- End Debug prints ---
        cursor.execute(update_query, update_values)
        conn.commit()
        rows_affected = cursor.rowcount
    else:
        rows_affected = 0 # No fields to update
    conn.close()

    if rows_affected > 0:
        conn = get_db_connection()
        updated_paper = conn.execute("SELECT * FROM papers WHERE id = ?", (paper_id,)).fetchone()
        conn.close()
        
        if updated_paper:
            updated_dict = dict(updated_paper)
            try:
                updated_dict['features'] = json.loads(updated_dict['features'])
            except (json.JSONDecodeError, TypeError):
                updated_dict['features'] = {}
            try:
                updated_dict['technique'] = json.loads(updated_dict['technique'])
            except (json.JSONDecodeError, TypeError):
                updated_dict['technique'] = {}
            
            updated_dict['changed_formatted'] = format_changed_timestamp(updated_dict.get('changed'))
            

            return_data = {
                'status': 'success',
                'changed': updated_dict.get('changed'),
                'changed_formatted': updated_dict['changed_formatted'],
                'changed_by': updated_dict.get('changed_by'),
                # Include updated fields for frontend refresh
                'research_area': updated_dict.get('research_area'),
                'page_count': updated_dict.get('page_count'),
                'is_survey': updated_dict.get('is_survey'),
                'is_offtopic': updated_dict.get('is_offtopic'),
                'is_through_hole': updated_dict.get('is_through_hole'),
                'is_smt': updated_dict.get('is_smt'),
                'is_x_ray': updated_dict.get('is_x_ray'),
                'relevance': updated_dict.get('relevance'),
                'features': updated_dict['features'], # Parsed dict
                'technique': updated_dict['technique'], # Parsed dict
                'user_trace': updated_dict.get('user_trace')
            }
            return return_data
        else:
            return {'status': 'error', 'message': 'Paper not found after update.'}
    else:
        return {'status': 'error', 'message': 'No rows updated. Paper ID might not exist or no changes were made.'}

def fetch_updated_paper_data(paper_id):
    """Fetches the full paper data after classification/verification for client-side update."""
    conn = get_db_connection()
    try:
        updated_paper = conn.execute("SELECT * FROM papers WHERE id = ?", (paper_id,)).fetchone()
        if updated_paper:
            updated_dict = dict(updated_paper)
            try:
                updated_dict['features'] = json.loads(updated_dict['features'])
            except (json.JSONDecodeError, TypeError):
                updated_dict['features'] = {}
            try:
                updated_dict['technique'] = json.loads(updated_dict['technique'])
            except (json.JSONDecodeError, TypeError):
                updated_dict['technique'] = {}
            updated_dict['changed_formatted'] = format_changed_timestamp(updated_dict.get('changed'))
            
            # Prepare data for frontend refresh (matching update_paper_custom_fields structure)
            return_data = {
                'status': 'success',
                'changed': updated_dict.get('changed'),
                'changed_formatted': updated_dict['changed_formatted'],
                'changed_by': updated_dict.get('changed_by'),
                'verified_by': updated_dict.get('verified_by'),
                # Include updated fields for frontend refresh
                'research_area': updated_dict.get('research_area'),
                'page_count': updated_dict.get('page_count'),
                'is_survey': updated_dict.get('is_survey'),
                'is_offtopic': updated_dict.get('is_offtopic'),
                'is_through_hole': updated_dict.get('is_through_hole'),
                'is_smt': updated_dict.get('is_smt'),
                'is_x_ray': updated_dict.get('is_x_ray'),
                'relevance': updated_dict.get('relevance'),
                'verified': updated_dict.get('verified'),
                'estimated_score': updated_dict.get('estimated_score'),
                'features': updated_dict['features'], # Parsed dict
                'technique': updated_dict['technique'], # Parsed dict
                'reasoning_trace': updated_dict.get('reasoning_trace'), # Include traces
                'verifier_trace': updated_dict.get('verifier_trace'),
                'user_trace': updated_dict.get('user_trace')
            }
            return return_data
        else:
            return {'status': 'error', 'message': 'Paper not found after update.'}
    finally:
        conn.close()

# --- DB Helper Functions ---

def format_changed_timestamp(changed_str):
    """Format the ISO timestamp string to dd/mm/yy hh:mm:ss"""
    if not changed_str:
        return ""
    try:
        dt = datetime.fromisoformat(changed_str.replace('Z', '+00:00'))
        return dt.strftime("%d/%m/%y %H:%M:%S")
    except ValueError:
        # If parsing fails, return the original string or a placeholder
        return changed_str

# used for HTML and XLSX exports: 
def get_default_filter_values(hide_offtopic_param, year_from_param, year_to_param, min_page_count_param, search_query_param):
    """Extracts and validates filter parameters, returning default values if invalid/missing."""
    hide_offtopic = True 
    if hide_offtopic_param is not None:
        hide_offtopic = hide_offtopic_param.lower() in ['1', 'true', 'yes', 'on']

    try:
        year_from_value = int(year_from_param) if year_from_param is not None else DEFAULT_YEAR_FROM
    except ValueError:
        year_from_value = DEFAULT_YEAR_FROM

    try:
        year_to_value = int(year_to_param) if year_to_param is not None else DEFAULT_YEAR_TO
    except ValueError:
        year_to_value = DEFAULT_YEAR_TO

    try:
        min_page_count_value = int(min_page_count_param) if min_page_count_param is not None else DEFAULT_MIN_PAGE_COUNT
    except ValueError:
        min_page_count_value = DEFAULT_MIN_PAGE_COUNT

    search_query_value = search_query_param if search_query_param is not None else ""

    return hide_offtopic, year_from_value, year_to_value, min_page_count_value, search_query_value

# --- Core Export Generation Functions ---

def generate_html_export_content(papers, hide_offtopic, year_from_value, year_to_value, min_page_count_value, search_query_value, is_lite_export=False):
    """Generates the full HTML content string for the static export."""
    # Strip fat text for lite export:
    if is_lite_export:
        for paper in papers:
            paper['abstract'] = '' # Blank Abstract
            paper['reasoning_trace'] = '' # Blank Classifier Trace
            paper['verifier_trace'] = '' # Blank Verifier Trace

    fonts_css_content = ""
    style_css_content = ""
    chart_js_content = ""
    d3_js_content = ""
    d3_cloud_js_content = ""
    ghpages_js_content = ""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    static_dir = os.path.join(script_dir, 'static')
    try:
        with open(os.path.join(static_dir, 'libs/chart.min.js'), 'r', encoding='utf-8') as f:
            chart_js_content = f.read()
        with open(os.path.join(static_dir, 'libs/d3.min.js'), 'r', encoding='utf-8') as f:
            d3_js_content = f.read()
        with open(os.path.join(static_dir, 'libs/d3-cloud.min.js'), 'r', encoding='utf-8') as f:
            d3_cloud_js_content = f.read()


        with open(os.path.join(static_dir, 'fonts.css'), 'r', encoding='utf-8') as f:
            fonts_css_content = f.read()
        with open(os.path.join(static_dir, 'style.css'), 'r', encoding='utf-8') as f:
            style_css_content = f.read()
        with open(os.path.join(static_dir, 'ghpages.js'), 'r', encoding='utf-8') as f:
            ghpages_js_content = f.read()
        with open(os.path.join(static_dir, 'stats.js'), 'r', encoding='utf-8') as f:
            stats_js_content = f.read()
        with open(os.path.join(static_dir, 'filtering.js'), 'r', encoding='utf-8') as f:
            filtering_js_content = f.read()
    except FileNotFoundError as e:
        print(f"Warning: Static file not found during HTML export generation: {e}")
        # Handle missing files gracefully if possible, or raise an error
        raise

    fonts_css_content = rcssmin.cssmin(fonts_css_content)
    style_css_content = rcssmin.cssmin(style_css_content)
    
    chart_js_content = rjsmin.jsmin(chart_js_content)
    d3_js_content = rjsmin.jsmin(d3_js_content)
    d3_cloud_js_content = rjsmin.jsmin(d3_cloud_js_content)

    stats_js_content = rjsmin.jsmin(stats_js_content)
    filtering_js_content = rjsmin.jsmin(filtering_js_content)
    ghpages_js_content = rjsmin.jsmin(ghpages_js_content)

    # --- Render the static export template ---
    papers_table_static_export = render_template(
        'papers_table_static_export.html',
        papers=papers, # Pass the potentially modified papers list
        type_emojis=globals.TYPE_EMOJIS,
        pdf_emojis=globals.PDF_EMOJIS, # Pass the PDF emojis dictionary
        default_type_emoji=globals.DEFAULT_TYPE_EMOJI,
        hide_offtopic=hide_offtopic,
        year_from_value=str(year_from_value),
        year_to_value=str(year_to_value),
        min_page_count_value=str(min_page_count_value),
        search_query_value=search_query_value
    )
    full_html_content = render_template(
        'index_static_export.html',
        papers_table_static_export=papers_table_static_export,
        hide_offtopic=hide_offtopic,
        year_from_value=year_from_value, # Pass raw values if needed by template logic
        year_to_value=year_to_value,
        min_page_count_value=min_page_count_value,
        search_query=search_query_value,
        # --- Pass potentially minified static content ---
        fonts_css_content=Markup(fonts_css_content), # Markup was already applied if needed, or content is minified
        style_css_content=Markup(style_css_content),
        
        chart_js_content=Markup(chart_js_content),
        d3_js_content=Markup(d3_js_content),
        d3_cloud_js_content=Markup(d3_cloud_js_content),

        filtering_js_content=Markup(filtering_js_content),
        stats_js_content=Markup(stats_js_content),
        ghpages_js_content=Markup(ghpages_js_content)
    )

    # --- Compress the full HTML content ---
    html_bytes = full_html_content.encode('utf-8')  # 1. Encode the HTML string to bytes (UTF-8)
    compressed_bytes = gzip.compress(html_bytes)    # 2. Compress the bytes
    compressed_base64 = base64.b64encode(compressed_bytes).decode('ascii')  # 3. Encode the compressed bytes to Base64 for embedding in JS

    pako_js_content = ""
    try:
        with open(os.path.join(static_dir, 'libs/pako.min.js'), 'r', encoding='utf-8') as f:
            pako_js_content = f.read()
    except FileNotFoundError as e:
        print(f"Warning: pako.min.js not found during HTML export generation: {e}")
        # Handle missing pako.js gracefully or raise an error
        raise

    # --- Render the LOADER template, passing the compressed data ---
    loader_html_content = render_template(
        'loader.html',
        compressed_html_data=compressed_base64,
        pako_js_content=Markup(pako_js_content)
    )
    return loader_html_content

def generate_xlsx_export_content(papers):
    """Generates the Excel file content as bytes."""
    output = io.BytesIO()
    wb = Workbook()
    ws = wb.active
    ws.title = "PCB Inspection Papers"

    # --- Define Headers (Updated Order - Corrected Boolean Features) ---
    headers = [
        "Type", "Title", "Year", "Journal/Conf name", "Pages count",
        # Classification Summary
        "Off-topic", "Relevance", "Survey", "THT", "SMT", "X-Ray",
        # Features Summary (Updated Order - Corrected Boolean Features)
        "Tracks", "Holes / Vias", "Bare PCB Other", # Boolean (e.g., bare_pcb_other)
        "Solder Insufficient", "Solder Excess", "Solder Void", "Solder Crack", "Solder Other", # Boolean (e.g., solder_other)
        "Missing Comp", "Wrong Comp", "Orientation", "Comp Other", # Boolean (e.g., component_other)
        "Cosmetic", "Other State", # Boolean for state (based on 'other' text content)
        "Other Defects Text", # Text for content (the 'other' field)
        # Techniques Summary (Updated Order)
        "Classic CV", "ML", "CNN Classifier", "CNN Detector",
        "R-CNN Detector", "Transformers", "Other DL", "Hybrid", "Datasets", "Model name",
        # Metadata
        "Last Changed", "Changed By", "Verified", "Accr. Score", "Verified By",
        "User Comment State", "User Comments" # Boolean for state, Text for content
    ]

    # --- Write Headers ---
    for col_num, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col_num, value=header)
        cell.font = Font(bold=True)

    # --- Write Data Rows ---
    for row_num, paper in enumerate(papers, 2): # Start from row 2
        # --- Helper function for consistent Excel value conversion ---
        def format_excel_value(val):
            """
            Converts Python/DB values to Excel-friendly values:
            - True/1   -> TRUE (Excel boolean)
            - False/0  -> FALSE (Excel boolean)
            - None/''/etc. -> "" (Empty string for blank Excel cell)
            - Other    -> str(val) (Text)
            """
            if val is True or (isinstance(val, (int, float)) and val == 1):
                return True # Excel TRUE
            elif val is False or (isinstance(val, (int, float)) and val == 0):
                return False # Excel FALSE
            elif val is None or val == "":
                 return "" # Explicitly empty cell for NULL/empty
            else:
                # Handle potential string representations of booleans from inconsistent DB
                if isinstance(val, str):
                    lower_val = val.lower()
                    if lower_val in ('true', '1'):
                        return True
                    elif lower_val in ('false', '0'):
                        return False
                # Default: Convert to string for text fields
                return str(val)

        # Extract and format data
        features = paper.get('features', {})
        technique = paper.get('technique', {})

        # --- Format the 'Last Changed' date ---
        changed_timestamp_str = paper.get('changed', '')
        formatted_changed_date = ""
        if changed_timestamp_str:
            try:
                # Parse the ISO format timestamp
                dt = datetime.fromisoformat(changed_timestamp_str.replace('Z', '+00:00'))
                # Format as 'YYYY-MM-DD HH:MM:SS' for Excel compatibility
                formatted_changed_date = dt.strftime("%Y-%m-%d %H:%M:%S")
            except ValueError:
                # If parsing fails, keep the original string or leave blank
                formatted_changed_date = changed_timestamp_str # Or ""

        row_data = [
            paper.get('type', ''),                    # Type (text)
            paper.get('title', ''),                   # Title (text)
            paper.get('year'),                        # Year (integer)
            paper.get('journal', ''),                 # Journal/Conf name (text)
            paper.get('page_count'),                  # Pages count (integer)
            # --- Classification Summary ---
            format_excel_value(paper.get('is_offtopic')), # Off-topic (boolean/null)
            paper.get('relevance'),                   # Relevance (integer)
            format_excel_value(paper.get('is_survey')), # Survey (boolean/null)
            format_excel_value(paper.get('is_through_hole')), # THT (boolean/null)
            format_excel_value(paper.get('is_smt')),    # SMT (boolean/null)
            format_excel_value(paper.get('is_x_ray')),  # X-Ray (boolean/null)
            # --- Features Summary (Updated Order - Corrected Boolean Features) ---
            format_excel_value(features.get('tracks')), # Tracks (boolean/null)
            format_excel_value(features.get('holes')),  # Holes / Vias (boolean/null)
            format_excel_value(features.get('bare_pcb_other')), # Bare PCB Other (boolean/null) - ADDED
            format_excel_value(features.get('solder_insufficient')), # Solder Insufficient (boolean/null)
            format_excel_value(features.get('solder_excess')), # Solder Excess (boolean/null)
            format_excel_value(features.get('solder_void')), # Solder Void (boolean/null)
            format_excel_value(features.get('solder_crack')), # Solder Crack (boolean/null)
            format_excel_value(features.get('solder_other')), # Solder Other (boolean/null) - ADDED
            format_excel_value(features.get('missing_component')), # Missing Comp (boolean/null)
            format_excel_value(features.get('wrong_component')), # Wrong Comp (boolean/null)
            format_excel_value(features.get('orientation')), # Orientation (boolean/null)
            format_excel_value(features.get('component_other')), # Comp Other (boolean/null) - ADDED
            format_excel_value(features.get('cosmetic')), # Cosmetic (boolean/null)
            # Other State (boolean based on 'other' text content) - CORRECTED COMMENT
            format_excel_value(features.get('other') is not None and str(features.get('other', '')).strip() != ""),
            features.get('other', ''),               # Other Defects Text (text) - This one shows the text
            # --- Techniques Summary (Updated Order) ---
            format_excel_value(technique.get('classic_cv_based')), # Classic CV (boolean/null)
            format_excel_value(technique.get('ml_traditional')), # ML (boolean/null)
            format_excel_value(technique.get('dl_cnn_classifier')), # CNN Classifier (boolean/null)
            format_excel_value(technique.get('dl_cnn_detector')), # CNN Detector (boolean/null)
            format_excel_value(technique.get('dl_rcnn_detector')), # R-CNN Detector (boolean/null)
            format_excel_value(technique.get('dl_transformer')), # Transformers (boolean/null)
            format_excel_value(technique.get('dl_other')), # Other DL (boolean/null)
            format_excel_value(technique.get('hybrid')), # Hybrid (boolean/null)
            format_excel_value(technique.get('available_dataset')), # Datasets (boolean/null)
            technique.get('model', ''),              # Model name (text)
            # --- Metadata ---
            formatted_changed_date,                 # Last Changed (formatted date string)
            paper.get('changed_by', ''),            # Changed By (text)
            format_excel_value(paper.get('verified')), # Verified (boolean/null)
            paper.get('estimated_score'),           # Accr. Score (integer)
            paper.get('verified_by', ''),           # Verified By (text)
            # User comments state (boolean based on 'user_trace' text content) - CORRECTED COMMENT
            format_excel_value(paper.get('user_trace') is not None and str(paper.get('user_trace', '')).strip() != ""),
            paper.get('user_trace', '')             # User comments contents (text) - This one shows the text
        ]

        # Write the row data to Excel
        for col_num, cell_value in enumerate(row_data, 1):
            ws.cell(row=row_num, column=col_num, value=cell_value)

    # Optional: Auto-adjust column widths (basic attempt)
    for column in ws.columns:
        max_length = 0
        column_letter = column[0].column_letter # Get the column name
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = (max_length + 2)
        # Cap the width to prevent extremely wide columns
        ws.column_dimensions[column_letter].width = min(adjusted_width, 50)

    # Optional: Format the data as a table (requires openpyxl >= 2.5)
    try:
        if len(papers) > 0:
            # Adjust the column reference to 'AQ' (assuming 37 columns now: A through AQ)
            # Headers are row 1, data starts row 2, so last row is len(papers) + 1
            tab = Table(displayName="PCBPapersTable", ref=f"A1:AQ{len(papers) + 1}")
            style = TableStyleInfo(name="TableStyleMedium2", showFirstColumn=False,
                                   showLastColumn=False, showRowStripes=True, showColumnStripes=False)
            tab.tableStyleInfo = style
            ws.add_table(tab)
    except Exception as e:
        print(f"Warning: Could not create Excel table: {e}")

    # --- NEW: Apply Conditional Formatting for Boolean Cells ---
    # Define fills for TRUE and FALSE
    true_fill = PatternFill(start_color="CCFFCC", end_color="CCFFCC", fill_type="solid") # Light Green
    false_fill = PatternFill(start_color="FFCCCC", end_color="FFCCCC", fill_type="solid") # Light Red
    # Updated boolean column indices based on corrected new order (1-based indexing)
    boolean_columns = [
        # Classification Summary
        6, 8, 9, 10, 11,
        # Features Summary (Boolean Features)
        12, 13, 14, # Tracks, Holes, Bare PCB Other
        15, 16, 17, 18, 19, # Solder Insufficient, Excess, Void, Crack, Solder Other
        20, 21, 22, 23, # Missing Comp, Wrong Comp, Orientation, Comp Other
        24, 25, 27, # Cosmetic, Other State, User Comment State
        # Techniques Summary
        28, 29, 30, 31, 32, 33, 34, 35, 36,
        # Metadata
        39 # Verified (column 39)
    ]

    # Iterate through rows and specified boolean columns to apply formatting
    for row in ws.iter_rows(min_row=2, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
        for col_idx in boolean_columns:
            # Adjust for 0-based indexing in the row list
            cell = row[col_idx - 1] # col_idx is 1-based, list index is 0-based
            if cell.value is True:
                cell.fill = true_fill
            elif cell.value is False:
                cell.fill = false_fill
            # If cell.value is None or "", it remains unformatted (blank cell)

    # --- Save Workbook to BytesIO object ---
    wb.save(output)
    output.seek(0)
    return output.getvalue()

def generate_filename(base_name, year_from, year_to, min_page_count, hide_offtopic, search_query, extra_suffix=""):
    """Generates a filename based on filters."""
    filename_parts = [base_name]
    if year_from == year_to:
        filename_parts.append(str(year_from))
    else:
        filename_parts.append(f"{year_from}-{year_to}")
    if min_page_count > 0:
        filename_parts.append(f"min{min_page_count}pg")
    if hide_offtopic:
        filename_parts.append("noOfftopic")
    if search_query:
        # Sanitize search query for filename (basic)
        safe_search = "".join(c for c in search_query if c.isalnum() or c in (' ', '-', '_')).rstrip()
        if safe_search:
            filename_parts.append(f"search_{safe_search[:20]}") # Limit name length
    if extra_suffix:
        filename_parts.append(extra_suffix)
    return "_".join(filename_parts)


# --- Jinja2-like filters ---
def render_status(value):
    """Render status value as emoji/symbol"""
    if value == 1 or value == "true" or value is True:
        return '' # Checkmark for True
    elif value == 0  or value == "false" or value is False:
        return '' # Cross for False
    else: # None or unknown
        return '' # Question mark for Unknown/Null

def render_verified_by(value):
    """
    Render verified_by value as emoji.
    Accepts the raw database value.
    Returns HTML string with emoji and tooltip if needed.
    """
    if value == 'user':
        return f'<span title="User"></span>' # Human emoji
    elif value is None or value == '':
        return f'<span title="Unverified"></span>'
    else:
        # For any other string, value is a model name, show computer emoji with tooltip
        # Escape the model name for HTML attribute safety
        escaped_model_name = str(value).replace('"', '&quot;').replace("'", "&#39;")
        return f'<span title="{escaped_model_name}"></span>'

def render_changed_by(value):
    """
    Render changed_by value as emoji.
    Accepts the raw database value.
    Returns HTML string with emoji and tooltip if needed.
    """
    if value == 'user':
        return f'<span title="User"></span>' # Human emoji
    elif value is None or value == '':
        return f'<span title="Unknown"></span>' # Question mark for null/empty
    else:
        # For any other string, value is a model name, show computer emoji with tooltip
        escaped_model_name = str(value).replace('"', '&quot;').replace("'", "&#39;")
        return f'<span title="{escaped_model_name}"></span>'

@app.template_filter('render_changed_by')
def render_changed_by_filter(value):
    # Use Markup to tell Jinja2 that the output is safe HTML
    return Markup(render_changed_by(value))

@app.template_filter('render_status')
def render_status_filter(value):
    return render_status(value)

@app.template_filter('render_verified_by')
def render_verified_by_filter(value):
    # Use Markup to tell Jinja2 that the output is safe HTML
    return Markup(render_verified_by(value)) 






#Routes: 
@app.route('/', methods=['GET'])
def index():
    """Main page to display the table."""
    # Get initial filter parameters from the request (or they will default inside render_papers_table)
    hide_offtopic_param = request.args.get('hide_offtopic')
    year_from_param = request.args.get('year_from')
    year_to_param = request.args.get('year_to')
    min_page_count_param = request.args.get('min_page_count')

    search_query_param = request.args.get('search_query')
        
    # Get the total number of papers in the database.
    conn = get_db_connection()
    total_paper_count = conn.execute("SELECT COUNT(*) FROM papers").fetchone()[0]
    conn.close()

    papers_table_content = render_papers_table(
        hide_offtopic_param=hide_offtopic_param,
        year_from_param=year_from_param,
        year_to_param=year_to_param,
        min_page_count_param=min_page_count_param,
        search_query_param=search_query_param,
    )
    # Pass the rendered table content and filter values to the main index template
    # Determine values to display in the input fields (use defaults if URL params were missing/invalid)
    try:
        year_from_input_value = str(int(year_from_param)) if year_from_param is not None else str(DEFAULT_YEAR_FROM)
    except ValueError:
        year_from_input_value = str(DEFAULT_YEAR_FROM)
    try:
        year_to_input_value = str(int(year_to_param)) if year_to_param is not None else str(DEFAULT_YEAR_TO)
    except ValueError:
        year_to_input_value = str(DEFAULT_YEAR_TO)
    try:
        min_page_count_input_value = str(int(min_page_count_param)) if min_page_count_param is not None else str(DEFAULT_MIN_PAGE_COUNT)
    except ValueError:
        min_page_count_input_value = str(DEFAULT_MIN_PAGE_COUNT)
    hide_offtopic_checkbox_checked = hide_offtopic_param is None or hide_offtopic_param.lower() in ['1', 'true', 'yes', 'on']
    search_input_value = search_query_param if search_query_param is not None else ""

    return render_template(
        'index.html',
        papers_table_content=papers_table_content,
        hide_offtopic=hide_offtopic_checkbox_checked,
        year_from_value=year_from_input_value,
        year_to_value=year_to_input_value,
        min_page_count_value=min_page_count_input_value,
        search_query_value=search_input_value,
        total_paper_count=total_paper_count
    )

#Backup/restore
@app.route('/backup', methods=['GET'])
def backup_database():
    """Creates a backup of the database and related files."""
    try:
        # Create backup filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"{timestamp}.para.zst"

        # Create temporary directory for exports
        with tempfile.TemporaryDirectory() as temp_dir:
            # Generate HTML export (full, not lite)
            papers = fetch_papers(hide_offtopic=True, year_from=0, year_to=9999, min_page_count=0, search_query="")
            html_content = generate_html_export_content(papers, True, 0, 9999, 0, "", is_lite_export=False)
            html_path = os.path.join(temp_dir, 'export.html')
            with open(html_path, 'w', encoding='utf-8') as f:
                f.write(html_content)

            # Generate XLSX export
            xlsx_content = generate_xlsx_export_content(papers)
            xlsx_path = os.path.join(temp_dir, 'export.xlsx')
            with open(xlsx_path, 'wb') as f:
                f.write(xlsx_content)

            # Create in-memory buffer for the backup
            buffer = io.BytesIO()
            
            # Create a Zstandard compressor
            cctx = zstd.ZstdCompressor(level=1)  # Fastest compression level
            
            # Compress the tar directly to the buffer
            with tarfile.open(fileobj=buffer, mode='w') as tar:
                # Add database file
                tar.add(DATABASE, arcname='data/new.sqlite')
                
                # Add PDF storage directory
                if os.path.exists(globals.PDF_STORAGE_DIR):
                    tar.add(globals.PDF_STORAGE_DIR, arcname='data/pdf')
                
                # Add annotated PDF storage directory
                if os.path.exists(globals.ANNOTATED_PDF_STORAGE_DIR):
                    tar.add(globals.ANNOTATED_PDF_STORAGE_DIR, arcname='data/pdf_annotated')
                
                # Add export files
                tar.add(html_path, arcname='export.html')
                tar.add(xlsx_path, arcname='export.xlsx')
            
            # Get the uncompressed tar data
            tar_data = buffer.getvalue()
            
            # Now compress the tar data with zstd
            compressed_data = cctx.compress(tar_data)
            
            # Create a new buffer with the compressed data
            compressed_buffer = io.BytesIO(compressed_data)
            compressed_buffer.seek(0)
            
            # Create a response with the in-memory backup
            response = send_file(
                compressed_buffer,
                as_attachment=True,
                download_name=backup_filename,
                mimetype='application/zstd'
            )
            
            # Ensure the filename is set correctly in Content-Disposition
            response.headers['Content-Disposition'] = f'attachment; filename="{backup_filename}"'
            
            return response
    except Exception as e:
        print(f"Backup error: {str(e)}")
        return jsonify({'status': 'error', 'message': str(e)}), 500
    
@app.route('/restore', methods=['POST'])
def restore_database():
    """Restores database and related files from a backup."""
    try:
        if 'backup_file' not in request.files:
            return jsonify({'status': 'error', 'message': 'No backup file provided'}), 400

        file = request.files['backup_file']
        if file.filename == '':
            return jsonify({'status': 'error', 'message': 'No file selected'}), 400

        if not file.filename.endswith('.para.zst'):
            return jsonify({'status': 'error', 'message': 'Invalid backup file format. Expected .para.zst'}), 400

        # Create temporary directory for extraction
        with tempfile.TemporaryDirectory() as temp_dir:
            # Save uploaded file temporarily
            temp_backup_path = os.path.join(temp_dir, 'backup.para.zst')
            file.save(temp_backup_path)

            # Decompress and extract
            dctx = zstd.ZstdDecompressor()
            with open(temp_backup_path, 'rb') as compressed_file:
                with dctx.stream_reader(compressed_file) as decomp_stream:
                    with tarfile.open(fileobj=decomp_stream, mode='r|') as tar:
                        tar.extractall(path=temp_dir)

            # Paths in the extracted archive
            extracted_db_path = os.path.join(temp_dir, 'data', 'new.sqlite')
            extracted_pdf_dir = os.path.join(temp_dir, 'data', 'pdf')
            extracted_annotated_pdf_dir = os.path.join(temp_dir, 'data', 'pdf_annotated')

            # Verify required files exist
            if not os.path.exists(extracted_db_path):
                return jsonify({'status': 'error', 'message': 'Backup does not contain required database file'}), 500

            # Backup current data before restoring (single file name, overwrites previous)
            backup_current = "backup_before_restore.para.zst"
            backup_current_path = os.path.join(os.getcwd(), backup_current)
            cctx = zstd.ZstdCompressor(level=1)
            with cctx.stream_writer(open(backup_current_path, 'wb')) as compressor:
                with tarfile.open(fileobj=compressor, mode='w|') as tar:
                    if os.path.exists(DATABASE):
                        tar.add(DATABASE, arcname='data/new.sqlite')
                    if os.path.exists(globals.PDF_STORAGE_DIR):
                        tar.add(globals.PDF_STORAGE_DIR, arcname='data/pdf')
                    if os.path.exists(globals.ANNOTATED_PDF_STORAGE_DIR):
                        tar.add(globals.ANNOTATED_PDF_STORAGE_DIR, arcname='data/pdf_annotated')

            # Perform restoration
            # 1. Replace database
            shutil.move(extracted_db_path, DATABASE)
            
            # 2. Replace PDF directories - only if they exist in the backup
            if os.path.exists(extracted_pdf_dir):
                # Create parent directory if it doesn't exist
                os.makedirs(os.path.dirname(globals.PDF_STORAGE_DIR), exist_ok=True)
                # Remove existing directory if it exists
                if os.path.exists(globals.PDF_STORAGE_DIR):
                    shutil.rmtree(globals.PDF_STORAGE_DIR)
                # Move the extracted directory
                shutil.move(extracted_pdf_dir, globals.PDF_STORAGE_DIR)
            else:
                # Create empty PDF directory if not in backup
                os.makedirs(globals.PDF_STORAGE_DIR, exist_ok=True)
                
            if os.path.exists(extracted_annotated_pdf_dir):
                # Create parent directory if it doesn't exist
                os.makedirs(os.path.dirname(globals.ANNOTATED_PDF_STORAGE_DIR), exist_ok=True)
                # Remove existing directory if it exists
                if os.path.exists(globals.ANNOTATED_PDF_STORAGE_DIR):
                    shutil.rmtree(globals.ANNOTATED_PDF_STORAGE_DIR)
                # Move the extracted directory
                shutil.move(extracted_annotated_pdf_dir, globals.ANNOTATED_PDF_STORAGE_DIR)
            else:
                # Create empty annotated PDF directory if not in backup
                os.makedirs(globals.ANNOTATED_PDF_STORAGE_DIR, exist_ok=True)

        return jsonify({
            'status': 'success',
            'message': f'Restored successfully from backup. Previous data backed up as {backup_current}'
        })
    except Exception as e:
        print(f"Restore error: {str(e)}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

# PDF storage/annotation routes
@app.route('/upload_pdf/<paper_id>', methods=['POST']) # Removed int: converter
def upload_pdf(paper_id):
    """Handles PDF file upload for a specific paper."""
    print(f"Received upload request for paper ID: {paper_id}") # Debug print
    if 'pdf_file' not in request.files:
        return jsonify({'status': 'error', 'message': 'No file part in request'}), 400

    file = request.files['pdf_file']
    if file.filename == '':
        return jsonify({'status': 'error', 'message': 'No file selected'}), 400

    if file and file.filename.lower().endswith('.pdf'):
        # original_filename = secure_filename(file.filename)
        unique_filename = f"{paper_id}.pdf"
        filepath = os.path.join(globals.PDF_STORAGE_DIR, unique_filename)

        try:
            file.save(filepath)
            # Update the database with the new filename and initial state 'PDF'
            # Use the string paper_id for the database query
            update_data = {'pdf_filename': unique_filename, 'pdf_state': 'PDF'}
            result = update_paper_custom_fields(paper_id, update_data, changed_by="user") # Pass string ID

            if result['status'] == 'success':
                # Fetch updated paper data including new PDF info
                # Pass the string ID here too
                updated_paper_data = fetch_updated_paper_data(paper_id)
                if updated_paper_data['status'] == 'success':
                    # Add the PDF specific data to the response
                    updated_paper_data['pdf_filename'] = unique_filename
                    updated_paper_data['pdf_state'] = 'PDF'
                    return jsonify(updated_paper_data)
                else:
                     print(f"Failed to fetch updated data for {paper_id} after upload.")
                     return jsonify({'status': 'error', 'message': 'Failed to fetch updated paper data after upload'}), 500
            else:
                print(f"DB update failed for {paper_id} after saving file.")
                # Rollback: delete the file if DB update failed
                if os.path.exists(filepath):
                    os.remove(filepath)
                return jsonify({'status': 'error', 'message': 'Failed to update database after saving file'}), 500

        except Exception as e:
            print(f"Error saving uploaded PDF for paper {paper_id}: {e}")
            # Attempt to remove the file if saving failed partway
            if os.path.exists(filepath):
                try:
                    os.remove(filepath)
                except OSError:
                    pass # Ignore error if file removal also fails
            return jsonify({'status': 'error', 'message': 'Failed to save file'}), 500
    else:
        print(f"File type not allowed for {paper_id}: {file.filename}")
        return jsonify({'status': 'error', 'message': 'File type not allowed, only PDFs are accepted'}), 400

@app.route('/serve_pdf/<paper_id>')
def serve_pdf(paper_id):
    """
    Serves the correct PDF file (annotated or original) for the PDF.js viewer/annotator
    based on the paper_id. Also updates the pdf_state in the database
    based on the actual existence of the annotated files.
    """
    conn = get_db_connection()
    paper = conn.execute("SELECT pdf_filename, pdf_state FROM papers WHERE id = ?", (paper_id,)).fetchone()
    
    if not paper or not paper['pdf_filename']:
        conn.close()
        print(f"No PDF filename found in DB for paper_id: {paper_id}")
        abort(404)

    filename = paper['pdf_filename']
    current_db_state = paper['pdf_state']
    
    # NEW LOGIC: Check for annotated and original files
    annotated_path = os.path.join(globals.ANNOTATED_PDF_STORAGE_DIR, filename)
    original_path = os.path.join(globals.PDF_STORAGE_DIR, filename)

    print(f"Serving PDF for paper_id {paper_id} (filename: {filename})") # Debug print
    print(f"Looking for annotated: {annotated_path}") # Debug print
    print(f"Looking for original: {original_path}") # Debug print

    new_state = None
    file_to_serve = None

    if os.path.exists(annotated_path):
        print(f"Found annotated file: {filename}")
        new_state = 'annotated'
        file_to_serve = annotated_path
    elif os.path.exists(original_path):
        print(f"Found original file: {filename}")
        new_state = 'PDF' # Reset to 'PDF' if annotated file is missing but original exists
        file_to_serve = original_path
    else:
        print(f"No PDF file found for paper_id: {paper_id} (filename: {filename})")
        # File doesn't exist at all, set state to 'none'
        new_state = 'none'
        # Update the database record
        update_query = "UPDATE papers SET pdf_state = ? WHERE id = ?"
        conn.execute(update_query, (new_state, paper_id))
        conn.commit()
        conn.close()
        abort(404) # Still abort 404 as no file to serve

    # Check if the state in the DB needs updating
    if current_db_state != new_state:
        print(f"Updating pdf_state for {paper_id} from '{current_db_state}' to '{new_state}'")
        update_query = "UPDATE papers SET pdf_state = ? WHERE id = ?"
        conn.execute(update_query, (new_state, paper_id))
        conn.commit()
    else:
        print(f"pdf_state for {paper_id} is already correct ('{new_state}')")

    conn.close()

    # Serve the determined file
    # Use os.path.basename to get just the filename from the full path for send_from_directory
    return send_from_directory(os.path.dirname(file_to_serve), os.path.basename(file_to_serve), as_attachment=False)

@app.route('/upload_annotated_pdf/<paper_id>', methods=['POST'])
def upload_annotated_pdf(paper_id):
    """
    API call for annotator autosaving feature:
    Receives an annotated PDF file associated with a paper_id,
    saves it to the annotated storage directory, and updates the pdf_state.
    """
    if 'pdf_file' not in request.files:
        return jsonify({'status': 'error', 'message': 'No file part in request'}), 400

    file = request.files['pdf_file']
    if file.filename == '' or not file.filename.lower().endswith('.pdf'):
        return jsonify({'status': 'error', 'message': 'Invalid or missing file'}), 400

    # Look up filename from paper_id to save it correctly.
    conn = get_db_connection()
    paper = conn.execute("SELECT pdf_filename FROM papers WHERE id = ?", (paper_id,)).fetchone()
    conn.close()

    if not paper or not paper['pdf_filename']:
        return jsonify({'status': 'error', 'message': f'Paper ID {paper_id} not found in DB'}), 404
    
    # Use the filename from the DB. Sanitize for security.
    filename = secure_filename(paper['pdf_filename'])
    filepath = os.path.join(globals.ANNOTATED_PDF_STORAGE_DIR, filename) # [2]

    try:
        file.save(filepath)
        
        # Update the database to set the pdf_state to 'annotated'
        update_data = {'pdf_state': 'annotated'}
        result = update_paper_custom_fields(paper_id, update_data, changed_by="user") # [10, 11]
        
        if result.get('status') != 'success':
             # If DB update fails, you might want to remove the saved file to avoid inconsistency.
            if os.path.exists(filepath):
                os.remove(filepath)
            return jsonify({'status': 'error', 'message': 'Failed to update paper state in DB'}), 500

        print(f"Saved annotated PDF for paper {paper_id} as {filename}")
        return jsonify({'status': 'success', 'message': f'File {filename} updated successfully.'})
    except Exception as e:
        print(f"Error saving annotated PDF for paper {paper_id}: {e}")
        return jsonify({'status': 'error', 'message': 'Failed to save file on server.'}), 500

# Export routes
@app.route('/static_export', methods=['GET'])
def static_export():
    """Generate and serve a downloadable HTML snapshot based on current filters."""
    # --- Get filter parameters from the request (URL query params) ---
    hide_offtopic_param = request.args.get('hide_offtopic')
    year_from_param = request.args.get('year_from')
    year_to_param = request.args.get('year_to')
    min_page_count_param = request.args.get('min_page_count')
    search_query_param = request.args.get('search_query')
    # hidden params (usable, but not implemented in the Web client GUI):
    lite_param = request.args.get('lite', default='0')
    download_param = request.args.get('download', default='1')

    # --- Determine filter values ---
    hide_offtopic, year_from_value, year_to_value, min_page_count_value, search_query_value = get_default_filter_values(
        hide_offtopic_param, year_from_param, year_to_param, min_page_count_param, search_query_param
    )

    # --- Fetch papers based on these filters ---
    papers = fetch_papers(
        hide_offtopic=hide_offtopic,
        year_from=year_from_value,
        year_to=year_to_value,
        min_page_count=min_page_count_value,
        search_query=search_query_value # Pass the search query
    )

    is_lite_export = lite_param.lower() in ['1', 'true', 'yes']

    # --- Generate the content using the core function ---
    full_html_content = generate_html_export_content(
        papers, hide_offtopic, year_from_value, year_to_value, min_page_count_value, search_query_value, is_lite_export
    )

    # --- Create a filename based on filters ---
    extra_suffix = "lite" if is_lite_export else ""
    filename = generate_filename("ResearchPara", year_from_value, year_to_value, min_page_count_value, hide_offtopic, search_query_value, extra_suffix) + ".html"

    # --- Prepare Response Headers ---
    response_headers = {"Content-Type": "text/html"}
    if download_param == '0':       # If download=0, set Content-Disposition to 'inline' to display in browser
        response_headers["Content-Disposition"] = f"inline; filename={filename}"
        print(f"Serving static export inline: {filename}") # Optional: Log action
    else:                           # Default behavior: prompt for download
        response_headers["Content-Disposition"] = f"attachment; filename={filename}"
        print(f"Sending static export as attachment: {filename}") # Optional: Log action

    return Response(
        full_html_content,
        mimetype="text/html",
        headers=response_headers
    )

@app.route('/xlsx_export', methods=['GET'])
def export_excel():
    """Generate and serve a downloadable Excel (.xlsx) file based on current filters."""
    # --- Get filter parameters from the request (URL query params) ---
    hide_offtopic_param = request.args.get('hide_offtopic')
    year_from_param = request.args.get('year_from')
    year_to_param = request.args.get('year_to')
    min_page_count_param = request.args.get('min_page_count')
    search_query_param = request.args.get('search_query') # Include search

    # --- Determine filter values ---
    hide_offtopic, year_from_value, year_to_value, min_page_count_value, search_query_value = get_default_filter_values(
        hide_offtopic_param, year_from_param, year_to_param, min_page_count_param, search_query_param
    )

    # --- Fetch papers based on these filters ---
    papers = fetch_papers(
        hide_offtopic=hide_offtopic,
        year_from=year_from_value,
        year_to=year_to_value,
        min_page_count=min_page_count_value,
        search_query=search_query_value # Pass the search query
    )

    # --- Generate the content using the core function ---
    excel_bytes = generate_xlsx_export_content(papers)

    # --- Create a filename based on filters ---
    filename = generate_filename("ResearchPara", year_from_value, year_to_value, min_page_count_value, hide_offtopic, search_query_value) + ".xlsx"

    # --- Return as a downloadable attachment ---
    return Response(
        excel_bytes, # Get the bytes from the core function
        mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

# Table generation routes
@app.route('/get_detail_row', methods=['GET'])
def get_detail_row():
    """Endpoint to fetch and render the detail row content for a specific paper."""
    paper_id = request.args.get('paper_id')
    if not paper_id:
        return jsonify({'status': 'error', 'message': 'Paper ID is required'}), 400

    try:
        conn = get_db_connection()
        paper = conn.execute("SELECT * FROM papers WHERE id = ?", (paper_id,)).fetchone()
        conn.close()

        if paper:
            # Process the paper data like in fetch_papers for consistency
            paper_dict = dict(paper)
            try:
                paper_dict['features'] = json.loads(paper_dict['features'])
            except (json.JSONDecodeError, TypeError):
                paper_dict['features'] = {}
            try:
                paper_dict['technique'] = json.loads(paper_dict['technique'])
            except (json.JSONDecodeError, TypeError):
                paper_dict['technique'] = {}
            
            # Render the detail row template fragment for this specific paper
            detail_html = render_template('detail_row.html', paper=paper_dict)
            return jsonify({'status': 'success', 'html': detail_html})
        else:
            return jsonify({'status': 'error', 'message': 'Paper not found'}), 404
    except Exception as e:
        print(f"Error fetching detail row for paper {paper_id}: {e}")
        return jsonify({'status': 'error', 'message': 'Failed to fetch detail row'}), 500

@app.route('/load_table', methods=['GET'])
def load_table():
    """Endpoint to fetch and render the table content based on current filters."""
    # Get filter parameters from the request
    hide_offtopic_param = request.args.get('hide_offtopic')
    year_from_param = request.args.get('year_from')
    year_to_param = request.args.get('year_to')
    min_page_count_param = request.args.get('min_page_count')
    search_query_param = request.args.get('search_query')

    # Use the updated helper function to render the table, passing the search query
    table_html = render_papers_table(
        hide_offtopic_param=hide_offtopic_param,
        year_from_param=year_from_param,
        year_to_param=year_to_param,
        min_page_count_param=min_page_count_param,
        search_query_param=search_query_param # Pass the search query
    )
    return table_html

# Data import/update routes (data writing):
@app.route('/update_paper', methods=['POST'])
def update_paper():
    """Endpoint to handle AJAX updates (partial or full)."""
    data = request.get_json()
    paper_id = data.get('id')
    if not paper_id:
        return jsonify({'status': 'error', 'message': 'Paper ID is required'}), 400

    try:
        # Use 'user' as the identifier for changes made via this interface
        result = update_paper_custom_fields(paper_id, data, changed_by="user")
        # The result dict already contains status and other data
        return jsonify(result)
    except Exception as e:
        print(f"Error updating paper {paper_id}: {e}") # Log error
        return jsonify({'status': 'error', 'message': 'Failed to update database'}), 500

# LLM inference routes (used for both single-paper and batch actions):
@app.route('/classify', methods=['POST'])
def classify_paper():
    """Endpoint to handle classification requests (single or batch)."""
    data = request.get_json()
    mode = data.get('mode', 'id') # Default to 'id' for single paper
    paper_id = data.get('paper_id')
    
    # Determine DB file (use command-line arg or global default)
    db_file = DATABASE 

    def run_classification_task():
        """Background task to run classification."""
        try:
            print(f"Starting classification task: mode={mode}, paper_id={paper_id}")
            # Call the appropriate function from automate_classification
            # Pass db_file explicitly or rely on its internal defaults/globals
            automate_classification.run_classification(
                mode=mode,
                paper_id=paper_id,
                db_file=db_file
                # grammar_file=..., prompt_template=..., server_url=... # Use defaults or override if needed
            )
            print(f"Classification task completed: mode={mode}, paper_id={paper_id}")
        except Exception as e:
            print(f"Error during background classification (mode={mode}, paper_id={paper_id}): {e}")
            # Consider logging this error more formally

    if mode in ['all', 'remaining']:
        # Run batch classification in a background thread to avoid blocking
        thread = threading.Thread(target=run_classification_task)
        thread.daemon = True # Dies with main process
        thread.start()
        # Return immediately
        return jsonify({'status': 'started', 'message': f'Batch classification ({mode}) initiated.'})
    elif mode == 'id' and paper_id:
        try:
            # Run single paper classification synchronously
            # The function updates the DB directly
            automate_classification.run_classification(
                mode=mode,
                paper_id=paper_id,
                db_file=db_file
            )
            # Fetch the updated data from the database
            updated_data = fetch_updated_paper_data(paper_id)
            if updated_data['status'] == 'success':
                return jsonify(updated_data)
            else:
                return jsonify(updated_data), 404 # Or 500 if it's a server error fetching data
        except Exception as e:
            print(f"Error classifying paper {paper_id}: {e}")
            return jsonify({'status': 'error', 'message': f'Classification failed: {str(e)}'}), 500
    else:
        return jsonify({'status': 'error', 'message': 'Invalid mode or missing paper_id for single classification.'}), 400

@app.route('/verify', methods=['POST'])
def verify_paper():
    """Endpoint to handle verification requests (single or batch)."""
    data = request.get_json()
    mode = data.get('mode', 'id') # Default to 'id' for single paper
    paper_id = data.get('paper_id')
    
    # Determine DB file (use command-line arg or global default)
    db_file = DATABASE

    def run_verification_task():
        """Background task to run verification."""
        try:
            print(f"Starting verification task: mode={mode}, paper_id={paper_id}")
            # Call the appropriate function from verify_classification
            verify_classification.run_verification(
                mode=mode,
                paper_id=paper_id,
                db_file=db_file
            )
            print(f"Verification task completed: mode={mode}, paper_id={paper_id}")
        except Exception as e:
            print(f"Error during background verification (mode={mode}, paper_id={paper_id}): {e}")
            # Consider logging this error more formally

    if mode in ['all', 'remaining']:
        # Run batch verification in a background thread to avoid blocking
        thread = threading.Thread(target=run_verification_task)
        thread.daemon = True
        thread.start()
        # Return immediately
        return jsonify({'status': 'started', 'message': f'Batch verification ({mode}) initiated.'})
    elif mode == 'id' and paper_id:
        try:
            # Run single paper verification synchronously
            verify_classification.run_verification(
                mode=mode,
                paper_id=paper_id,
                db_file=db_file
            )
            # Fetch the updated data from the database
            updated_data = fetch_updated_paper_data(paper_id)
            if updated_data['status'] == 'success':
                return jsonify(updated_data)
            else:
                return jsonify(updated_data), 404 # Or 500
        except Exception as e:
            print(f"Error verifying paper {paper_id}: {e}")
            return jsonify({'status': 'error', 'message': f'Verification failed: {str(e)}'}), 500
    else:
        return jsonify({'status': 'error', 'message': 'Invalid mode or missing paper_id for single verification.'}), 400

@app.route('/upload_bibtex', methods=['POST'])
def upload_bibtex():
    """Endpoint to handle BibTeX file upload and import."""
    global DATABASE # Assuming DATABASE is defined globally as before

    if 'file' not in request.files:
        return jsonify({'status': 'error', 'message': 'No file part'}), 400

    file = request.files['file']

    if file.filename == '':
        return jsonify({'status': 'error', 'message': 'No selected file'}), 400

    if file and file.filename.lower().endswith('.bib'):
        try:
            # Save the uploaded file to a temporary location
            with tempfile.NamedTemporaryFile(delete=False, suffix='.bib') as tmp_bib_file:
                file.save(tmp_bib_file.name)
                tmp_bib_path = tmp_bib_file.name

            # Use the existing import_bibtex logic
            # Import here to avoid potential circular imports if placed at the top
            import import_bibtex 

            # Call the import function with the temporary file and the global DB path
            import_bibtex.import_bibtex(tmp_bib_path, DATABASE)

            # Clean up the temporary file
            os.unlink(tmp_bib_path)

            return jsonify({'status': 'success', 'message': 'BibTeX file imported successfully.'})

        except Exception as e:
            # Ensure cleanup even if import fails
            if 'tmp_bib_path' in locals():
                try:
                    os.unlink(tmp_bib_path)
                except OSError:
                    pass # Ignore errors during cleanup
            print(f"Error importing BibTeX: {e}")
            return jsonify({'status': 'error', 'message': f'Import failed: {str(e)}'}), 500
    else:
        return jsonify({'status': 'error', 'message': 'Invalid file type. Please upload a .bib file.'}), 400



if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Browse and edit PCB inspection papers database.')
    parser.add_argument('db_file', nargs='?', help='SQLite database file path (optional)')
    args = parser.parse_args()
    
    if args.db_file:
        DATABASE = args.db_file
        print(f"Attempting to use database file from command line argument: {DATABASE}")
    elif hasattr(globals, 'DATABASE_FILE') and globals.DATABASE_FILE:
        DATABASE = globals.DATABASE_FILE
        print(f"Attempting to use database file from globals.DATABASE_FILE: {DATABASE}")

    # 3. If DATABASE is still None (neither arg nor globals provided), or if the specified file doesn't exist,
    #    fall back to 'fallback.sqlite' by copying it to globals.DATABASE_FILE location
    fallback_needed = False
    if DATABASE is None:
        fallback_needed = True
        print("Info: No database file specified via argument or globals.DATABASE_FILE.")
    elif not os.path.exists(DATABASE):
        fallback_needed = True
        print(f"Warning: Specified database file not found: {DATABASE}")

    if fallback_needed:
        # Check if fallback.sqlite exists in the script's directory
        script_dir = os.path.dirname(os.path.abspath(__file__))
        fallback_path = os.path.join(script_dir, 'fallback.sqlite')
        
        if not os.path.exists(fallback_path):
            print(f"Error: Fallback database file not found: {fallback_path}")
            print("Please ensure 'fallback.sqlite' exists in the script's directory.")
            sys.exit(1)
        
        target_database = globals.DATABASE_FILE
        print(f"Copying fallback database from {fallback_path} to {target_database}")
        
        # Copy the fallback database to the target location
        import shutil
        shutil.copy2(fallback_path, target_database)
        
        DATABASE = target_database
        print(f"Using database file: {DATABASE}")

    # Check if the final determined database file exists
    if not os.path.exists(DATABASE):
        print(f"Error: Final database file not found: {DATABASE}")
        print("Please provide a valid database file via command line argument, set globals.DATABASE_FILE correctly, or ensure 'fallback.sqlite' exists in the script's directory.")
        sys.exit(1) # Exit if even the fallback doesn't exist

    # Verify the database has the required tables
    try:
        conn = sqlite3.connect(DATABASE)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='papers'")
        if not cursor.fetchone():
            print(f"Error: Database '{DATABASE}' does not contain required 'papers' table")
            sys.exit(1)
        conn.close()
    except sqlite3.Error as e:
        print(f"Error verifying database: {e}")
        sys.exit(1)

    print(f"Starting server, database: {DATABASE}")

    # --- Open browser only once ---
    # The standard Flask/Werkzeug reloader runs the script twice:
    # 1. Once in the parent process (to manage the reloader)
    # 2. Once in the child process (the actual server, where WERKZEUG_RUN_MAIN is set)
    # We only want to open the browser in the child process.
    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
        # Function to open the browser after a delay
        def open_browser():
            import time
            time.sleep(2)  # Wait for the server to start
            webbrowser.open("http://127.0.0.1:5000")

        # Start the browser opener in a separate thread
        threading.Thread(target=open_browser, daemon=True).start()
        print(" * Visit http://127.0.0.1:5000 to view the table.")
    
    # Ensure the templates and static folders exist
    if not os.path.exists('templates'):
        os.makedirs('templates')
    if not os.path.exists('static'):
        os.makedirs('static')
    app.run(host='0.0.0.0', port=5000, debug=True)
```

```python
# globals.py
# globals.py
# **** This *has to be updated* when features or techniques change 
# See DEFAULT_FEATURES and DEFAULT_TECHNIQUE below. ****

import requests
import json
import sqlite3

import threading
import os

LLM_SERVER_URL = "http://localhost:8080"
MAX_CONCURRENT_WORKERS = 8 # Match your server slots
GRAMMAR_FILE = "" #"output.gbnf" # obsolete, disabled for reasoning models.
PROMPT_TEMPLATE = "prompt_template.txt"
VERIFIER_TEMPLATE = "verifier_template.txt"

DATABASE_FILE = os.path.join(os.getcwd(), 'data', 'db.sqlite')
os.makedirs(os.path.dirname(DATABASE_FILE), exist_ok=True)  # Ensure the directory exists

PDF_STORAGE_DIR = os.path.join(os.getcwd(), 'data', 'pdf')
os.makedirs(PDF_STORAGE_DIR, exist_ok=True) # Ensure the directory exists

ANNOTATED_PDF_STORAGE_DIR = os.path.join(os.getcwd(), 'data', 'pdf_annotated')
os.makedirs(ANNOTATED_PDF_STORAGE_DIR, exist_ok=True)

# Define default JSON structures for features and technique
DEFAULT_FEATURES = {
    "tracks": None,
    "holes": None,
    "bare_pcb_other": None,         #new
    "solder_insufficient": None,
    "solder_excess": None,
    "solder_void": None,
    "solder_crack": None,
    "solder_other": None,           #new
    "orientation": None,
    "wrong_component": None,
    "missing_component": None,
    "component_other": None,        #new
    "cosmetic": None,
    "other": None   #text
}
BOOLEAN_FEATURE_KEYS = [    # for no_features re-classification
    "tracks",
    "holes",
    "bare_pcb_other",
    "solder_insufficient",
    "solder_excess",
    "solder_void",
    "solder_crack",
    "solder_other",
    "orientation",
    "wrong_component",
    "missing_component",
    "component_other",
    "cosmetic"
]
DEFAULT_TECHNIQUE = {
    "classic_cv_based": None,
    "ml_traditional": None,
    "dl_cnn_classifier": None,
    "dl_cnn_detector": None,
    "dl_rcnn_detector": None,
    "dl_transformer": None,
    "dl_other": None,
    "hybrid": None,
    "model": None,   #text
    "available_dataset": None  
}

# mover para client-side?
# --- Define emoji mapping for publication types ---
TYPE_EMOJIS = {
    'article': '',        # Page facing up
    'inproceedings': '',  # Books (representing conference proceedings)
    'incollection': '',   # Open book (representing book chapters/collections)
    'book': '',         # Blue book
    'phdthesis': '',      # Graduation cap
    'mastersthesis': '',  # Graduation cap (using the same for simplicity)
    'techreport': '',     # Clipboard
    'misc': '',           # File folder
}
# Default emoji for unknown types
DEFAULT_TYPE_EMOJI = '' # Using article as default

PDF_EMOJIS = {
    'PDF': '',        
    'annotated': '',
    'paywalled': '',
    'none': ''
}

# --- Global Shutdown Flag for Instant Shutdown (using Lock for atomicity) ---
# This provides a common mechanism for scripts to handle Ctrl+C gracefully.
shutdown_lock = threading.Lock()
shutdown_flag = False

def set_shutdown_flag():
    """Sets the global shutdown flag to True in a thread-safe manner."""
    global shutdown_flag
    with shutdown_lock:
        shutdown_flag = True

def is_shutdown_flag_set():
    """Checks the global shutdown flag in a thread-safe manner."""
    global shutdown_flag
    with shutdown_lock:
        return shutdown_flag

def signal_handler(sig, frame):
    """Standard signal handler for SIGINT (Ctrl+C). Sets shutdown flag and forces exit."""
    print("\nReceived Ctrl+C. Killing all threads...")
    set_shutdown_flag()
    # Use os._exit for immediate shutdown across all threads
    os._exit(1)
    
#usados por automate and verify:
def get_model_alias(server_url_base):
    """Fetches the model alias from the LLM server's /v1/models endpoint."""
    models_url = f"{server_url_base.rstrip('/')}/v1/models"
    headers = {"Content-Type": "application/json"}

    try:
        response = requests.get(models_url, headers=headers, timeout=30)
        response.raise_for_status()
        models_data = response.json()

        # Simplified model alias detection
        if models_data and isinstance(models_data.get('data'), list) and models_data['data']:
            model_alias = models_data['data'][0].get('id')
            if model_alias:
                print(f"Detected model alias: '{model_alias}'")
                return model_alias

    except requests.exceptions.RequestException as e:
        print(f"Error connecting to LLM server: {e}")
        if hasattr(e, 'response') and e.response:
            print(f"Response Text: {e.response.text}")
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON response: {e}")
        if 'response' in locals():
            print(f"Response Text: {response.text}")

    fallback_alias = "Unknown_LLM"
    print(f"Using fallback model alias: '{fallback_alias}'")
    return fallback_alias

def load_prompt_template(template_path):
    """Loads the prompt template from a file."""
    try:
        with open(template_path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Error: Prompt template file '{template_path}' not found.")
        raise
    except Exception as e:
        print(f"Error reading prompt template file '{template_path}': {e}")
        raise

def get_paper_by_id(db_path, paper_id):
    """Fetches a single paper's data from the database by its ID."""
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM papers WHERE id = ?", (paper_id,))
    row = cursor.fetchone()
    conn.close()
    return dict(row) if row else None

def load_grammar(grammar_path):
    """Loads the GBNF grammar from a file."""
    try:
        with open(grammar_path, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Error: Grammar file '{grammar_path}' not found.")
        raise
    except Exception as e:
        print(f"Error reading grammar file '{grammar_path}': {e}")
        raise

def send_prompt_to_llm(prompt_text, grammar_text=None, server_url_base=None, model_name="default", is_verification=False):
    """
    Sends a prompt to the LLM via the OpenAI-compatible API. 
    Returns (content_str, model_name_used, reasoning_trace).
    """
    if server_url_base is None:
        server_url_base = LLM_SERVER_URL  # Now this will work
    
    chat_url = f"{server_url_base.rstrip('/')}/v1/chat/completions"
    headers = {"Content-Type": "application/json"}
    payload = { #official recommended parameters from Qwen:
        "model": model_name,
        "messages": [{"role": "user", "content": prompt_text}],
        "temperature": 0.6,
        "top_p": 0.95, 
        "top_k": 20, 
        "min_p": 0,
        "max_tokens": 32768,
        "stream": False
    }
    if grammar_text:
        payload["grammar"] = grammar_text
    
    context = "verification " if is_verification else ""
    
    try:
        if is_shutdown_flag_set():
            return None, None, None
        response = requests.post(chat_url, headers=headers, json=payload, timeout=600)
        if is_shutdown_flag_set():
            return None, None, None
        response.raise_for_status()
        response_data = response.json()
        
        model_name_from_response = response_data.get('model', model_name)
        if 'choices' in response_data and response_data['choices']:
            # Extract reasoning_content safely
            reasoning_content = None
            message = response_data['choices'][0]['message']
            if 'reasoning_content' in message:
                reasoning_content = message.get('reasoning_content', '').strip()
            content = message.get('content', '').strip()
            return content, model_name_from_response, reasoning_content
        else:
            print(f"Warning: Unexpected LLM {context}response structure: {response_data}")
            return None, model_name_from_response, None
    except requests.exceptions.RequestException as e:
        if is_shutdown_flag_set():
            return None, None, None
        print(f"Error sending {context}request to LLM server: {e}")
        if hasattr(e, 'response') and e.response:
            print(f"Response Text: {e.response.text}")
        return None, None, None
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON {context}response: {e}")
        if 'response' in locals():
            print(f"Response Text: {response.text}")
        return None, None, None
    except KeyError as e:
        print(f"Unexpected {context}response structure, missing key: {e}")
        print(f"Response Data: {response_data}")
        return None, None, None
```

```python
# import_bibtex.py
# import_bibtex.py
# This should be agnostic to changes inside features and techniques:
import sqlite3
import json
import bibtexparser
from bibtexparser.bparser import BibTexParser
from bibtexparser.customization import homogenize_latex_encoding
import argparse
import re # Import regex for brace removal

import globals

def create_database(db_path):
    """Create SQLite database with the specified schema including new columns"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS papers (
        id TEXT PRIMARY KEY,               -- BibTeX key
        type TEXT,                         -- Publication type (article, inproceedings, etc.)
        title TEXT,
        authors TEXT,                      -- Semicolon-separated list
        year INTEGER,
        month TEXT,
        journal TEXT,                      -- Journal or conference name
        volume TEXT,
        pages TEXT,
        page_count INTEGER,                
        doi TEXT,
        issn TEXT,
        abstract TEXT,
        keywords TEXT,                     -- Semicolon-separated list
        -- Custom classification fields
        research_area TEXT,                -- NULL = unknown
        is_offtopic INTEGER,               -- 1=true, 0=false, NULL=unknown
        relevance INTEGER,                 -- New field: 0 for offtopic, 10 for ontopic
        is_survey INTEGER,                 -- 1=true, 0=false, NULL=unknown
        is_through_hole INTEGER,           -- 1=true, 0=false, NULL=unknown
        is_smt INTEGER,                    -- 1=true, 0=false, NULL=unknown
        is_x_ray INTEGER,                  -- 1=true, 0=false, NULL=unknown
        -- Features and techniques (stored as JSON)
        features TEXT,
        technique TEXT,
        -- Audit fields
        changed TEXT,                      -- ISO 8601 timestamp, NULL if never changed
        changed_by TEXT,                   -- Identifier of the changer (e.g., 'Web app')
        verified INTEGER,                  -- 1=true, 0=false, NULL=unknown
        estimated_score INTEGER,
        verified_by TEXT,                  -- Identifier of the verifier (e.g., 'user')
        reasoning_trace TEXT,              -- New column to store evaluator reasoning traces
        verifier_trace TEXT,                -- New column to store verifier reasoning traces
        user_trace TEXT,                     -- User comments.
        pdf_filename TEXT DEFAULT NULL,
        pdf_state TEXT DEFAULT 'none'       -- 'none', 'annotated', 'PDF'
    )
    ''')
    # Enable WAL mode for better concurrency (optional)
    cursor.execute('PRAGMA journal_mode = WAL')
    conn.commit()
    conn.close() # Close connection after creation

def migrate_database(db_path):
    """Migrate existing database from old format to new format"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # Check if relevance column exists
    cursor.execute("PRAGMA table_info(papers)")
    columns = [column[1] for column in cursor.fetchall()]
    
    if 'relevance' not in columns:
        print("Migrating database to new format...")
        # Add the new relevance column
        cursor.execute("ALTER TABLE papers ADD COLUMN relevance INTEGER")
        
        # Update existing records: set relevance based on is_offtopic
        # For offtopic (is_offtopic=1), set relevance=0
        # For ontopic (is_offtopic=0), set relevance=10
        # For unknown (is_offtopic=NULL), set relevance=NULL
        cursor.execute("""
            UPDATE papers 
            SET relevance = CASE 
                WHEN is_offtopic = 1 THEN 0
                WHEN is_offtopic = 0 THEN 10
                ELSE NULL
            END
        """)
        
        conn.commit()
        print("Database migration completed.")
    
    conn.close()

def parse_authors(authors_str):
    """Parse authors string into semicolon-separated list"""
    if not authors_str:
        return ""
    # Handle potential LaTeX encoding issues if not fully homogenized
    return "; ".join(a.strip() for a in authors_str.split(' and '))

def parse_keywords(keywords_str):
    """Parse keywords into semicolon-separated list"""
    if not keywords_str:
        return ""
    return "; ".join(k.strip() for k in keywords_str.split(','))

def clean_latex_braces(text):
    """Remove unescaped curly braces from text, often left in titles by bibtexparser."""
    if not text:
        return text
    # Remove braces that are not part of a LaTeX command (simple heuristic)
    # This removes { and } that are not preceded by a backslash.
    # It might not be perfect for all edge cases but handles common ones.
    cleaned = re.sub(r'(?<!\\)\{', '', text)
    cleaned = re.sub(r'(?<!\\)\}', '', cleaned)
    return cleaned

def clean_latex_commands(text):
    """Remove common LaTeX commands and formatting from text."""
    if not text:
        return text
    
    # Remove unescaped braces
    text = re.sub(r'(?<!\\)\{', '', text)
    text = re.sub(r'(?<!\\)\}', '', text)
    
    # Replace LaTeX dash commands with regular dash
    text = re.sub(r'\\textendash', '-', text)
    text = re.sub(r'\\textemdash', '-', text)
    text = re.sub(r'\\endash', '-', text)
    text = re.sub(r'\\emdash', '-', text)
    
    # Remove other common LaTeX commands
    text = re.sub(r'\\textellipsis', '...', text)
    text = re.sub(r'\\ldots', '...', text)
    text = re.sub(r'\\dots', '...', text)
    
    # Remove any remaining LaTeX commands (pattern: backslash followed by letters)
    text = re.sub(r'\\[a-zA-Z]+', '', text)
    
    # Clean up extra whitespace
    text = re.sub(r'\s+', ' ', text).strip()
    
    return text

def parse_pages(pages_str):
    """
    Normalize pages string to "start - end" format and return start, end, and count.
    Handles formats like '276--279', '276-279', '276', '276+', etc.
    Returns:
        tuple: (normalized_pages_str, page_count) or (None, None)
    """
    if not pages_str:
        return None, None

    # Clean LaTeX commands first
    pages_str = clean_latex_commands(pages_str).strip()

    # Match common formats including double hyphens
    # Covers: "123--456", "123-456", "123456", "123456"
    match = re.match(r'^(\d+)\s*[-]*\s*(\d+)?$', pages_str.replace('--', '-'))
    if match:
        start_page = int(match.group(1))
        end_page = int(match.group(2)) if match.group(2) else start_page
        normalized = f"{start_page} - {end_page}"
        count = end_page - start_page + 1
        return normalized, count
    else:
        # Handle "123+" format
        if re.match(r'^\d+\+$', pages_str):
            page = int(pages_str[:-1])
            return f"{page} - {page}", 1
        elif pages_str.isdigit():
            # Single page
            page = int(pages_str)
            return f"{page} - {page}", 1
        else:
            # Fallback: return as-is if parsing fails
            return pages_str, None
        
def import_bibtex(bib_file, db_path):
    """Import BibTeX file into SQLite database"""
    # Configure BibTeX parser
    parser = BibTexParser(common_strings=True)
    parser.customization = homogenize_latex_encoding
    parser.ignore_nonstandard_types = False

    # Parse BibTeX file
    with open(bib_file, 'r', encoding='utf-8') as f:
        bib_db = bibtexparser.load(f, parser=parser)

    # Create database and migrate if needed
    create_database(db_path)
    migrate_database(db_path)
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    for entry in bib_db.entries:
        # Prepare data for insertion
        title_raw = entry.get('title', '')
        cleaned_title = clean_latex_commands(title_raw)  # Use improved cleaning

        # Handle pages and page_count
        raw_pages = entry.get('pages', '')
        normalized_pages, computed_page_count = parse_pages(raw_pages)

        # Try to get page_count from numpages field
        numpages_str = entry.get('numpages', '')
        page_count = None
        if numpages_str.isdigit():
            page_count = int(numpages_str)
        else:
            page_count = computed_page_count  # fallback to computed value

        # Set relevance based on is_offtopic (0 for offtopic, 10 for ontopic)
        is_offtopic = None  # Default to unknown
        relevance = None    # Default to unknown
        
        data = {
            'id': entry.get('ID', ''),
            'type': entry.get('ENTRYTYPE', ''),
            'title': cleaned_title,
            'authors': parse_authors(entry.get('author', '')),
            'year': int(entry.get('year', '0')) if entry.get('year', '').isdigit() else None,
            'month': entry.get('month', ''),
            'journal': entry.get('journal', '') or entry.get('booktitle', ''),
            'volume': entry.get('volume', ''),
            'pages': normalized_pages,
            'page_count': page_count,
            'doi': entry.get('doi', ''),
            'issn': entry.get('issn', ''),
            'abstract': entry.get('abstract', ''),
            'keywords': parse_keywords(entry.get('keywords', '')),
            'research_area': None,
            'is_offtopic': is_offtopic,
            'relevance': relevance,  # New field
            'is_survey': None,
            'is_through_hole': None,
            'is_smt': None,
            'is_x_ray': None,
            'features': json.dumps(globals.DEFAULT_FEATURES),
            'technique': json.dumps(globals.DEFAULT_TECHNIQUE),
            'changed': None,
            'changed_by': None,
            'verified': None,
            'estimated_score': None,
            'verified_by': None,
            'reasoning_trace': None,  
            'verifier_trace': None,  
            'user_trace': None, 
        }
        # Check for duplicates: prioritize DOI, fallback to title + year
        doi = data['doi']
        title = data['title']
        year = data['year']

        duplicate_found = False
        
        if doi:
            cursor.execute("SELECT id FROM papers WHERE doi = ?", (doi,))
            if cursor.fetchone():
                print(f"Skipping duplicate entry with DOI '{doi}'")
                duplicate_found = True
        else:
            # Fallback: check for same title and year
            if title and year:
                cursor.execute("SELECT id FROM papers WHERE title = ? AND year = ?", (title, year))
                if cursor.fetchone():
                    print(f"Skipping duplicate entry with title '{title}' and year '{year}'")
                    duplicate_found = True

        if duplicate_found:
            continue  # Skip this entry

        # Insert into database
        try:
            cursor.execute('''
            INSERT INTO papers (
                id, type, title, authors, year, month, journal, 
                volume, pages, page_count, doi, issn, abstract, keywords,
                research_area, is_offtopic, relevance, is_survey, is_through_hole, 
                is_smt, is_x_ray, features, technique, changed, changed_by, verified, estimated_score, verified_by, reasoning_trace, verifier_trace, user_trace
            ) VALUES (
                :id, :type, :title, :authors, :year, :month, :journal, 
                :volume, :pages, :page_count, :doi, :issn, :abstract, :keywords,
                :research_area, :is_offtopic, :relevance, :is_survey, :is_through_hole, 
                :is_smt, :is_x_ray, :features, :technique, :changed, :changed_by, :verified, :estimated_score, :verified_by, :reasoning_trace, :verifier_trace, :user_trace
            )
            ''', data)
        except sqlite3.IntegrityError as e:
            print(f"Warning: Skipping duplicate ID '{data['id']}' - {e}")
        except Exception as e:
            print(f"Error inserting entry '{data['id']}': {e}")

    conn.commit()
    print(f"Imported {len(bib_db.entries)} records into database '{db_path}'")
    conn.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Convert BibTeX to SQLite database for PCB inspection papers')
    parser.add_argument('bib_file', help='Input BibTeX file path')
    parser.add_argument('db_file', help='Output SQLite database file path')
    args = parser.parse_args()
    import_bibtex(args.bib_file, args.db_file)
```

```text
# prompt_template.txt
Given the data from the specific paper at the end, fill in the following YAML structure exactly and convert it to JSON. Do not add, remove or move any fields.
Only write 'true' or 'false' if the contents given (abstract, title, keywords, etc.) make it clear that it is the case. If unsure, fill the field with null. Do not guess true or false unless there's enough evidence in the provided abstract/keywords/etc.

research_area: null   # broad area: electrical engineering, computer sciences, medical, finances, etc, can be inferred by journal or conference name as well as abstract contents.
is_offtopic: null     # We are looking for PCB automated defect detection papers (be it implementations or surveys on this specific field). Set this field to true if paper seems unrelated to *implementations of automated defect detection on electronic printed circuit boards*. If the paper talks about anything else entirely, set as offtopic. If the paper talks about defect detection in other areas instead of electronics manufacturing, it's also offtopic. When offtopic, answer null for all classification fields following this one (filling only the research area and relevance with actual contents). *Only set this to false if at least one feature from the 'features' list below (including "other") can be set to true.*
relevance: 7          # An integer from 0 to 10 estimating how relevant the paper is for the topic according to the description above. 0 for completely irrelevant, 10 for completely relevant. Offtopic papers should have relevance around 0 to 1, rarely 2.
is_survey: null       # true for survey/review/etc., false for implementations, new research, etc.
is_through_hole: null # true for papers that specify PTH, THT, etc., through-hole component mounting, false for papers that clearly do NOT relate to this type of component mounting, null if unclear.
is_smt: null          # true for papers that specify surface-mount component mounting (SMD, SMT), false for papers that clearly do NOT relate to this type of component mounting, null if unclear.
is_x_ray: null        # true for X-ray inspection, false for standard optical (visible light) inspection.
features:             # true, false, null for unknown/unclear. Mark as true all the types of defect which are detected by the implementation(s) described in the paper (or the surveyed papers if it's a survey). Mark as false if the paper explicitly exclude a class, otherwise keep as unknown.
	# Empty PCB issues:
    tracks: null # any track error detection: open track, short circuit, spurious copper, mouse bite, wrong trace space/width, etc.
    holes: null # for hole plating, drilling defects and any other PCB hole issues.
    bare_pcb_other: null # for any other or unspecified bare PCB (not assembled with components) issue. Set this to true if paper talks about bare PCB defects but doesn't mention which ones.
	
	# soldering/welding issues:
    solder_insufficient: null # too little solder, dry joint, poor fillet
    solder_excess: null # solder ball / bridge / short between pads or leads
    solder_void: null # voids, blow-holes, pin-holes inside the joint
    solder_crack: null # fatigue cracks, fractured or cold joints
    solder_other: null # for any other or unspecified solder issue. Set this to true if paper talks about solder defects but doesn't mention which ones.
	
	# component issues: 
    orientation: null # for components installed in the correct place, but with wrong orientation (inverted polarity, wrong pin 1 placement, etc).
    wrong_component: null # for components installed in the wrong location, might also detect components being installed where none should be.
    missing_component: null # for detection of empty places where some component has to be installed (e.g. empty pads that aren't supposed to stay empty).
    component_other: null # for any other or unspecified component issue. Set this to true if paper talks about component defects but doesn't mention which ones.
	
  # other issues:
	  cosmetic: null #cosmetic defects (any manufacturing defect that does not actually affect functionality: scratches, dirt, etc.);
    other: null #"string with any other types of defect detection not specified above"

technique:                # true, false, null for unknown/unclear. Identify all techniques used (if it's an implementation), or all techniques reviewed (if it's a survey). For each single DL-based implementation, set exactly one dl_* flag to true. For surveys (or papers that make more than one implementation) there may be multiple ones:
	classic_cv_based: null  # for general pattern recognition techniques that do not leverage machine learning: true if the method is entirely rule-based or uses classical image-processing / pattern-recognition without learned parameters (histogram matching, morphological filtering, template matching, etc.). May or may not leverage optimization algorithms, like genetic, PSO, etc.

	ml_traditional: null    # true for any non-deep ML: SVM, RF, K-NN, LVQ, Boosting, etc. Does not include deep learning like CNNs or Transformers.

	dl_cnn_classifier: null # true when the only DL component is a plain CNN used as an image classifier (ResNet-50, EfficientNet-B0, VGG, ): no detection, no segmentation, no attention blocks.
	dl_cnn_detector: null   # true for single-shot detectors whose backbone is CNN (YOLOv3, YOLOv4, YOLOv5, YOLOv6, YOLOv7, YOLOv9, YOLOv10, SSD, RetinaNet, FCOS, CenterNet, etc.). Also true for otherwise single-stage CNNs with an attached Transformer module.
	dl_rcnn_detector: null  # true for two-stage (R-CNN family) or anchor-based region proposal detectors: R-CNN, Fast R-CNN, Faster R-CNN, Mask R-CNN, Cascade R-CNN, DetectoRS, Sparse R-CNN, etc.  Also true for otherwise two-stage CNNs with an attached Transformer module.
	dl_transformer: null    # true for any model whose core is attention/transformer blocks, including pure ViT, DETR, Deformable DETR, YOLOv8-seg, YOLOv12, RT-DETR, SegFormer, Swin, etc. Also, if the paper adds a transformer module to another model like a CNN, set both this and the corresponding CNN field as true.
	dl_other: null          # for any other DL architecture not covered above (e.g. pure Autoencoder, GAN, Diffusion, MLP-Mixer).

	hybrid: null            # true if the paper explicitly combines categories above (classic + DL, classic + ML, ML + DL).  If hybrid is true, also set each constituent technique to true.
	model: "name"			      # model name or comma-separated list if multiple models are used (YOLO, ResNet, DETR, etc.), null if not ML, "in-house" if unnamed ML model is developed in the paper itself.
	available_dataset: null # true if authors explicitly mention they're providing related datasets for the public, false if there's no dataset usage (e.g. for techniques not depending on a dataset) or if the dataset used is not provided to the public.

Below are some example outputs, from random papers, for structure reference only:

**Implementation using YOLO for SMT PCB inspection**

{{
  "research_area": "electrical engineering",
  "is_offtopic": false,
  "relevance": 9,
  "is_survey": false,
  "is_through_hole": false,
  "is_smt": true,
  "is_x_ray": false,
  "features": {{
    "tracks": true,
    "holes": false,
    "bare_pcb_other": false,
    "solder_insufficient": true,
    "solder_excess": true,
    "solder_void": null,
    "solder_crack": null,
    "solder_other": null,
    "orientation": true,
    "wrong_component": true,
    "missing_component": true,
    "component_other": null,
    "cosmetic": true,
    "other": null
  }},
  "technique": {{
    "classic_cv_based": false,
    "ml_traditional": false,
    "dl_cnn_detector": true,
    "dl_rcnn_detector": false,
    "dl_transformer": false,
    "dl_other": false,
    "hybrid": false,
    "model": "YOLOv5",
    "available_dataset": true
  }}
}}

**Justification**:  
This paper presents an implementation of YOLOv5 applied to optical inspection of surface-mounted PCBs. It detects multiple defect types including solder bridges, missing components, and track issues. The dataset is publicly released. All relevant fields are set accordingly. Strongly on-topic with high relevance.

---
**Mid 2010s survey paper on deep learning methods for PCB defect detection**

{{
  "research_area": "computer sciences",
  "is_offtopic": false,
  "relevance": 8,
  "is_survey": true,
  "is_through_hole": null,
  "is_smt": null,
  "is_x_ray": null,
  "features": {{
    "tracks": true,
    "holes": true,
    "bare_pcb_other": true,
    "solder_insufficient": true,
    "solder_excess": true,
    "solder_void": true,
    "solder_crack": true,
    "solder_other": true,
    "orientation": null,
    "wrong_component": null,
    "missing_component": null,
    "component_other": null,
    "cosmetic": false,
    "other": "via misalignment, pad lifting"
  }},
  "technique": {{
    "classic_cv_based": false,
    "ml_traditional": true,
    "dl_cnn_detector": true,
    "dl_rcnn_detector": true,
    "dl_transformer": false,
    "dl_other": false,
    "hybrid": true,
    "model": "ResNet, YOLOv3, Faster R-CNN, DETR",
    "available_dataset": null
  }}
}}

**Justification**:  
This is a comprehensive survey reviewing various techniques (ML, DL) used in PCB defect detection. It covers both SMT and through-hole (though not specified), and includes X-ray and optical methods. Since it's a survey, `is_survey = true`, and multiple techniques are marked as `true`. High relevance due to broad coverage of the target domain. It does not cover Transformer because that wasn't yet a thing at the time of the survey.

---
**X-ray based void detection in solder joints using CNN classifier**

{{
  "research_area": "electronics manufacturing",
  "is_offtopic": false,
  "relevance": 7,
  "is_survey": false,
  "is_through_hole": true,
  "is_smt": true,
  "is_x_ray": true,
  "features": {{
    "tracks": false,
    "holes": false,
    "bare_pcb_other": false,
    "solder_insufficient": null,
    "solder_excess": false,
    "solder_void": true,
    "solder_crack": null,
    "solder_other": null,
    "orientation": false,
    "wrong_component": false,
    "missing_component": false,
    "component_other": false,
    "cosmetic": false,
    "other": null
  }},
  "technique": {{
    "classic_cv_based": false,
    "ml_traditional": false,
    "dl_cnn_detector": false,
    "dl_rcnn_detector": false,
    "dl_transformer": false,
    "dl_other": false,
    "hybrid": false,
    "model": "ResNet-50",
    "available_dataset": false
  }}
}}

**Justification**:  
The paper focuses specifically on detecting solder voids in BGA joints using X-ray imaging and a ResNet-50 classifier. It applies to both SMT and through-hole (implied by context). Very narrow scope but valid implementation in the target field. Relevance is moderate because it addresses only one defect type.

---
**Defect detection in textile manufacturing using computer vision**

{{
  "research_area": "materials engineering",
  "is_offtopic": true,
  "relevance": 1,
  "is_survey": null,
  "is_through_hole": null,
  "is_smt": null,
  "is_x_ray": null,
  "features": {{
    "tracks": null,
    "holes": null,
    "bare_pcb_other": null,
    "solder_insufficient": null,
    "solder_excess": null,
    "solder_void": null,
    "solder_crack": null,
    "solder_other": null,
    "orientation": null,
    "wrong_component": null,
    "missing_component": null,
    "component_other": null,
    "cosmetic": null,
    "other": null
  }},
  "technique": {{
    "classic_cv_based": null,
    "ml_traditional": null,
    "dl_cnn_detector": null,
    "dl_rcnn_detector": null,
    "dl_transformer": null,
    "dl_other": null,
    "hybrid": null,
    "model": null,
    "available_dataset": null
  }}
}}

**Justification**:  
Although this paper uses computer vision and deep learning for *defect detection*, it is applied to **textile manufacturing**, not PCBs or electronics. Therefore, it's **off-topic**. `is_offtopic = true`, so all subsequent fields are `null`. The research area is correctly identified as materials engineering.

---

**Blockchain-based voting system**

{{
  "research_area": "computer sciences",
  "is_offtopic": true,
  "relevance": 0,
  "is_survey": null,
  "is_through_hole": null,
  "is_smt": null,
  "is_x_ray": null,
  "features": {{
    "tracks": null,
    "holes": null,
    "bare_pcb_other": null,
    "solder_insufficient": null,
    "solder_excess": null,
    "solder_void": null,
    "solder_crack": null,
    "solder_other": null,
    "orientation": null,
    "wrong_component": null,
    "missing_component": null,
    "component_other": null,
    "cosmetic": null,
    "other": null
  }},
  "technique": {{
    "classic_cv_based": null,
    "ml_traditional": null,
    "dl_cnn_detector": null,
    "dl_rcnn_detector": null,
    "dl_transformer": null,
    "dl_other": null,
    "hybrid": null,
    "model": null,
    "available_dataset": null
  }}
}}

**Justification**:  
This paper proposes a blockchain solution for secure digital voting. There is **no mention of PCBs, defect detection, image processing, or hardware inspection**. It is **completely unrelated** to the topic. Hence, `is_offtopic = true`, all lower fields are `null`, and relevance is 0. Research area is broadly computer science, but still far off-topic.

--

Finally, below is the paper you will process. Answer accordingly:

*Title:* {title}
*Abstract:* {abstract}
*Keywords:* {keywords}
*Authors:* {authors}
*Publication Year:* {year}
*Publication Type:* {type}
*Publication Name:* {journal}

Remember, your response is not being read by a human, it goes directly to an automated parser. After thinking through the request in <think></think> tags, output only the result in JSON format in plaintext without any other tags like ```json or similar.
```

```markdown
# README.md
# ResearchPara

ResearchPara is a tool for managing and analyzing a bibliographic database, specifically tailored for academic papers on Printed Circuit Board (PCB) inspection. It processes BibTeX files, stores the data in an SQLite database, and provides a web interface for browsing, filtering, and editing the information. The core functionality includes using Large Language Models (LLMs) to automatically classify papers based on their content (title, abstract, keywords) and to verify these classifications.

The system is designed to streamline literature reviews by allowing for advanced search capabilities, statistical analysis of the dataset, and traceable, LLM-driven data enrichment.

## Features

- **BibTeX Import**: Imports bibliographic data from `.bib` files into a structured SQLite database. The import process handles duplicate entries by checking for existing DOIs or matching titles and years.
- **Web Interface**: A Flask-based web application (`browse_db.py`) provides a user-friendly interface to view, filter, and edit the paper database. The server starts up and automatically opens the interface in a web browser.
- **LLM-Powered Classification**: The `automate_classification.py` script sends paper metadata to an OpenAI-compatible LLM server to classify papers based on a detailed prompt template. It can process all papers, only unprocessed ones, or a single paper by its ID. Classification results, including the model's reasoning trace, are saved to the database.
- **LLM-Powered Verification**: `verify_classification.py` uses an LLM to review and verify the accuracy of a previous classification, providing a score and a "verified" status. This process also runs in different modes ('all', 'remaining', 'id').
- **Advanced Filtering and Search**: The web UI allows for server-side filtering by year range, minimum page count, and a search query. The search functionality is powered by SQLite FTS5 for efficient full-text searching across standard fields and JSON content.
- **Data Editing**: Users can directly edit classification fields, add comments (`user_trace`), and manage metadata through the web interface.
- **PDF Management**: The application supports uploading, storing, and viewing PDF versions of papers. It includes an integrated, branded version of PDF.js that allows for annotating documents directly in the browser, with changes being automatically saved to the server.
- **Data Export**: The currently filtered view of the database can be exported to:
    - A self-contained, interactive static **HTML file**. This export is compressed for a smaller file size and includes client-side filtering and charting capabilities.
    - An **Excel (.xlsx) file**, with boolean fields conditionally formatted for readability, ready to be processed using pivot tables and/or any other Excel tools.
- **Backup and Restore**: The system includes functionality to create a complete backup (`.para.zst` file) containing the SQLite database, all stored PDFs, and exported files. A restore feature allows rebuilding the application state from a backup file. The backup file can also be manually extracted and browsed (including annotated PDFs) directly from the included HTML export.

## Usage

1.  **Installation**:
    - Ensure Python 3.x is installed.
    - Create a virtual environment and install the required packages: `pip install -r requirements.txt`.

2.  **Configuration**:
    - Edit `globals.py` to configure application settings, including the database file path (`DATABASE_FILE`) and the URL for the LLM server (`LLM_SERVER_URL`). The application is designed to work with an OpenAI-compatible API that supports reasoning traces.

3.  **Database Setup**:
    - You can import a BibTeX file directly from the web interface after the application is running. If no database is found on startup, the application will copy `fallback.sqlite` to the data directory to ensure it can launch for the first import or a backup restore.
    - Alternatively, manually run the import script to create and populate the database:
      ```bash
      python import_bibtex.py your_file.bib data/db.sqlite
      ```

4.  **Running the Application**:
    - Launch the web server by running `browse_db.py`. You can optionally provide the path to the database file as a command-line argument.
      ```bash
      python browse_db.py [path/to/your/db.sqlite]
      ```
    - The application will be available at `http://127.0.0.1:5000`, and a browser window should open to this address automatically.
    - Look at the help page in the Web application itself for more instructions about the Web interface itself (Note: these instructions are currently outdated, some functionality is changed or added).

5.  **LLM Integration**:
    - Start an OpenAI-compatible inference server (e.g., llama.cpp). `/lcpp` folder has sample settings for a supported llama.cpp configuration.
    - From the web UI, you can trigger classification and verification tasks for individual papers or in batches ('all' or 'remaining').
    - Alternatively, manually run classification using `automate_classification.py` and `verify_classification.py.` Both accept `--mode all` and `--mode remaining` operating modes for batch classification.
```

```text
# TODO.txt
OK  Identify LLM by name from the API
OK  Remove bogus DOI links from papers that lack so.
OK  Change LLM endpoint URL to go to the server itself instead of /v1/chat/completions
        Ensure correct usage on all files.
OK  Use Config from file instead of requiring commandline

OK  Add column for "page count" (to filter out short papers)
OK  Add columns on DB for "verified by":         User        Computer        null
        Also add a tooltip for LLM namme
OK  Add new column to table and/or detail row:
OK      Verified by

OK  Add missing columns to table and/or detail row:
OK        Model name
OK        Page count
    
OK   Redo from scratch verification pass (LLM reads each DB line and checks if the according inferred values are sane)
OK      Use shared functions from globals.py
      
OK    Add support to reasoning models
OK        Save reasoning to DB
OK        Show reasoning in detail row

OK   Fix page count parser for Zotero exports

OK  Add client-side filters:
OK      Instant search keywords
OK            Ensure detail row still stays linked to corresponding article row
OK        Filter out short papers
OK        Filter out offtopic

OK    Add quick stats (totals at the end of the table)
OK        Also add counter of total papers and total filtered papers
OK    Remove signal handler + set_flags, etc. from automate_classification.py
OK    Change "changed by" to icon instead of model name, consistent with "verified by"
OK    Fix bogus table shading after filtering
OK    Fix model_name not showing in GUI
OK    Fix "other defects" not showing in GUI
OK    Fix "datasets" not showing in GUI
OK    Fix instances of computer_graphics instead of computer_vision
OK    Fix sort by 'verified'

OK?   Send to LLM from GUI
OK        Refactor automate, verify .py
OK        Reprocess and verify all?
OK        Reprocess remaining?
OK        Verify remaining;
OK?            Prevent verifying unprocessed papers;
OK        "Classify this paper" from detail row?
OK        "Verify this paper" from detail row?

OK    Fix automate never reaches final status, stuck at 'processed 524/524' papers after finishing.
OK        Do not search inside thinking traces (as it may think about things the given paper doesn't have, etc.)

OK        Fix css
OK        Tell the verifier that "None" is as valid as null.

OK        Finer-grained classes:
                Features:
                        Tracks (short, open, mouse bite, spur, spurious copper, wrong trace space/width)
                        Holes 
                        Missing component;
                        Wrong/misplaced component;
                        Wrong orientation/polarity of component;
                        Solder (Cold solder, bridging, excess solder, pinhole);
                        Cosmetic defects (any manufacturing defect that does not actually affect functionality: scratches, dirt, etc.);
                Techniques: 
                        Classic CV (pattern matching, manually-programmed feature analysis etc. May or may not leverage optimization algorithms, like genetic, PSO, etc.)
                        Classic ML (SVM, Random Forest, K-NN, LVQ, etc.)
                        DL: Standard CNN (classifiers: ResNet, EfficientNet, etc)
                        DL: Region-based CNN (detectors: R-CNNs, EfficientDet, most YOLO versions)
                        DL: Transformer (e.g. ViT, DETR, etc.) or mixed CNN+Transformer (e.g. YOLOv12)
                        Hybrid/Ensemble methods (including ML+DL, classic+DL, not including 'hybrids' of DL+DL)
                
OK      Fix/verify after refactor:
OK              Counters at the end of table
OK              Sort by
        
OK        Stats (calculated after filtering):
                Count of instances of each journal
                Count of instances of each keyword     
                        Multiple keywords per row
                Count of instances of each research area and count
OK              Fix CSS

OK      Read manually-set page count.

OK      Import bibTeX from GUI?
OK              Automatic Dedup by DOI?
    
        Allow discarding a paper from DB in GUI?
                Maybe not, be consistent with the search sentence

OK      Hide unclassified and off-topic server-side
OK      Add year range instead of "older than x years"

Refactor: optimizations for larger >>1000 papers dataset:

OK      Change min page count to server-side;
OK      Change year to server-side;
OK      Change search to server-side;
OK      Change detail row to lazy load;
OK      Reimplement repeated keywords, authors, areas count server-side 

OK      Reimplement full-client-side GH Pages export
                Optimize this version for speed somehow?

OK      Fix table layout dynamic widths (colgroups)
OK      Add loading spinner for table updates

OK      Group features;
OK      Keep colors consistent across charts;
OK      Fix exported HTML charts;
OK      Show "has Other"
OK      Show "has User Comment"
OK      Add missing stats to server-side version. Can't be done client-side because detail row is lazy-loaded.
OK      Add Export to Excel to server-side implementation.

OK      Add sanity check filter: offtopic papers verified as wrong classification:
OK              Instead, just add a "only wrong classifications" filter then sort by offtopic?
                Potential max. 177 false offtopics of 11709?

OK      Fix server-side search not being capable of searching strings that are JSON keys (as they return all rows because they have the key)?
OK              Index JSON contents for fast search

OK      Refactor filtering.js (too large): separate stats.js
        Automatically reset 'verified' after 're-classify this paper' or manual changes.

OK      Fix fixed-position JS columns (e.g. verifier score updating wrong column on client post-XHR);

OK      Fix chart can grow but can't shrink?
OK      Add filter for feature groups (tracks/holes, solder, PCBA), all client-side;
OK      Add journal vs conference chart;

OK      Add PDF attachment capability
OK      Add PDF annotation capability
OK              Autosave annotations
OK              Brand annotator interface

OK      Add Excel export:
                Count of misclassification suspects;
                Bubble charts about...?
                
OK      Add full zip export (static HTML viewer + database + PDF folders)
OK              Implement full backup/restore
OK              Add a fallback empty DB to always allow app to open without data (so restores can be done from Web UI)

OK      Add solder_other, pcb_other, etc. boolean fields;
OK      Add 'search this' buttons on every statistics list item;
OK      Separate journal count from conference count in the stats;

OK	Add tri-state checkbox for off-topic papers;

OK	Add stacked/cumulative charts;

OK	Re-factor JS to remove duplicated code from ghpages.js: keep only actual export-specific code
OK		Refactor filtering.js
OK		Refactor stats.js

OK      Add keyword cloud
OK      Fix filtering/stats generation: unified client-side logic for now.
OK              deprecated fetchDetailRowLists()
OK              deprecated /get_stats
OK              deprecated FTS search
        Currently search doesn't read abstracts (not in preloaded detail row to reduce excess bloat). Should it?


        Refactor browse_db.py (too large)?
                Moving SQLite logic to a separate file for DB operations may cause 
                        'sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 34640 and this is thread id 16976.'
                Moving helpers away is fine, but there are only three.
                
        Fix ugly checkboxes
                Show negative vs positive checkboxes differently

        Integrate base64 favicon incl. in HTML Export
        Add ABNT? citation to detail pane

        Add multiuser capability (naming users, user-selectable DB) -- good for offline "sneakernet" collaboration;
                Possibly auth for online server hosting? -- low priority

        Isolate most domain-specific logic where possible -- long term, complicated refactor with little usefulness for now:
                separate fixed from domain-specific HTML templates;
                add a python file exclusive for the domain-specific details (DB schema, JSON schemas, etc) and change existing scripts to use it accordingly;
                separate JS for logic that access the domain-specific HTML parts from generic JS
                See docs.md for info on some domain-specific scattered code.

        Low relevance XHR limitations/fixes:
                Update commented&other field displays on save.
                Update PDF icon on first annotation without manual reload.

        Automatic add/remove paywalled icon to papers based on user trace containing 'paywalled' string;

        
        Fix FTS search (not finding text fields at all?)
                Optimize FTS Search (use all searchable fields)
```

```text
# verifier_template.txt
Below is the data for a paper and its corresponding LLM-generated classification. Your job is to determine if the classification accurately reflects the information in the paper's title, abstract, and keywords.

Instructions:
1. Read the paper content carefully.
2. Compare the automated classification against the paper content.
3. Determine if the classification is a faithful representation of the paper.
4. Respond ONLY with a JSON object containing two fields:
   - `verified`: `true` if the classification is largely correct, `false` if it contains significant errors or misrepresentations, `null` if there's not enough data for a decision, you are unsure or cannot determine the accuracy.
   - `estimated_score`: An integer between 0 and 10 scoring the quality of the original classification. It represents a finer-grained score for how accurate the automated classification was compared to the actual paper data. 0 for completelly inaccurate, 10 for completely accurate, or any integer inbetween.

Example Response Format (only output the JSON):
{{
  "verified": true,
  "estimated_score": 8
}}

The plaintext below shows the requirements for the original classification you'll be verifying:

```plaintext
Given the data from the specific paper at the end, fill in the following YAML structure exactly and convert it to JSON. Do not add, remove or move any fields.
Only write 'true' or 'false' if the contents given (abstract, title, keywords, etc.) make it clear that it is the case. If unsure, fill the field with null. Do not guess true or false unless there's enough evidence in the provided abstract/keywords/etc.

research_area: null   # broad area: electrical engineering, computer sciences, medical, finances, etc, can be inferred by journal or conference name as well as abstract contents.
is_offtopic: null     # We are looking for PCB automated defect detection papers (be it implementations or surveys on this specific field). Set this field to true if paper seems unrelated to *implementations of automated defect detection on electronic printed circuit boards*. If the paper talks about anything else entirely, set as offtopic. If the paper talks about defect detection in other areas instead of electronics manufacturing, it's also offtopic. When offtopic, answer null for all classification fields following this one (filling only the research area and relevance with actual contents). *Only set this to false if at least one feature from the 'features' list below (including "other") can be set to true.*
relevance: 7          # An integer from 0 to 10 estimating how relevant the paper is for the topic according to the description above. 0 for completely irrelevant, 10 for completely relevant. Offtopic papers may have relevance "None", "null", or around 0 to 1, rarely 2.
is_survey: null       # true for survey/review/etc., false for implementations, new research, etc.
is_through_hole: null # true for papers that specify PTH, THT, etc., through-hole component mounting, false for papers that clearly do NOT relate to this type of component mounting, null if unclear.
is_smt: null          # true for papers that specify surface-mount component mounting (SMD, SMT), false for papers that clearly do NOT relate to this type of component mounting, null if unclear.
is_x_ray: null        # true for X-ray inspection, false for standard optical (visible light) inspection.
features:             # true, false, null for unknown/unclear. Mark as true all the types of defect which are detected by the implementation(s) described in the paper (or the surveyed papers if it's a survey). Mark as false if the paper explicitly exclude a class, otherwise keep as unknown.
	# Empty PCB issues:
    tracks: null # any track error detection: open track, short circuit, spurious copper, mouse bite, wrong trace space/width, etc.
    holes: null # for hole plating, drilling defects and any other PCB hole issues.
    bare_pcb_other: null # for any other or unspecified bare PCB (not assembled with components) issue. Set this to true if paper talks about bare PCB defects but doesn't mention which ones.
	
	# soldering/welding issues:
    solder_insufficient: null # too little solder, dry joint, poor fillet
    solder_excess: null # solder ball / bridge / short between pads or leads
    solder_void: null # voids, blow-holes, pin-holes inside the joint
    solder_crack: null # fatigue cracks, fractured or cold joints
    solder_other: null # for any other or unspecified solder issue. Set this to true if paper talks about solder defects but doesn't mention which ones.
	
	# component issues: 
    orientation: null # for components installed in the correct place, but with wrong orientation (inverted polarity, wrong pin 1 placement, etc).
    wrong_component: null # for components installed in the wrong location, might also detect components being installed where none should be.
    missing_component: null # for detection of empty places where some component has to be installed (e.g. empty pads that aren't supposed to stay empty).
    component_other: null # for any other or unspecified component issue. Set this to true if paper talks about component defects but doesn't mention which ones.
	
  # other issues:
	  cosmetic: null # cosmetic defects (any manufacturing defect that does not actually affect functionality: scratches, dirt, etc.);
    other: null #"string with any other types of defect detection not specified above"

technique:                # true, false, null for unknown/unclear. Identify all techniques used (if it's an implementation), or all techniques reviewed (if it's a survey). For each single DL-based implementation, set exactly one dl_* flag to true. For surveys (or papers that make more than one implementation) there may be multiple ones:
	classic_cv_based: null  # for general pattern recognition techniques that do not leverage machine learning: true if the method is entirely rule-based or uses classical image-processing / pattern-recognition without learned parameters (histogram matching, morphological filtering, template matching, etc.). May or may not leverage optimization algorithms, like genetic, PSO, etc.

	ml_traditional: null    # true for any non-deep ML: SVM, RF, K-NN, LVQ, Boosting, etc. Does not include deep learning like CNNs or Transformers.

	dl_cnn_classifier: null # true when the only DL component is a plain CNN used as an image classifier (ResNet-50, EfficientNet-B0, VGG, ): no detection, no segmentation, no attention blocks.
	dl_cnn_detector: null   # true for single-shot detectors whose backbone is CNN (YOLOv3, YOLOv4, YOLOv5, YOLOv6, YOLOv7, YOLOv9, YOLOv10, SSD, RetinaNet, FCOS, CenterNet, etc.).
	dl_rcnn_detector: null  # true for two-stage (R-CNN family) or anchor-based region proposal detectors: R-CNN, Fast R-CNN, Faster R-CNN, Mask R-CNN, Cascade R-CNN, DetectoRS, Sparse R-CNN, etc.
	dl_transformer: null    # true for any model whose core is attention/transformer blocks, including pure ViT, DETR, Deformable DETR, YOLOv8-seg, YOLOv12, RT-DETR, SegFormer, Swin, etc. Also, if the paper adds a transformer module to another model like a CNN, set both this and the corresponding CNN field as true.
	dl_other: null          # for any other DL architecture not covered above (e.g. pure Autoencoder, GAN, Diffusion, MLP-Mixer).

	hybrid: null            # true if the paper explicitly combines categories above (classic + DL, classic + ML, ML + DL).  If hybrid is true, also set each constituent technique to true.
	model: "name"			      # model name or comma-separated list if multiple models are used (YOLO, ResNet, DETR, etc.), null if not ML, "in-house" if unnamed ML model is developed in the paper itself.
	available_dataset: null # true if authors explicitly mention they're providing related datasets for the public, false if there's no dataset usage (e.g. for techniques not depending on a dataset) or if the dataset used is not provided to the public.
```
Please notice that the null may also have been recorded as None. Both are correct and have the same meaning for the parser.

Now, here is the Paper Content (real data) for your task:

*Title:* {title}
*Abstract:* {abstract}
*Keywords:* {keywords}
*Authors:* {authors}
*Publication Year:* {year}
*Publication Type:* {type}
*Publication Name:* {journal}

Automated Classification to Verify (inferred by a language model):

research_area: {research_area}
is_offtopic: {is_offtopic}
relevance: {relevance}
is_survey: {is_survey}
is_through_hole: {is_through_hole}
is_smt: {is_smt}
is_x_ray: {is_x_ray}
features:
{features}
technique:
{technique}

Your response is not being read by a human, it goes directly to an automated parser. After thinking through the request in <think></think> tags, output only the result in JSON format in plaintext without any other tags like ```json or similar.
```

```python
# verify_classification.py
# verify_classification.py
# This should be agnostic to changes inside features and techniques:
import sqlite3
import json
import argparse
import time
import os
from concurrent.futures import ThreadPoolExecutor
import queue
import threading
import signal
import globals  # Import for global settings and shared functions

def build_verification_prompt(paper_data, classification_data, template_content):
    """Builds the verification prompt string for a single paper using a loaded template."""
    # Prepare data for insertion into the template
    # Include original paper data
    format_data = {
        'title': paper_data.get('title', ''),
        'abstract': paper_data.get('abstract', ''),
        'keywords': paper_data.get('keywords', ''),
        'authors': paper_data.get('authors', ''),
        'year': paper_data.get('year', ''),
        'type': paper_data.get('type', ''),
        'journal': paper_data.get('journal', ''),
        'relevance': paper_data.get('relevance', ''),
    }
    
    # Include the LLM-generated classification data for verification
    # Convert complex fields (features, technique) back to JSON strings for template insertion
    classification_for_template = classification_data.copy()
    if isinstance(classification_for_template.get('features'), dict):
        classification_for_template['features'] = json.dumps(classification_for_template['features'], indent=2)
    if isinstance(classification_for_template.get('technique'), dict):
        classification_for_template['technique'] = json.dumps(classification_for_template['technique'], indent=2)
        
    # Add classification fields to format data
    format_data.update(classification_for_template)

    try:
        return template_content.format(**format_data)
    except KeyError as e:
        print(f"Error formatting verification prompt: Missing key {e} in paper/classification data or template expects it.")
        raise

def update_paper_verification(db_path, paper_id, verification_result, verified_by="LLM", reasoning_trace=None):
    """
    Updates the verification fields (verified, estimated_score, verified_by, verifier_trace)
    in the database for a specific paper.
    Does NOT update 'changed' or 'changed_by' as per requirements.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    verified = verification_result.get('verified')
    # Normalize verified value to database format (1, 0, None)
    if verified is True:
        verified_db_value = 1
    elif verified is False:
        verified_db_value = 0
    else: # None or anything else
        verified_db_value = None

    estimated_score = verification_result.get('estimated_score')
    # Ensure estimated_score is an integer within 0-100 or None
    if isinstance(estimated_score, (int, float)):
        estimated_score_db_value = max(0, min(100, int(estimated_score)))
    else:
        estimated_score_db_value = None

    # --- Prepare update fields and values ---
    update_fields = ["verified = ?", "estimated_score = ?", "verified_by = ?"]
    update_values = [verified_db_value, estimated_score_db_value, verified_by]

    # --- Add verifier_trace if provided ---
    if reasoning_trace is not None:
        update_fields.append("verifier_trace = ?")
        update_values.append(reasoning_trace)

    # --- Construct and execute the query ---
    update_query = f"UPDATE papers SET {', '.join(update_fields)} WHERE id = ?"
    update_values.append(paper_id) # Add paper_id for the WHERE clause

    try:
        cursor.execute(update_query, update_values) # Pass the combined list of values
        conn.commit()
        rows_affected = cursor.rowcount
    except Exception as e:
        print(f"[Thread-{threading.get_ident()}] Error updating verification for paper {paper_id}: {e}")
        rows_affected = 0
    finally:
        conn.close()
    return rows_affected > 0

def process_paper_verification_worker(
    db_path, 
    grammar_content, 
    verification_prompt_template_content, 
    paper_id_queue, 
    progress_lock, 
    processed_count, 
    total_papers, 
    model_alias
):
    """Worker function executed by each thread for verification."""
    while True:
        try:
            # Use timeout to periodically check for shutdown
            paper_id = paper_id_queue.get(timeout=1)
        except queue.Empty:
            # Check if we should shutdown periodically
            if globals.is_shutdown_flag_set():
                return
            continue

        # Poison pill - time to die
        if paper_id is None:
            return

        # Check for shutdown before processing
        if globals.is_shutdown_flag_set():
            return

        print(f"[Thread-{threading.get_ident()}] Verifying paper ID: {paper_id}")
        try:
            # 1. Fetch paper data and current classification from DB
            paper_data = globals.get_paper_by_id(db_path, paper_id)
            if not paper_data:
                print(f"[Thread-{threading.get_ident()}] Error: Paper {paper_id} not found in DB for verification.")
                continue

            # Prepare classification data for the prompt
            # Parse JSON fields back into dicts for the prompt builder
            classification_data = {}
            bool_fields = ['is_survey', 'is_offtopic', 'is_through_hole', 'is_smt', 'is_x_ray']
            for field in bool_fields:
                 # Convert DB integers (1,0,None) back to boolean/None for prompt clarity
                db_val = paper_data.get(field)
                if db_val == 1:
                    classification_data[field] = True
                elif db_val == 0:
                    classification_data[field] = False
                else: # None or unexpected
                    classification_data[field] = None

            classification_data['research_area'] = paper_data.get('research_area')

            # Handle JSON fields
            try:
                classification_data['features'] = json.loads(paper_data.get('features', '{}')) if paper_data.get('features') else {}
            except json.JSONDecodeError:
                classification_data['features'] = {}
                print(f"[Thread-{threading.get_ident()}] Warning: Could not parse features JSON for {paper_id}")

            try:
                classification_data['technique'] = json.loads(paper_data.get('technique', '{}')) if paper_data.get('technique') else {}
            except json.JSONDecodeError:
                classification_data['technique'] = {}
                print(f"[Thread-{threading.get_ident()}] Warning: Could not parse technique JSON for {paper_id}")

            # 2. Build the verification prompt
            prompt_text = build_verification_prompt(paper_data, classification_data, verification_prompt_template_content)
            
            if globals.is_shutdown_flag_set():
                return

            # 3. Send prompt to LLM
            json_result_str, model_name_used, reasoning_trace = globals.send_prompt_to_llm(
                prompt_text,
                grammar_text=grammar_content,
                server_url_base=globals.LLM_SERVER_URL,
                model_name=model_alias,
                is_verification=True
            )

            if globals.is_shutdown_flag_set():
                return

            # 4. Process LLM response
            if json_result_str:
                # print(f"[DEBUG] Raw LLM output for {paper_id}: {json_result_str}")
                try:
                    llm_verification_result = json.loads(json_result_str)
                    # 5. Update database with verification result
                    # Prepend model info to reasoning_trace
                    if reasoning_trace:
                        reasoning_trace = f"As verified by {model_name_used}\n\n{reasoning_trace}"
                    else:
                        reasoning_trace = f"As verified by {model_name_used}"

                    success = update_paper_verification(
                        db_path,
                        paper_id,
                        llm_verification_result,
                        verified_by=model_name_used,
                        reasoning_trace=reasoning_trace
                    )
                    if success:
                        print(f"[Thread-{threading.get_ident()}] Verified paper {paper_id} (Model: {model_name_used})")
                    else:
                        print(f"[Thread-{threading.get_ident()}] No verification changes or error for paper {paper_id}")
                except json.JSONDecodeError as e:
                    print(f"[Thread-{threading.get_ident()}] Error parsing LLM verification output for {paper_id}: {e}")
                    print(f"LLM Output: {json_result_str}")
                except Exception as e:
                    print(f"[Thread-{threading.get_ident()}] Error updating DB verification for {paper_id}: {e}")
            else:
                if not globals.is_shutdown_flag_set():
                    print(f"[Thread-{threading.get_ident()}] No LLM verification response for {paper_id}")

        except Exception as e:
            if not globals.is_shutdown_flag_set():
                print(f"[Thread-{threading.get_ident()}] Error verifying {paper_id}: {e}")
        finally:
            if globals.is_shutdown_flag_set():
                return
            with progress_lock:
                processed_count[0] += 1
                print(f"[Progress] Verified {processed_count[0]}/{total_papers} papers.")

def run_verification(mode='remaining', paper_id=None, db_file=None, grammar_file=None, prompt_template=None, server_url=None):
    """
    Runs the LLM verification process.

    Args:
        mode (str): 'all', 'remaining', or 'id'. Defaults to 'remaining'.
        paper_id (int, optional): The specific paper ID to verify (required if mode='id').
        db_file (str): Path to the SQLite database.
        grammar_file (str): Path to the GBNF grammar file.
        prompt_template (str): Path to the verification prompt template file.
        server_url (str): Base URL of the LLM server.
    """
    if db_file is None:
        db_file = globals.DATABASE_FILE
    if grammar_file is None:
        grammar_file = globals.GRAMMAR_FILE
    if prompt_template is None:
        prompt_template = globals.VERIFIER_TEMPLATE
    if server_url is None:
        server_url = globals.LLM_SERVER_URL

    if not os.path.exists(db_file):
        print(f"Error: Database file '{db_file}' not found.")
        return False

    try:
        verification_prompt_template_content = globals.load_prompt_template(prompt_template)
        print(f"Loaded verification prompt template from '{prompt_template}'")
    except Exception as e:
        print(f"Error loading verification prompt template: {e}")
        return False

    grammar_content = None
    if grammar_file:
        try:
            grammar_content = globals.load_grammar(grammar_file)
            print(f"Loaded GBNF grammar from '{grammar_file}' for verification")
        except Exception as e:
            print(f"Warning: Error reading grammar file for verification: {e}")
            grammar_content = None

    print("Fetching model alias from LLM server for verification...")
    model_alias = globals.get_model_alias(server_url)
    if not model_alias:
        print("Error: Could not determine model alias for verification. Exiting.")
        return False

    print(f"Connecting to database '{db_file}' to fetch papers for verification...")
    try:
        conn = sqlite3.connect(db_file)
        cursor = conn.cursor()
        
        if mode == 'all': #All classified papers (there's no sense in verifying classification of papers that weren't even classified)
            print("Fetching ALL classified papers for re-verification...")
            cursor.execute("SELECT id FROM papers WHERE (changed_by IS NOT NULL AND changed_by != '')")
        elif mode == 'id':
            if paper_id is None:
                print("Error: Mode 'id' requires a specific paper ID.")
                conn.close()
                return False
            print(f"Fetching specific paper ID: {paper_id} for verification...")
            cursor.execute("SELECT id FROM papers WHERE id = ?", (paper_id,))
            if not cursor.fetchone():
                 print(f"Warning: Paper ID {paper_id} not found or not classified.")
                 conn.close()
                 return True
            cursor.execute("SELECT id FROM papers WHERE id = ?", (paper_id,))
        else: # Default to 'remaining'
            print("Fetching classified but unverified papers...")
            cursor.execute("""
                SELECT id 
                FROM papers 
                WHERE (changed_by IS NOT NULL AND changed_by != '') 
                AND (verified_by IS NULL OR verified_by = '' OR verified = 'unknown' OR verified = '')
            """) #added  OR verified_by = 'unknown' to verify to manually set to ?
            
        paper_ids = [row[0] for row in cursor.fetchall()]
        conn.close()
        total_papers = len(paper_ids)
        print(f"Found {total_papers} paper(s) to verify based on mode '{mode}'.")
    except Exception as e:
        print(f"Error fetching paper IDs: {e}")
        return False

    if not paper_ids:
        print("No papers found matching the verification criteria. Nothing to process.")
        return True

    paper_id_queue = queue.Queue()
    for pid in paper_ids:
        paper_id_queue.put(pid)

    # Add poison pills for each worker thread
    for _ in range(globals.MAX_CONCURRENT_WORKERS):
        paper_id_queue.put(None)

    progress_lock = threading.Lock()
    processed_count = [0]

    print(f"Starting ThreadPoolExecutor with {globals.MAX_CONCURRENT_WORKERS} workers for verification...")
    start_time = time.time()

    try:
        with ThreadPoolExecutor(max_workers=globals.MAX_CONCURRENT_WORKERS) as executor:
            futures = []
            for _ in range(globals.MAX_CONCURRENT_WORKERS):
                future = executor.submit(
                    process_paper_verification_worker,
                    db_file,
                    grammar_content,
                    verification_prompt_template_content,
                    paper_id_queue,
                    progress_lock,
                    processed_count,
                    total_papers,
                    model_alias
                )
                futures.append(future)
            
            print("Verification processing started. Press Ctrl+C to abort.")
            
            while not globals.is_shutdown_flag_set():
                if all(f.done() for f in futures):
                    break
                time.sleep(0.1)

    except KeyboardInterrupt:
        print("\nKeyboardInterrupt caught in run_verification. Setting shutdown flag.")
        globals.set_shutdown_flag()
    except Exception as e:
        print(f"Error in main verification execution loop: {e}")
        globals.set_shutdown_flag()
    finally:
        end_time = time.time()
        final_count = 0
        if progress_lock:
            with progress_lock:
                final_count = processed_count[0] if processed_count else 0
        print(f"\n--- Verification Summary ---")
        print(f"Papers verified: {final_count}/{total_papers}")
        print(f"Time taken: {end_time - start_time:.2f} seconds")
        print("Verification run finished.")
        return not globals.is_shutdown_flag_set()
    
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Verify LLM classifications for papers in the database.')
    parser.add_argument('--mode', '-m', choices=['all', 'remaining', 'id'], default='remaining',
                        help="Verification mode: 'all' (verify all classified), 'remaining' (verify unverified), 'id' (verify a specific paper). Default: 'remaining'.")
    parser.add_argument('--paper_id', '-i', type=int, help='Paper ID to verify (required if --mode id).')
    parser.add_argument('--db_file', default=globals.DATABASE_FILE,
                       help=f'SQLite database file path (default: {globals.DATABASE_FILE})')
    parser.add_argument('--grammar_file', '-g', default=globals.GRAMMAR_FILE,
                       help=f'Path to the GBNF grammar file (default: {globals.GRAMMAR_FILE})')
    parser.add_argument('--prompt_template', '-t', default=globals.VERIFIER_TEMPLATE,
                       help=f'Path to the verification prompt template file (default: {globals.VERIFIER_TEMPLATE})')
    parser.add_argument('--server_url', default=globals.LLM_SERVER_URL,
                       help=f'Base URL of the LLM server (default: {globals.LLM_SERVER_URL})')
    args = parser.parse_args()

    signal.signal(signal.SIGINT, globals.signal_handler)

    if args.mode == 'id' and args.paper_id is None:
        parser.error("--mode 'id' requires --paper_id to be specified.")

    success = run_verification(
        mode=args.mode,
        paper_id=args.paper_id,
        db_file=args.db_file,
        grammar_file=args.grammar_file,
        prompt_template=args.prompt_template,
        server_url=args.server_url
    )

    if not success and not globals.is_shutdown_flag_set():
        exit(1)
```

```javascript
# static\comms.js
// static/comms.js
/** For detail row retrieval and any functionality that reads/writes to the server (DB query/updates, etc). 
 * Some functions here are reimplemented as a client-side version in ghpages.js for the HTML export.
 * */
// --- New Global Variables for Batch Status ---
let isBatchRunning = false; // Simple flag to prevent multiple simultaneous batches


// --- Status Cycling Logic ---
const STATUS_CYCLE = {
    '': { next: '', value: 'true' },
    '': { next: '', value: 'false' },
    '': { next: '', value: 'unknown' }
};
const VERIFIED_BY_CYCLE = {
    '': { next: '', value: 'unknown' }, 
    '': { next: '', value: 'user' },   
    // If user sees Computer (), next is User:
    // We assume the user wants to override/review it, not set it to computer.
    '': { next: '', value: 'user' } 
};

/**
 * Helper to update a cell's status symbol based on boolean/null value.
 * @param {Element} row - The main table row element.
 * @param {string} selector - The CSS selector for the cell within the row.
 * @param {*} value - The value (true, false, null, undefined) to determine the symbol.
 */
function updateRowCell(row, selector, value) {
    const cell = row.querySelector(selector);
    if (cell) {
        cell.textContent = renderStatus(value); // Use the renderStatus function
    }
}

/**
 * Renders a status value (true, false, null, etc.) as an emoji.
 * Replicates Python's render_status logic on the client.
 * @param {*} value - The value to render.
 * @returns {string} The emoji string.
 */
function renderStatus(value) {
    if (value === 1 || value === true) {
        return '';
    } else if (value === 0 || value === false) {
        return '';
    } else {
        return '';
    }
}

/**
 * Renders a verified_by value (user, model_name, null) as an emoji with tooltip.
 * Replicates Python's render_verified_by logic on the client.
 * @param {*} value - The raw database value.
 * @returns {string} The HTML string for the emoji span.
 */
function renderVerifiedBy(value) {
     if (value === 'user') {
        return '<span title="User"></span>';
    } else if (value === null || value === undefined || value === '') {
        return '<span title="Unverified"></span>';
    } else {
        // Escape the model name for HTML attribute safety (basic escaping)
        let escapedModelName = String(value).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        return `<span title="${escapedModelName}"></span>`;
    }
}

// --- Helper function to render changed_by value as emoji (Client-Side) ---
function renderChangedBy(value) {
    // This replicates the logic from Python's render_changed_by function
    if (value === 'user') {
        return '<span title="User"></span>';
    } else if (value === null || value === undefined || value === '') {
        return '<span title="Unknown"></span>';
    } else {
        // Escape the model name for HTML attribute safety (basic escaping)
        // Using a simple replace for quotes. For more robust escaping, consider a library.
        let escapedModelName = String(value).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        return `<span title="${escapedModelName}"></span>`;
    }
}

// --- Extracted AJAX logic for reuse ---
function sendAjaxRequest(cell, dataToSend, currentText, row, paperId, field) {
    // Use the same endpoint as the form save
    const saveButton = row.querySelector('.save-btn'); // Find save button in details if needed for disabling
    const wasSaveButtonDisabled = saveButton ? saveButton.disabled : false;
    if (saveButton) saveButton.disabled = true; // Optional: disable main save while quick save happens

    fetch('/update_paper', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(dataToSend)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(errData => {
                throw new Error(errData.message || `HTTP error! status: ${response.status}`);
            }).catch(() => {
                throw new Error(`HTTP error! status: ${response.status}`);
            });
        }
        return response.json();
    })
    .then(data => {
        if (data.status === 'success') {
            // 4. Update other relevant cells in the row based on the response
            const mainRow = document.querySelector(`tr[data-paper-id="${paperId}"]`);
            if (mainRow) {
                // Update audit fields (using formatted timestamp sent back)
                if (data.changed_formatted !== undefined) {
                    mainRow.querySelector('.changed-cell').textContent = data.changed_formatted;
                }
                if (data.changed_by !== undefined) {
                    mainRow.querySelector('.changed-by-cell').innerHTML = renderChangedBy(data.changed_by);
                }
                if (data.estimated_score !== undefined) {
                     const estimatedScoreCell = mainRow.cells[estScoreCellIndex]; 
                     if (estimatedScoreCell) {
                         estimatedScoreCell.textContent = data.estimated_score !== null && data.estimated_score !== undefined ? data.estimated_score : ''; // Example formatting
                     }
                }
            }
            updateCounts();
            console.log(`Quick save successful for ${paperId} field ${field}`);
        } else {
            console.error('Quick save error:', data.message);
            cell.textContent = currentText; // Revert text
        }
    })
    .catch((error) => {
        console.error('Quick save error:', error);
        cell.textContent = currentText; // Revert text
    })
    .finally(() => {
        if (saveButton) saveButton.disabled = wasSaveButtonDisabled;
    });
}

function saveChanges(paperId) {
    const form = document.getElementById(`form-${paperId}`);
    if (!form) {
        console.error(`Form not found for paper ID: ${paperId}`);
        return;
    }
    // --- Collect Main Fields ---
    const researchAreaInput = form.querySelector('input[name="research_area"]');
    const researchAreaValue = researchAreaInput ? researchAreaInput.value : '';
    const pageCountInput = form.querySelector('input[name="page_count"]');
    let pageCountValue = pageCountInput ? pageCountInput.value : '';
    // Convert empty string or invalid input to NULL for the database
    if (pageCountValue === '') {
        pageCountValue = null;
    } else {
        const parsedValue = parseInt(pageCountValue, 10);
        if (isNaN(parsedValue)) {
            pageCountValue = null; // Or handle error as needed
        } else {
            pageCountValue = parsedValue;
        }
    }

    // --- NEW: Collect Relevance Field ---
    const relevanceInput = form.querySelector('input[name="relevance"]');
    let relevanceValue = relevanceInput ? relevanceInput.value : '';
    // Convert empty string to NULL for the database consistency (optional but good practice)
    if (relevanceValue === '') {
        relevanceValue = null;
    } else {
        // If you want to ensure it's a number, uncomment the next lines:
        const parsedRelevance = parseFloat(relevanceValue); // or parseInt if it's an integer
        if (isNaN(parsedRelevance)) {
            relevanceValue = null; // Or handle error
        } else {
            relevanceValue = parsedRelevance;
        }
    }


    // --- Collect Additional Fields ---
    // Model Name -> technique_model
    const modelNameInput = form.querySelector('input[name="model_name"]');
    const modelNameValue = modelNameInput ? modelNameInput.value : '';
    // Other Defects -> features_other
    const otherDefectsInput = form.querySelector('input[name="features_other"]');
    const otherDefectsValue = otherDefectsInput ? otherDefectsInput.value : '';
    // User Comments -> user_trace (stored in main table column, not features/technique JSON)
    const userCommentsTextarea = form.querySelector('textarea[name="user_trace"]');
    const userCommentsValue = userCommentsTextarea ? userCommentsTextarea.value : '';

    // --- Prepare Data Payload ---
    const data = {
        id: paperId,
        research_area: researchAreaValue,
        page_count: pageCountValue,
        // --- NEW: Add Relevance Field to Payload ---
        relevance: relevanceValue,
        // --- Add Additional Fields to Payload ---
        // Prefix 'technique_' and 'features_' are handled by the backend
        technique_model: modelNameValue,
        features_other: otherDefectsValue,
        user_trace: userCommentsValue // This one is a direct column update
    };

    // --- UI Feedback and AJAX Call (Remains Largely the Same) ---
    const saveButton = form.querySelector('.save-btn');
    const originalText = saveButton ? saveButton.textContent : 'Save Changes';
    if (saveButton) {
        saveButton.textContent = 'Saving...';
        saveButton.disabled = true;
    }
    fetch('/update_paper', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data) // <-- Send the updated data object
    })
    .then(response => {
        if (!response.ok) {
             return response.json().then(errData => {
                 throw new Error(errData.message || `HTTP error! status: ${response.status}`);
             }).catch(() => {
                 throw new Error(`HTTP error! status: ${response.status}`);
             });
        }
        return response.json();
    })
    .then(data => {
        if (data.status === 'success') {
            const row = document.querySelector(`tr[data-paper-id="${paperId}"]`);
            if (row) {
                // Update displayed audit fields if returned
                if (data.changed_formatted !== undefined) {
                    row.querySelector('.changed-cell').textContent = data.changed_formatted;
                }
                if (data.changed_by !== undefined) {
                    row.querySelector('.changed-by-cell').innerHTML = renderChangedBy(data.changed_by);
                }
                // Update displayed page count if returned
                const pageCountCell = row.cells[pageCountCellIndex];
                if (pageCountCell) {
                     pageCountCell.textContent = data.page_count !== null && data.page_count !== undefined ? data.page_count : '';
                }
                // --- NEW: Update displayed relevance if returned ---
                // Find the relevance cell in the main row (adjust selector if needed)
                const relevanceCell = row.cells[relevanceCellIndex]; // Or better, add a class like .relevance-cell to the <td> and use '.relevance-cell'
                if (relevanceCell) {
                     relevanceCell.textContent = data.relevance !== null && data.relevance !== undefined ? data.relevance : '';
                }
                // Note: The UI fields (model_name, features_other, user_trace) are NOT updated here
                // from the server response because update_paper_custom_fields doesn't return them.
                // They retain the user-entered value after saving.
            }
            // Collapse details row after successful save
            const toggleBtn = row ? row.querySelector('.toggle-btn') : null;
            if (toggleBtn && row && row.nextElementSibling && row.nextElementSibling.classList.contains('expanded')) {
                 toggleDetails(toggleBtn);
            }
            if (saveButton) {
                saveButton.textContent = 'Saved!';
                setTimeout(() => {
                    if (saveButton) {
                        saveButton.textContent = originalText;
                        saveButton.disabled = false;
                    }
                }, 1500);
            }
            updateCounts();
        } else {
            console.error('Save error:', data.message);
            if (saveButton) {
                saveButton.textContent = originalText;
                saveButton.disabled = false;
            }
        }
    })
    .catch((error) => {
        console.error('Error:', error);
        if (saveButton) {
            saveButton.textContent = originalText;
            saveButton.disabled = false;
        }
    });
}



function toggleDetails(element) {   //has server-based logic
    const row = element.closest('tr');
    const detailRow = row.nextElementSibling;
    const isExpanded = detailRow && detailRow.classList.contains('expanded');
    const paperId = row.getAttribute('data-paper-id');

    if (isExpanded) {
        detailRow.classList.remove('expanded');
        element.innerHTML = '<span>Show</span>';
    } else {
        detailRow.classList.add('expanded');
        element.innerHTML = '<span>Hide</span>';
        const contentPlaceholder = detailRow.querySelector('.detail-content-placeholder');
        fetch(`/get_detail_row?paper_id=${encodeURIComponent(paperId)}`)
            .then(response => {
                return response.json();
            })
            .then(data => {
                if (data.status === 'success' && data.html) {
                    contentPlaceholder.innerHTML = data.html;
                } else {  // Handle error from server
                    console.error(`Error loading detail row for paper ${paperId}:`, data.message);
                    if (contentPlaceholder) {
                        contentPlaceholder.innerHTML = `<p>Error loading details: ${data.message || 'Unknown error'}</p>`;
                    }
                }
            })
            .catch(error => {  // Handle network or other errors
                console.error(`Error fetching detail row for paper ${paperId}:`, error);
                if (contentPlaceholder) {
                    contentPlaceholder.innerHTML = `<p>Error loading details: ${error.message}</p>`;
                }
            });
    }
}

function applyServerSideFilters() {     //moved from filtering as it has server-based
    document.documentElement.classList.add('busyCursor');
    const urlParams = new URLSearchParams(window.location.search);

    const isOfftopicChecked = hideOfftopicCheckbox.checked;
    urlParams.set('hide_offtopic', isOfftopicChecked ? '1' : '0');

    const yearFromValue = document.getElementById('year-from').value.trim();
    if (yearFromValue !== '' && !isNaN(parseInt(yearFromValue))) {
        urlParams.set('year_from', yearFromValue);
    } else {
        urlParams.delete('year_from');
    }
    const yearToValue = document.getElementById('year-to').value.trim();
    if (yearToValue !== '' && !isNaN(parseInt(yearToValue))) {
        urlParams.set('year_to', yearToValue);
    } else {
        urlParams.delete('year_to');
    }

    const minPageCountValue = document.getElementById('min-page-count').value.trim();
    if (minPageCountValue !== '' && !isNaN(parseInt(minPageCountValue))) {
        urlParams.set('min_page_count', minPageCountValue);
    } else {
        urlParams.delete('min_page_count');
    }

    // const searchValue = document.getElementById('search-input').value.trim();
    // if (searchValue !== '') {
    //     urlParams.set('search_query', searchValue);
    // } else {
    //     urlParams.delete('search_query');
    // }
    // Construct the URL for the /load_table endpoint with current parameters
    const loadTableUrl = `/load_table?${urlParams.toString()}`;
    fetch(loadTableUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(html => {
            const tbody = document.querySelector('#papersTable tbody');
            if (tbody) {
                tbody.innerHTML = html;
                const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
                window.history.replaceState({ path: newUrl }, '', newUrl);
                applyLocalFilters(); //update local filters and let it remove busy state
            }
        })
        .catch(error => {
            console.error('Error fetching updated table:', error);
            document.documentElement.classList.remove('busyCursor');
        });
}





// Add a hidden file input element dynamically if it doesn't exist already
// (This avoids needing to add it to index.html)
if (!document.getElementById('pdf-file-input')) {
    const hiddenFileInput = document.createElement('input');
    hiddenFileInput.type = 'file';
    hiddenFileInput.id = 'pdf-file-input';
    hiddenFileInput.accept = '.pdf'; // Only accept PDF files
    hiddenFileInput.style.display = 'none';
    document.body.appendChild(hiddenFileInput);
}

// Reference the hidden input
const pdfFileInput = document.getElementById('pdf-file-input');

// Function to handle the actual upload
function uploadPDFForPaper(paperId) {
    const file = pdfFileInput.files[0];
    if (!file) {
        console.error("No file selected for upload.");
        alert("No file selected.");
        return;
    }

    if (!file.name.toLowerCase().endsWith('.pdf')) {
         alert("Please select a PDF file.");
         return;
    }

    const formData = new FormData();
    formData.append('pdf_file', file);

    // Show a simple loading indicator or disable interaction temporarily
    const uploadLink = document.querySelector(`.pdf-upload-link[data-paper-id="${paperId}"]`);
    if (uploadLink) {
        uploadLink.textContent = ''; // Change icon to indicate processing
        uploadLink.style.pointerEvents = 'none'; // Disable clicks temporarily
    }

    fetch(`/upload_pdf/${encodeURIComponent(paperId)}`, { // Use encodeURIComponent for the string ID
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            console.log("PDF uploaded successfully for paper ID:", paperId);
            // Update the table row with the new PDF info
            // Pass the filename and state received from the server
            updateTableRowWithPDFData(paperId, data.pdf_filename, data.pdf_state);
        } else {
            console.error("Upload failed:", data.message);
            alert(`Upload failed: ${data.message}`);
            // Re-enable the link if it failed
             if (uploadLink) {
                 uploadLink.textContent = '';
                 uploadLink.style.pointerEvents = 'auto';
             }
        }
    })
    .catch(error => {
        console.error("Error during upload:", error);
        alert("An error occurred during upload.");
        // Re-enable the link if it failed
        if (uploadLink) {
            uploadLink.textContent = '';
            uploadLink.style.pointerEvents = 'auto';
        }
    });
}

function updateTableRowWithPDFData(paperId, filename) {
    const row = document.querySelector(`tr[data-paper-id="${paperId}"]`);
    if (!row) {
        console.error(`Row for paper ID ${paperId} not found.`);
        return;
    }

    const pdfCell = row.cells[pdfCellIndex]; // PDF cell is the second cell (index 1)
    if (!pdfCell) {
        console.error(`PDF cell for paper ID ${paperId} not found.`);
        return;
    }

    // Remove .pdf extension from filename for the viewer URL
    const filenameWithoutExtension = filename.replace(/\.pdf$/i, '');
    
    // Create the new link element for the PDF.js viewer
    const pdfLink = document.createElement('a');
    pdfLink.href = `/static/pdfjs/web/viewer.html?file=/serve_pdf/${encodeURIComponent(filenameWithoutExtension)}`;
    pdfLink.target = '_blank';
    pdfLink.title = `Open PDF.js Annotator for: ${filename}`;
    pdfLink.textContent = '';

    // Replace the cell content with the new link
    pdfCell.innerHTML = ''; // Clear existing content (like '')
    pdfCell.appendChild(pdfLink);
    pdfCell.title = "PDF Status"; // Set title back
}

// Event delegation for the PDF upload links
document.addEventListener('click', function(event) {
    if (event.target.classList.contains('pdf-upload-link')) {
        event.preventDefault(); // Prevent default link behavior
        // Get the paper ID as a string directly
        const paperId = event.target.getAttribute('data-paper-id');
        if (!paperId) { // Check if the ID string is empty or null
            console.error("Invalid or missing paper ID for PDF upload link.");
            return;
        }

        console.log("Attempting upload for paper ID:", paperId); // Debug log

        // Reset the file input to allow selecting the same file again
        pdfFileInput.value = '';

        // Add event listener for when a file is selected
        pdfFileInput.onchange = function(e) {
            if (e.target.files.length > 0) {
                uploadPDFForPaper(paperId);
            }
        };

        // Trigger the hidden file input click
        pdfFileInput.click();
    }
});


/** Functionality below is exclusive to server-based implementation (e.g, not HTML exports) */
//globals.js
const batchModal = document.getElementById("batchModal");
const importModal = document.getElementById("importModal");
const exportModal = document.getElementById("exportModal");

//Checkboxes:  

const minPageCountInput = document.getElementById('min-page-count');
const yearFromInput = document.getElementById('year-from');
const yearToInput = document.getElementById('year-to');
const applyButton = document.getElementById('apply-serverside-filters');
// const totalPapersCountCell = document.getElementById('total-papers-count');


// --- Batch Action Button Event Listeners ---
const paraToolsBtn = document.getElementById('para-tools-btn');
const classifyAllBtn = document.getElementById('classify-all-btn');
const classifyRemainingBtn = document.getElementById('classify-remaining-btn');
const verifyAllBtn = document.getElementById('verify-all-btn');
const verifyRemainingBtn = document.getElementById('verify-remaining-btn');
const batchStatusMessage = document.getElementById('batch-status-message');
const backupStatusMessage = document.getElementById('backup-status-message');

const importActionsBtn = document.getElementById('import-btn');
const exportActionsBtn = document.getElementById('export-btn');

const backupBtn = document.getElementById('backup-btn');
const restoreBtn = document.getElementById('restore-btn');

//show/hide modals:

function showBatchActions(){
    batchModal.offsetHeight;
    batchModal.classList.add('modal-active');
}
function closeBatchModal() { batchModal.classList.remove('modal-active'); }

function showImportActions(){
    importModal.offsetHeight;
    importModal.classList.add('modal-active');
}
function closeImportModal() { importModal.classList.remove('modal-active'); }

function showExportActions(){
    exportModal.offsetHeight;
    exportModal.classList.add('modal-active');   
    backupStatusMessage.innerHTML = 'Backups include the database, original and annotated PDFs, HTML export and a XLSX spreadsheet.<br><br>Restoring from a backup overwrites all existing data!';
    backupStatusMessage.style.color = '';
}
function closeExporthModal() { exportModal.classList.remove('modal-active'); }

function showApplyButton(){  applyButton.style.opacity = '1'; applyButton.style.pointerEvents = 'visible'; }



document.addEventListener('DOMContentLoaded', function () {
    
    yearFromInput.addEventListener('change', showApplyButton);
    yearToInput.addEventListener('change', showApplyButton);
    minPageCountInput.addEventListener('change', showApplyButton);
    hideOfftopicCheckbox.addEventListener('change', applyServerSideFilters);

    applyButton.addEventListener('click', applyServerSideFilters);

    //server-side search disabled for now as FTS is broken. Using full-client-side search instead:

    // document.getElementById('search-input').addEventListener('input', function () {
    //     clearTimeout(filterTimeoutId);
    //     filterTimeoutId = setTimeout(() => {
    //         applyServerSideFilters();
    //     }, 300);  //additional debounce for typing
    // });

    // Click Handler for Editable Status Cells
    document.addEventListener('click', function (event) {
        // Check if the clicked element is an editable status cell
        if (event.target.classList.contains('editable-status')) {
            const cell = event.target;
            const currentText = cell.textContent.trim();
            const field = cell.getAttribute('data-field');
            const row = cell.closest('tr[data-paper-id]'); // Find the parent row with the paper ID
            const paperId = row ? row.getAttribute('data-paper-id') : null;
            if (!paperId) {
                console.error('Paper ID not found for clicked cell.');
                return;
            }
            // Find the next status in the general cycle
            const nextStatusInfo = STATUS_CYCLE[currentText];
            if (!nextStatusInfo) {
                console.error('Unknown status symbol:', currentText);
                // default to unknown if symbol is unrecognized
                const defaultNextStatusInfo = STATUS_CYCLE[''];
                cell.textContent = defaultNextStatusInfo.next;
                // Prepare data for AJAX using the default value
                const dataToSend = {
                    id: paperId,
                    [field]: defaultNextStatusInfo.value
                };
                sendAjaxRequest(cell, dataToSend, currentText, row, paperId, field);
                return;
            }
            const nextSymbol = nextStatusInfo.next;
            const nextValue = nextStatusInfo.value;

            // 1. Immediately update the UI (for general fields)
            cell.textContent = nextSymbol;
            cell.style.backgroundColor = '#f9e79f'; // Light yellow flash
            setTimeout(() => {
                 // Ensure we only reset the background if it hasn't changed again
                 if (cell.textContent === nextSymbol) {
                     cell.style.backgroundColor = ''; // Reset to default
                 }
            }, 300);

            // 2. Prepare data for the AJAX request (for general fields)
            const dataToSend = {
                id: paperId,
                [field]: nextValue
            };
            sendAjaxRequest(cell, dataToSend, currentText, row, paperId, field);
        }
    });

    // Click Handler for Editable Verify Cell (verified_by)
    document.addEventListener('click', function (event) {
        // Find the closest .editable-verify ancestor (handles clicks on <span> inside)
        const cell = event.target.closest('.editable-verify');
        if (!cell) return; // Not a verify cell or child thereof

        const currentSpan = cell.querySelector('span');
        if (!currentSpan) return;

        const currentSymbol = currentSpan.textContent.trim();
        const field = cell.getAttribute('data-field'); // Should be "verified_by"
        const row = cell.closest('tr[data-paper-id]');
        const paperId = row ? row.getAttribute('data-paper-id') : null;

        if (!paperId) {
            console.error('Paper ID not found for clicked cell.');
            return;
        }

        const nextStatusInfo = VERIFIED_BY_CYCLE[currentSymbol];
        if (!nextStatusInfo) {
            console.error('Unknown verified_by symbol:', currentSymbol);
            return;
        }

        const nextSymbol = nextStatusInfo.next;
        const nextValue = nextStatusInfo.value; // 'user', 'unknown'

        // 1. Immediately update the UI
        if (nextValue === 'user') {
            cell.innerHTML = '<span title="User"></span>';
        } else {
            cell.innerHTML = '<span title="Unverified"></span>';
        }

        cell.style.backgroundColor = '#f9e79f'; // Light yellow flash
        setTimeout(() => {
            if (cell.querySelector('span')?.textContent.trim() === nextSymbol) {
                cell.style.backgroundColor = '';
            }
        }, 300);

        // 2. Prepare data for AJAX
        const dataToSend = {
            id: paperId,
            [field]: nextValue === 'unknown' ? null : nextValue
        };

        // 3. Send AJAX request
        sendAjaxRequest(cell, dataToSend, currentSymbol, row, paperId, field);
    });
    function runBatchAction(mode, actionType) { // actionType: 'classify' or 'verify'
        if (isBatchRunning) {
            alert(`A ${actionType} batch is already running.`);
            return;
        }

        if (!confirm(`Are you sure you want to ${actionType} ${mode === 'all' ? 'ALL' : 'REMAINING'} papers? This might take a while.`)) {
            return;
        }

        isBatchRunning = true;
        const btnToDisable = mode === 'all' ? (actionType === 'classify' ? classifyAllBtn : verifyAllBtn) :
                                              (actionType === 'classify' ? classifyRemainingBtn : verifyRemainingBtn);
        const otherBtns = [classifyAllBtn, classifyRemainingBtn, verifyAllBtn, verifyRemainingBtn].filter(btn => btn !== btnToDisable);

        if (btnToDisable) btnToDisable.disabled = true;
        otherBtns.forEach(btn => btn.disabled = true);
        if (batchStatusMessage) batchStatusMessage.textContent = `Starting ${actionType} (${mode})...`;

        const endpoint = actionType === 'classify' ? '/classify' : '/verify';

        fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ mode: mode })
        })
        .then(response => {
             if (!response.ok) {
                 return response.json().then(errData => {
                     throw new Error(errData.message || `HTTP error! status: ${response.status}`);
                 }).catch(() => {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 });
             }
             return response.json();
        })
        .then(data => {
            if (data.status === 'started') {
                if (batchStatusMessage) batchStatusMessage.textContent = data.message;
                // Batch started, it's running in the background.
                // To re-enable buttons after a short delay or assume user knows it's running
                //  setTimeout(() => {
                //      isBatchRunning = false; // Allow new batches after a short time
                //      if (btnToDisable) btnToDisable.disabled = false;
                //      otherBtns.forEach(btn => btn.disabled = false);
                //     //  if (batchStatusMessage) batchStatusMessage.textContent += " (Background task running)";
                //  }, 2000); // Assume it started successfully after 2s
            } else {
                 // This shouldn't happen for batch actions, but handle if it does
                 console.error(`Unexpected response for batch ${actionType}:`, data);
                 if (batchStatusMessage) batchStatusMessage.textContent = `Error initiating ${actionType} (${mode}).`;
                 isBatchRunning = false;
                 if (btnToDisable) btnToDisable.disabled = false;
                 otherBtns.forEach(btn => btn.disabled = false);
            }
        })
        .catch(error => {
            console.error(`Error initiating batch ${actionType} (${mode}):`, error);
            alert(`Failed to start ${actionType} (${mode}): ${error.message}`);
            isBatchRunning = false;
            if (btnToDisable) btnToDisable.disabled = false;
            otherBtns.forEach(btn => btn.disabled = false);
            if (batchStatusMessage) batchStatusMessage.textContent = '';
        });
    }

    paraToolsBtn.addEventListener('click', showBatchActions);
    classifyAllBtn.addEventListener('click', () => runBatchAction('all', 'classify'));
    classifyRemainingBtn.addEventListener('click', () => runBatchAction('remaining', 'classify'));
    verifyAllBtn.addEventListener('click', () => runBatchAction('all', 'verify'));
    verifyRemainingBtn.addEventListener('click', () => runBatchAction('remaining', 'verify'));

    importActionsBtn.addEventListener('click', showImportActions);
    exportActionsBtn.addEventListener('click', showExportActions);

    // --- Per-Row Action Button Event Listeners ---
    document.addEventListener('click', function(event) {
        const classifyBtn = event.target.closest('.classify-btn');
        const verifyBtn = event.target.closest('.verify-btn');

        if (classifyBtn || verifyBtn) {
            const paperId = (classifyBtn || verifyBtn).getAttribute('data-paper-id');
            const actionType = classifyBtn ? 'classify' : 'verify';
            const endpoint = classifyBtn ? '/classify' : '/verify';

            if (!paperId) {
                console.error(`Paper ID not found for ${actionType} button.`);
                return;
            }

            // Disable the button temporarily
            (classifyBtn || verifyBtn).disabled = true;
            (classifyBtn || verifyBtn).textContent = 'Running...';

            // Send AJAX request
            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ mode: 'id', paper_id: paperId })
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => {
                         throw new Error(errData.message || `HTTP error! status: ${response.status}`);
                    }).catch(() => {
                         throw new Error(`HTTP error! status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    // Update the row with the received data
                    const row = document.querySelector(`tr[data-paper-id="${paperId}"]`);
                    const detailRow = row ? row.nextElementSibling : null;
                    if (row) {
                        // Update main row cells
                        updateRowCell(row, '.editable-status[data-field="is_offtopic"]', data.is_offtopic);
                        updateRowCell(row, '.editable-status[data-field="is_survey"]', data.is_survey);
                        updateRowCell(row, '.editable-status[data-field="is_through_hole"]', data.is_through_hole);
                        updateRowCell(row, '.editable-status[data-field="is_smt"]', data.is_smt);
                        updateRowCell(row, '.editable-status[data-field="is_x_ray"]', data.is_x_ray);

                        // Replace the existing feature updates with:
                        updateRowCell(row, '.editable-status[data-field="features_tracks"]', data.features?.tracks);
                        updateRowCell(row, '.editable-status[data-field="features_holes"]', data.features?.holes);
                        updateRowCell(row, '.editable-status[data-field="features_solder_insufficient"]', data.features?.solder_insufficient);
                        updateRowCell(row, '.editable-status[data-field="features_solder_excess"]', data.features?.solder_excess);
                        updateRowCell(row, '.editable-status[data-field="features_solder_void"]', data.features?.solder_void);
                        updateRowCell(row, '.editable-status[data-field="features_solder_crack"]', data.features?.solder_crack);
                        updateRowCell(row, '.editable-status[data-field="features_orientation"]', data.features?.orientation);
                        updateRowCell(row, '.editable-status[data-field="features_wrong_component"]', data.features?.wrong_component);
                        updateRowCell(row, '.editable-status[data-field="features_missing_component"]', data.features?.missing_component);
                        updateRowCell(row, '.editable-status[data-field="features_cosmetic"]', data.features?.cosmetic);
                        updateRowCell(row, '.editable-status[data-field="features_other"]', data.features?.other);

                        // Replace the existing technique updates with:
                        updateRowCell(row, '.editable-status[data-field="technique_classic_cv_based"]', data.technique?.classic_cv_based);
                        updateRowCell(row, '.editable-status[data-field="technique_ml_traditional"]', data.technique?.ml_traditional);
                        updateRowCell(row, '.editable-status[data-field="technique_dl_cnn_classifier"]', data.technique?.dl_cnn_classifier);
                        updateRowCell(row, '.editable-status[data-field="technique_dl_cnn_detector"]', data.technique?.dl_cnn_detector);
                        updateRowCell(row, '.editable-status[data-field="technique_dl_rcnn_detector"]', data.technique?.dl_rcnn_detector);
                        updateRowCell(row, '.editable-status[data-field="technique_dl_transformer"]', data.technique?.dl_transformer);
                        updateRowCell(row, '.editable-status[data-field="technique_dl_other"]', data.technique?.dl_other);
                        updateRowCell(row, '.editable-status[data-field="technique_hybrid"]', data.technique?.hybrid);
                        updateRowCell(row, '.editable-status[data-field="technique_available_dataset"]', data.technique?.available_dataset);

                        // Update audit/other fields
                        const changedCell = row.querySelector('.changed-cell');
                        if (changedCell) changedCell.textContent = data.changed_formatted || '';

                        const changedByCell = row.querySelector('.changed-by-cell');
                        if (changedByCell) changedByCell.innerHTML = renderChangedBy(data.changed_by);

                        const verifiedCell = row.querySelector('.editable-status[data-field="verified"]');
                        if (verifiedCell) {
                            // Assuming render_status function exists or create one
                            verifiedCell.textContent = renderStatus(data.verified);
                        }

                        const verifiedByCell = row.querySelector('.editable-verify[data-field="verified_by"]');
                        if (verifiedByCell) {
                             // Assuming render_verified_by function exists or create one based on Python logic
                             verifiedByCell.innerHTML = renderVerifiedBy(data.verified_by);
                        }
                        const estimatedScoreCell = row.cells[estScoreCellIndex];  //Updates score dynamically after verification.
                        if (estimatedScoreCell) estimatedScoreCell.textContent = data.estimated_score !== null && data.estimated_score !== undefined ? data.estimated_score : ''; // Example formatting

                        const pageCountCell = row.cells[pageCountCellIndex]; 
                        if (pageCountCell) pageCountCell.textContent = data.page_count !== null && data.page_count !== undefined ? data.page_count : '';

                        // Update detail row traces if expanded
                        if (detailRow && detailRow.classList.contains('expanded')) {
                            const evalTraceDiv = detailRow.querySelector('.detail-evaluator-trace .trace-content');
                            if (evalTraceDiv) {
                                evalTraceDiv.textContent = data.reasoning_trace || 'No trace available.';
                                evalTraceDiv.classList.remove('trace-placeholder');
                            }
                            const verifyTraceDiv = detailRow.querySelector('.detail-verifier-trace .trace-content');
                            if (verifyTraceDiv) {
                                verifyTraceDiv.textContent = data.verifier_trace || 'No trace available.';
                                verifyTraceDiv.classList.remove('trace-placeholder');
                            }
                            // Update form fields if needed (e.g., model name, other defects might have changed)
                            const form = detailRow.querySelector(`form[data-paper-id="${paperId}"]`);
                            if(form){
                                const modelNameInput = form.querySelector('input[name="technique_model"]');
                                if(modelNameInput) modelNameInput.value = data.technique?.model || '';
                                const otherDefectsInput = form.querySelector('input[name="features_other"]');
                                if(otherDefectsInput) otherDefectsInput.value = data.features?.other || '';
                                const researchAreaInput = form.querySelector('input[name="research_area"]');
                                if(researchAreaInput) researchAreaInput.value = data.research_area || '';
                                // const pageCountInput = form.querySelector('input[name="page_count"]');
                                // if(pageCountInput) pageCountInput.value = data.page_count !== null && data.page_count !== undefined ? data.page_count : '';
                                // const userTraceTextarea = form.querySelector('textarea[name="user_trace"]');
                                // if(userTraceTextarea) userTraceTextarea.value = data.user_trace || ''; // Update textarea value
                            }
                        }
                        updateCounts();
                        console.log(`${actionType.charAt(0).toUpperCase() + actionType.slice(1)} successful for paper ${paperId}`);
                    }
                } else {
                    console.error(`${actionType.charAt(0).toUpperCase() + actionType.slice(1)} error for paper ${paperId}:`, data.message);
                    alert(`Failed to ${actionType} paper ${paperId}: ${data.message}`);
                }
            })
            .catch(error => {
                console.error(`Error during ${actionType} for paper ${paperId}:`, error);
                alert(`An error occurred while ${actionType}ing paper ${paperId}: ${error.message}`);
            })
            .finally(() => {
                (classifyBtn || verifyBtn).disabled = false;
                if (actionType === 'classify') {
                    (classifyBtn || verifyBtn).innerHTML = 'Classify <strong>this paper</strong>';
                } else if (actionType === 'verify') {
                    (classifyBtn || verifyBtn).innerHTML = 'Verify <strong>this paper</strong>'; 
                }
            });
        }
    });


    // --- BibTeX Import Logic ---
    const importBibtexBtn = document.getElementById('import-bibtex-btn');
    const bibtexFileInput = document.getElementById('bibtex-file-input');

    // Clicking the button triggers the hidden file input
    importBibtexBtn.addEventListener('click', () => {
        bibtexFileInput.click();
    });

    // Handle file selection and upload
    bibtexFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            if (!file.name.toLowerCase().endsWith('.bib')) {
                alert('Please select a .bib file.');
                bibtexFileInput.value = ''; // Clear the input
                return;
            }

            if (!confirm(`Are you sure you want to import '${file.name}'?`)) {
                    bibtexFileInput.value = ''; // Clear the input
                    return;
            }

            const formData = new FormData();
            formData.append('file', file);

            // Disable button and show status
            importBibtexBtn.disabled = true;
            importBibtexBtn.textContent = 'Importing...';
            if (batchStatusMessage) {
                batchStatusMessage.textContent = `Uploading and importing '${file.name}'...`;
                batchStatusMessage.style.color = ''; // Reset color
            }

            fetch('/upload_bibtex', {
                method: 'POST',
                body: formData // Use FormData for file uploads
                // Don't set Content-Type header, let browser set it with boundary
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => {
                        throw new Error(errData.message || `HTTP error! status: ${response.status}`);
                    }).catch(() => {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    console.log(data.message);
                    if (batchStatusMessage) {
                        batchStatusMessage.textContent = data.message;
                        batchStatusMessage.style.color = 'green'; // Success color
                    }
                    // Optional: Reload the page or fetch new data to show imported papers
                    // window.location.reload(); // Simple reload
                    // Or, fetch updated papers list (requires more JS logic)
                        setTimeout(() => { window.location.reload(); }, 1500); // Reload after delay
                } else {
                    console.error("Import Error:", data.message);
                    if (batchStatusMessage) {
                        batchStatusMessage.textContent = `Import Error: ${data.message}`;
                        batchStatusMessage.style.color = 'red'; // Error color
                    }
                    alert(`Import failed: ${data.message}`);
                }
            })
            .catch(error => {
                console.error('Error uploading BibTeX file:', error);
                if (batchStatusMessage) {
                    batchStatusMessage.textContent = `Upload Error: ${error.message}`;
                    batchStatusMessage.style.color = 'red'; // Error color
                }
                alert(`An error occurred during upload: ${error.message}`);
            })
            .finally(() => {    // Re-enable button and reset file input
                importBibtexBtn.disabled = false;
                importBibtexBtn.innerHTML = 'Import <strong>BibTeX</strong>'; // Restore original HTML
                bibtexFileInput.value = '';
            });
        }
    });
    // --- End BibTeX Import Logic ---

    // --- Export HTML Button ---
    const exportHtmlBtn = document.getElementById('export-html-btn');
    exportHtmlBtn.addEventListener('click', function() {
        console.log("Export HTML button clicked");
        // Gather current filter values from the UI elements
        const hideOfftopicCheckbox = document.getElementById('hide-offtopic-checkbox');
        const yearFromInput = document.getElementById('year-from');
        const yearToInput = document.getElementById('year-to');
        const minPageCountInput = document.getElementById('min-page-count');
        const searchInput = document.getElementById('search-input'); // Get search input

        let exportUrl = '/static_export?'; // Start building the URL

        // Add filters to the URL query parameters
        if (hideOfftopicCheckbox) {
            exportUrl += `hide_offtopic=${hideOfftopicCheckbox.checked ? '1' : '0'}&`;
        }
        if (yearFromInput && yearFromInput.value) {
            exportUrl += `year_from=${encodeURIComponent(yearFromInput.value)}&`;
        }
        if (yearToInput && yearToInput.value) {
            exportUrl += `year_to=${encodeURIComponent(yearToInput.value)}&`;
        }
        if (minPageCountInput && minPageCountInput.value) {
            exportUrl += `min_page_count=${encodeURIComponent(minPageCountInput.value)}&`;
        }
        if (searchInput && searchInput.value) { // Add search query
            exportUrl += `search_query=${encodeURIComponent(searchInput.value)}&`;
        }

        // Remove trailing '&' or '?' if present
        exportUrl = exportUrl.replace(/&$/, '');

        console.log("Export URL:", exportUrl);

        // --- Trigger the download asynchronously ---
        // Create a temporary invisible anchor element
        const link = document.createElement('a');
        link.href = exportUrl;
        link.style.display = 'none';
        // The filename will be suggested by the server's Content-Disposition header
        // link.download = 'PCBPapers_export.html'; // Optional: Suggest a default name if server doesn't set it
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        // Note: The browser's download manager should handle the file save dialog.
    });

    document.getElementById('export-xlsx-btn').addEventListener('click', function() {
        // Reuse the logic from exportStaticBtn or create a specific one
        // This example reuses the core logic
        const currentUrlParams = new URLSearchParams(window.location.search);
        const exportUrlParams = new URLSearchParams();

        // Copy relevant filter parameters
        const relevantParams = ['hide_offtopic', 'year_from', 'year_to', 'min_page_count', 'search_query'];
        relevantParams.forEach(param => {
            const value = currentUrlParams.get(param);
            if (value !== null) {
                exportUrlParams.set(param, value);
            }
        });

        // Construct the URL for the Excel export endpoint
        const exportUrl = `/xlsx_export?${exportUrlParams.toString()}`;
        console.log("Exporting Excel with URL:", exportUrl);

        // Trigger the download
        window.location.href = exportUrl;
    });


    const backupBtn = document.getElementById('backup-btn');


    backupBtn.addEventListener('click', function() {
        document.documentElement.classList.add('busyCursor');
        console.log("Backup button clicked");

        backupStatusMessage.textContent = 'Creating backup...';
        backupStatusMessage.style.color = '';

        // Create backup URL with current filters
        const currentUrlParams = new URLSearchParams(window.location.search);
        const backupUrl = `/backup?${currentUrlParams.toString()}`;
        
        // Use fetch to get the backup file
        fetch(backupUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Backup failed: ${response.status} ${response.statusText}`);
                }
                // Extract filename from Content-Disposition header
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = 'backup.para.zst';
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="([^"]+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }
                
                return response.blob().then(blob => ({ blob, filename }));
            })
            .then(({ blob, filename }) => {
                // Create a download link for the backup file
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            
                backupStatusMessage.textContent = 'Backup created successfully!';
                backupStatusMessage.style.color = 'green';
                
                document.documentElement.classList.remove('busyCursor');
            })
            .catch(error => {
                console.error('Backup error:', error);
                backupStatusMessage.textContent = `Backup Error: ${error.message}`;
                backupStatusMessage.style.color = 'red';
                alert(`An error occurred during backup: ${error.message}`);
                document.documentElement.classList.remove('busyCursor');
            });
    });

    restoreBtn.addEventListener('click', function() {
        console.log("Restore button clicked");
        
        // Create file input for backup selection
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.zst';
        fileInput.style.display = 'none';
        
        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file extension
            if (!file.name.endsWith('.para.zst')) {
                alert('Invalid backup file. Expected .para.zst file.');
                return;
            }

            // Create FormData and send restore request
            const formData = new FormData();
            formData.append('backup_file', file);

            // Show status message
                backupStatusMessage.textContent = `Restoring from ${file.name}...`;
                backupStatusMessage.style.color = '';

            fetch('/restore', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.documentElement.classList.add('busyCursor');
                if (data.status === 'success') {
                    console.log(data.message);
                    backupStatusMessage.textContent = data.message;
                    backupStatusMessage.style.color = 'green';
                    
                    // Reload page after successful restore
                    setTimeout(() => { window.location.reload(); }, 2000);
                } else {
                    console.error("Restore Error:", data.message);
                    backupStatusMessage.textContent = `Restore Error: ${data.message}`;
                    backupStatusMessage.style.color = 'red';
                    alert(`Restore failed: ${data.message}`);
                }
                document.documentElement.classList.remove('busyCursor');
            })
            .catch(error => {
                document.documentElement.classList.add('busyCursor');
                console.error('Restore error:', error);
                backupStatusMessage.textContent = `Restore Error: ${error.message}`;
                backupStatusMessage.style.color = 'red';
                alert(`An error occurred during restore: ${error.message}`);
                document.documentElement.classList.remove('busyCursor');
            });
        });

        // Trigger file selection
        document.body.appendChild(fileInput);
        fileInput.click();
        document.body.removeChild(fileInput);
    });

});
















//deprecated, replaced by full-client-side implementation based on GH export version.
// The change seems to substantially slow down page manipulation with inspector for some reason, 
// but it's the easiest solution for stats bugs for now.
// function fetchDetailRowLists(callback){
//         // --- Fetch Server Stats (for other lists) ---
//     const urlParams = new URLSearchParams(window.location.search);
//     const statsUrl = `/get_stats?${urlParams.toString()}`;
//     fetch(statsUrl).then(response => {
//         return response.json();
//     }).then(data => {
//         if (data.status === 'success' && data.data) {
//             const serverStatsData = data.data;
//             function populateListFromServer(listElementId, dataArray) { //for items with count >=2
//                 const listElement = document.getElementById(listElementId);
//                 listElement.innerHTML = '';
//                 if (!dataArray || dataArray.length === 0) {
//                     listElement.innerHTML = '<li>No items with count > 1.</li>';
//                     return;
//                 }
//                 dataArray.forEach(item => {
//                     const listItem = document.createElement('li');
//                     const escapedName = (item.name || '').toString()
//                         .replace(/&/g, "&amp;").replace(/</g, "<")
//                         .replace(/>/g, ">").replace(/"/g, "&quot;")
//                         .replace(/'/g, "&#39;");
//                     // --- Preserve Original Structure ---
//                     const countSpan = document.createElement('span');
//                     countSpan.className = 'count';
//                     countSpan.textContent = item.count;
//                     const nameSpan = document.createElement('span');
//                     nameSpan.className = 'name';
//                     nameSpan.textContent = escapedName;
//                     // --- NEW: Create search button element ---
//                     const searchButton = document.createElement('button');
//                     searchButton.type = 'button'; // Important to prevent form submission if inside one
//                     searchButton.className = 'search-item-btn'; // Add a specific class for styling/listening
//                     searchButton.title = `Search for "${item.name}"`;
//                     searchButton.textContent = ''; // Or use an icon image
//                     // --- NEW: Add click event listener to the button ---
//                     searchButton.addEventListener('click', function(event) {
//                         event.stopPropagation(); // Prevent triggering other click listeners on the <li>
//                         searchInput.value = item.name; // Set the search input value
//                         closeModal(); // Close the stats modal
//                         // Trigger the existing search mechanism (which includes debouncing)
//                         const inputEvent = new Event('input', { bubbles: true });
//                         searchInput.dispatchEvent(inputEvent);
//                     });
//                     // --- Append elements preserving the original structure ---
//                     listItem.appendChild(countSpan);
//                     listItem.appendChild(searchButton); 
//                     listItem.appendChild(nameSpan);
//                     listElement.appendChild(listItem);
//                 });
//             }
//             function populateAllListFromServer(listElementId, dataArray) { //for ALL items, not just repeating ones
//                 const listElement = document.getElementById(listElementId);
//                 listElement.innerHTML = '';
//                 if (!dataArray || dataArray.length === 0) {
//                     listElement.innerHTML = '<li>No non-empty items found.</li>';
//                     return;
//                 }
//                 dataArray.forEach(item => {
//                     const listItem = document.createElement('li');
//                     const escapedName = (item.name || '').toString()
//                         .replace(/&/g, "&amp;").replace(/</g, "<")
//                         .replace(/>/g, ">").replace(/"/g, "&quot;")
//                         .replace(/'/g, "&#39;");
//                     // --- Preserve Original Structure ---
//                     const countSpan = document.createElement('span');
//                     countSpan.className = 'count';
//                     countSpan.textContent = item.count;
//                     const nameSpan = document.createElement('span');
//                     nameSpan.className = 'name';
//                     nameSpan.textContent = escapedName;
//                     // --- NEW: Create search button element ---
//                     const searchButton = document.createElement('button');
//                     searchButton.type = 'button';
//                     searchButton.className = 'search-item-btn';
//                     searchButton.title = `Search for "${item.name}"`;
//                     searchButton.textContent = '';
//                     // --- NEW: Add click event listener to the button ---
//                     searchButton.addEventListener('click', function(event) {
//                         event.stopPropagation();
//                         searchInput.value = item.name;
//                         closeModal();
//                         const inputEvent = new Event('input', { bubbles: true });
//                         searchInput.dispatchEvent(inputEvent);
//                     });
//                     // --- Append elements preserving the original structure ---
//                     listItem.appendChild(countSpan);
//                     listItem.appendChild(searchButton);
//                     listItem.appendChild(nameSpan);
//                     listElement.appendChild(listItem);
//                 });
//             }
//             // Populate Server Lists (Keywords, Authors, etc.)
//             populateListFromServer('keywordStatsList', serverStatsData.keywords);
//             populateListFromServer('authorStatsList', serverStatsData.authors);
//             populateListFromServer('researchAreaStatsList', serverStatsData.research_areas);
//             populateAllListFromServer('otherDetectedFeaturesStatsList', serverStatsData.other_features_all);
//             populateAllListFromServer('modelNamesStatsList', serverStatsData.model_names_all);
                
//         // ---- now the lists exist; build cloud if switch is on ----
//         if (document.getElementById('cloudToggle').checked) {
//             toggleCloud();                     // first render
//         }
//             if (callback) callback(); // Call the callback function after populating lists
//         } else {
//             // Handle potential fetch error - still populate client-side lists if possible
//             console.error("Failed to fetch server stats:", data);
//         }
//     })
//                 if (callback) callback(); // Call the callback function after populating lists

// }

```

```javascript
# static\filtering.js
// static/filtering.js
/** This file contains client-side filtering code, shared between server-based full page and client-only HTML export.
 */


//Hardocoded cells - used for multiple scripts:
const pdfCellIndex = 0;
const titleCellIndex = 1;
const yearCellIndex = 2;
const pageCountCellIndex = 3;
const journalCellIndex = 4;
const typeCellIndex = 5;
const relevanceCellIndex = 7;
const estScoreCellIndex = 38;


const searchInput = document.getElementById('search-input');
const hideOfftopicCheckbox = document.getElementById('hide-offtopic-checkbox');
const hideXrayCheckbox = document.getElementById('hide-xray-checkbox');
const hideApprovedCheckbox = document.getElementById('hide-approved-checkbox');
const onlySurveyCheckbox = document.getElementById('only-survey-checkbox');
const showPCBcheckbox = document.getElementById('show-pcb-checkbox');
const showSolderCheckbox = document.getElementById('show-solder-checkbox');
const showPCBAcheckbox = document.getElementById('show-pcba-checkbox');
const noFeaturesCheckbox = document.getElementById('no-features-checkbox');
const showOtherCheckbox = document.getElementById('show-other-checkbox');

let filterTimeoutId = null;
const FILTER_DEBOUNCE_DELAY = 200;

const headers = document.querySelectorAll('th[data-sort]');
let currentClientSort = { column: null, direction: 'ASC' };


const SYMBOL_SORT_WEIGHTS = {
    '': 2,
    '': 1,
    '': 0
};

const SYMBOL_PDF_WEIGHTS = {
    '': 3, // Annotated
    '': 2, // PDF
    '': 1,  // None
    '': 0 // Paywalled
};


/**
 * Applies alternating row shading to visible main rows.
 * Ensures detail rows follow their main row's shading.
 * Each "paper group" (main row + detail row) gets a single alternating color.
 * Should be pure client-side to be reused for HTML export
 */
function applyAlternatingShading() {
    // Select ALL main rows (not just visible ones)
    const allMainRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]');

    let visibleGroupIndex = 0; // Counter for visible paper groups

    allMainRows.forEach((mainRow) => {
        // Check if the current main row itself is visible
        const isMainRowVisible = !mainRow.classList.contains('filter-hidden');

        if (isMainRowVisible) {
            // Determine the shade class based on the current visible group index
            const shadeClass = (visibleGroupIndex % 2 === 0) ? 'alt-shade-1' : 'alt-shade-2';

            // Apply shade to the visible main row
            mainRow.classList.remove('alt-shade-1', 'alt-shade-2');
            mainRow.classList.add(shadeClass);

            // Apply the SAME shade to its associated detail row
            const detailRow = mainRow.nextElementSibling;
            if (detailRow) { // Ensure detail row exists
                detailRow.classList.remove('alt-shade-1', 'alt-shade-2');
                detailRow.classList.add(shadeClass);
                // Note: Ensure CSS .detail-row has background-color: inherit; or no background-color set
                // so it uses the one from the .alt-shade-* class.
            }

            // Only increment the group index when we process a *visible* main row
            visibleGroupIndex++;
        } else {
            // If the main row is hidden, its detail row is also hidden.
            // Remove shading classes from both the hidden main and detail row
            // to avoid potential issues if they become visible later with old shading.
            mainRow.classList.remove('alt-shade-1', 'alt-shade-2');
            const detailRow = mainRow.nextElementSibling;
            if (detailRow) {
                 detailRow.classList.remove('alt-shade-1', 'alt-shade-2');
            }
        }
    });
}

function applyDuplicateShading(rows) {  // not used in HTML export due to performance concerns.
    const journalCounts = new Map();
    const titleCounts = new Map();

    // Count occurrences for both journal names and titles
    rows.forEach(row => {
        if (!row.classList.contains('filter-hidden')) {
            const journalCell = row.cells[journalCellIndex];
            const titleCell = row.cells[titleCellIndex];
            
            const journalName = journalCell.textContent.trim();
            const title = titleCell.textContent.trim();
            
            journalCounts.set(journalName, (journalCounts.get(journalName) || 0) + 1);
            titleCounts.set(title, (titleCounts.get(title) || 0) + 1);
        }
    });

    // Count duplicate titles (only titles with 2 or more occurrences)
    let duplicateTitleCount = 0;
    for (const [title, count] of titleCounts) {
        if (title && count >= 2) {
            duplicateTitleCount++;
        }
    }
    
    // Update the duplicate papers count in HTML
    const duplicateCountElement = document.getElementById('duplicate-papers-count');
    if (duplicateCountElement) {
        duplicateCountElement.textContent = duplicateTitleCount;
    }

    // Determine the maximum count for scaling (for journals only)
    let maxCount = 0;
    for (const count of journalCounts.values()) {
        if (count > maxCount) maxCount = count;
    }

    // Define base shade colors
    const baseJournalHue = 210; // Blueish
    const baseSaturation = 66;
    const minLightness = 96; // Lightest shade (almost white)
    const maxLightness = 84; // Darkest shade when maxCount is high
    
    const baseTitleHue = 0; // Reddish
    const titleSaturation = 66;
    const titleLightness = 94; // Consistent light red

    rows.forEach(row => {
        const journalCell = row.cells[journalCellIndex];
        const titleCell = row.cells[titleCellIndex];
        
        // Reset background colors
        journalCell.style.backgroundColor = '';
        titleCell.style.backgroundColor = '';

        // Only apply shading if the row is visible
        if (!row.classList.contains('filter-hidden')) {
            const journalName = journalCell.textContent.trim();
            const title = titleCell.textContent.trim();
            
            // Apply journal shading (progressive)
            if (journalName && journalName) {
                const journalCount = journalCounts.get(journalName) || 0;
                if (journalCount >= 2) { 
                    let lightness;
                    if (maxCount <= 1) {
                        lightness = minLightness;
                    } else {
                        lightness = maxLightness + (minLightness - maxLightness) * (1 - (journalCount - 1) / (maxCount - 1));
                        lightness = Math.max(maxLightness, Math.min(minLightness, lightness));
                    }
                    journalCell.style.backgroundColor = `hsl(${baseJournalHue}, ${baseSaturation}%, ${lightness}%)`;
                }
            }
            
            // Apply title shading (consistent red for duplicates)
            if (title && title) {
                const titleCount = titleCounts.get(title) || 0;
                if (titleCount >= 2) {
                    titleCell.style.backgroundColor = `hsl(${baseTitleHue}, ${titleSaturation}%, ${titleLightness}%)`;
                }
            }
        }
    });
}

// --- Tri-State Survey Filter Logic (Add to globals.js) ---
// Define the states for the survey filter
const SURVEY_FILTER_STATES = {
    ALL: 'all',           // Default: Show all papers
    ONLY_SURVEYS: 'surveys', // Show only papers marked as surveys ()
    ONLY_NON_SURVEYS: 'non_surveys' // Show only papers NOT marked as surveys ( or )
};

// Store the current state of the survey filter
// let currentSurveyFilterState = SURVEY_FILTER_STATES.ALL; // Start with showing all
let currentSurveyFilterState = SURVEY_FILTER_STATES.ONLY_NON_SURVEYS; 

// Function to cycle the checkbox's visual state and update the title
function updateSurveyCheckboxUI() {
    const checkbox = onlySurveyCheckbox; // Reference from your globals
    const state = currentSurveyFilterState;

    // Remove any previous tri-state classes (if you add custom styling)
    checkbox.classList.remove('tri-state-indeterminate'); // Example class

    switch (state) {
        case SURVEY_FILTER_STATES.ALL:
            checkbox.checked = false;
            checkbox.indeterminate = false; // Ensure indeterminate is off
            checkbox.title = 'Currently showing all papers. Click to show only Survey papers';
            break;
        case SURVEY_FILTER_STATES.ONLY_SURVEYS:
            checkbox.checked = true; // Visually checked
            checkbox.indeterminate = false;
            checkbox.title = 'Currently showing only Surveys. Click to show only implementation (non-survey) papers';
            break;
        case SURVEY_FILTER_STATES.ONLY_NON_SURVEYS:
            checkbox.checked = false; // Visually unchecked
            checkbox.indeterminate = true; // Use indeterminate to show the third state
            checkbox.title = 'Currently showing only implementation (non-survey) papers. Click to show All papers';
            break;
    }
}

// Function to cycle the filter state on click
function cycleSurveyFilterState() {
    switch (currentSurveyFilterState) {
        case SURVEY_FILTER_STATES.ALL:
            currentSurveyFilterState = SURVEY_FILTER_STATES.ONLY_SURVEYS;
            break;
        case SURVEY_FILTER_STATES.ONLY_SURVEYS:
            currentSurveyFilterState = SURVEY_FILTER_STATES.ONLY_NON_SURVEYS;
            break;
        case SURVEY_FILTER_STATES.ONLY_NON_SURVEYS:
            currentSurveyFilterState = SURVEY_FILTER_STATES.ALL;
            break;
    }
    updateSurveyCheckboxUI();
    applyLocalFilters(); // Re-apply filters after state change
}


function applyLocalFilters() {
    clearTimeout(filterTimeoutId);
    document.documentElement.classList.add('busyCursor');    // Set the cursor immediately on user interaction
    filterTimeoutId = setTimeout(() => {
        const tbody = document.querySelector('#papersTable tbody');
        if (!tbody) return;
        const hideXrayChecked = hideXrayCheckbox.checked;
        //const onlySurveyChecked = onlySurveyCheckbox.checked; //not a normal checkbox anymore.
        const hideApprovedChecked = hideApprovedCheckbox.checked;

        // --- NEW: Get the state of PCB/Solder/PCBA checkboxes ---
        const showPCBChecked = showPCBcheckbox.checked;
        const showSolderChecked = showSolderCheckbox.checked;
        const showPCBAChecked = showPCBAcheckbox.checked;
        const showOtherChecked = showOtherCheckbox.checked;
        const showNoFeaturesChecked = noFeaturesCheckbox.checked;

        const rows = tbody.querySelectorAll('tr[data-paper-id]');
        rows.forEach(row => {
            let showRow = true;
            let detailRow = row.nextElementSibling; // Get the associated detail row

            /** full-client-side reimplementations for GH pages. Here to simplify variable passing: */
            if (document.body.id === 'html-export') {   
                const hideOfftopicChecked = hideOfftopicCheckbox.checked;
                
                if (showRow && hideOfftopicChecked) {
                    const offtopicCell = row.querySelector('.editable-status[data-field="is_offtopic"]');
                    if (offtopicCell && offtopicCell.textContent.trim() === '') {
                        showRow = false;
                    }
                }
                
                // 2. Minimum Page Count
                // Only hide if page count is a known number and it's less than the minimum
                const minPageCountValue = document.getElementById('min-page-count').value.trim();
                if (showRow && minPageCountValue > 0) { // Only check if min value is set
                    const pageCountCell = row.cells[4]; // Index 4 for 'Pages' column
                    if (pageCountCell) {
                        const pageCountText = pageCountCell.textContent.trim();
                        // Only filter if there's actual text to parse
                        if (pageCountText !== '') {
                            const pageCount = parseInt(pageCountText, 10);
                            // If parsing was successful and the number is less than the minimum, hide
                            if (!isNaN(pageCount) && pageCount < minPageCountValue) {
                                showRow = false;
                            }
                        }
                        // If pageCountText is '', pageCount is NaN, or pageCount >= min, row stays visible
                    }
                }

                // 3. Year Range
                const yearFromValue = document.getElementById('year-from').value.trim();
                const yearToValue = document.getElementById('year-to').value.trim();
                if (showRow) {
                    const yearCell = row.cells[2]; // Index 2 for 'Year' column
                    if (yearCell) {
                        const yearText = yearCell.textContent.trim();
                        const year = yearText ? parseInt(yearText, 10) : NaN;
                        // If year is not a number or outside the range, hide the row
                        // Ensure year is valid before comparison
                        if (isNaN(year) || year < yearFromValue || year > yearToValue) {
                            showRow = false;
                        }
                    }
                }
            }

            // 4. Search Term - added model name, etc. values search.
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            if (showRow && searchTerm) {
                let rowText = (row.textContent || '').toLowerCase();
                let detailText = '';
                let inputValuesText = ''; // NEW: To store values from input fields

                if (detailRow) {
                    const detailClone = detailRow.cloneNode(true);
                    // Exclude traces from search:
                    detailClone.querySelector('.detail-evaluator-trace .trace-content')?.remove();
                    detailClone.querySelector('.detail-verifier-trace .trace-content')?.remove();
                    detailText = (detailClone.textContent || '').toLowerCase();

                    // NEW: Extract values from specific input fields in the detail row
                    const inputSelectors = [
                        'input[name="research_area"]',
                        'input[name="model_name"]',
                        'input[name="features_other"]',
                        'input[name="user_trace"]' // Also include user comments if desired
                    ];

                    inputSelectors.forEach(selector => {
                        const inputElement = detailRow.querySelector(selector);
                        if (inputElement && inputElement.value) {
                            inputValuesText += ' ' + inputElement.value.toLowerCase();
                        }
                    });

                    // NEW: Also check textarea values if needed, e.g., user_trace
                    const textareaElement = detailRow.querySelector('textarea[name="user_trace"]');
                    if (textareaElement && textareaElement.value) {
                        inputValuesText += ' ' + textareaElement.value.toLowerCase();
                    }
                }

                // Check if the term is in the main row text, the detail text (excluding traces), OR the input values
                if (!rowText.includes(searchTerm) && !detailText.includes(searchTerm) && !inputValuesText.includes(searchTerm)) {
                    showRow = false;
                }
            }
            // NEW: Apply the tri-state survey filter logic
            if (showRow) {
                const surveyCell = row.querySelector('.editable-status[data-field="is_survey"]');
                const surveyStatus = surveyCell ? surveyCell.textContent.trim() : ''; // Default to unknown if cell not found

                switch (currentSurveyFilterState) {
                    case SURVEY_FILTER_STATES.ONLY_SURVEYS:
                        // Show only if status is ''
                        if (surveyStatus !== '') {
                            showRow = false;
                        }
                        break;
                    case SURVEY_FILTER_STATES.ONLY_NON_SURVEYS:
                        // Show only if status is '' or ''
                        if (surveyStatus === '') {
                            showRow = false;
                        }
                        break;
                    // For SURVEY_FILTER_STATES.ALL, showRow remains unchanged (default)
                }
            }

            // Existing filters (X-Ray, Survey, Approved)
            if (showRow && hideXrayChecked) {
                const xrayCell = row.querySelector('.editable-status[data-field="is_x_ray"]');
                if (xrayCell && xrayCell.textContent.trim() === '') {
                    showRow = false;
                }
            }
            if (showRow && hideApprovedChecked) {
                const verifiedCell = row.querySelector('.editable-status[data-field="verified"]');
                if (verifiedCell && verifiedCell.textContent.trim() === '') {
                    showRow = false;
                }
            }
            
            if (showRow && (showPCBChecked || showSolderChecked || showPCBAChecked || showOtherChecked)) { // Add showOtherChecked here
                let hasPCBFeature = false;
                let hasSolderFeature = false;
                let hasPCBAFeature = false;
                let hasOtherFeature = false; // NEW: Add variable for 'Other' group

                // Helper function to check if a paper has ANY '' in a given list of feature fields
                const hasAnyFeature = (featureFields) => {
                    return featureFields.some(fieldName => {
                        const cell = row.querySelector(`[data-field="${fieldName}"]`);
                        return cell && cell.textContent.trim() === '';
                    });
                };
                    
                const pcbFeatures = ['features_tracks', 'features_holes', 'features_bare_pcb_other'];
                const solderFeatures = [
                    'features_solder_insufficient',
                    'features_solder_excess',
                    'features_solder_void',
                    'features_solder_crack',
                    'features_solder_other'
                ];
                const pcbaFeatures = [ // Remove 'features_other_state' from here
                    'features_orientation',
                    'features_missing_component',
                    'features_wrong_component',
                    'features_component_other',
                    'features_cosmetic',
                    'features_other_state' // <-- Remove this line
                ]; 
                // NEW: Define features for the 'Other' group
                const otherFeatures = ['features_other_state'];
                // Check which groups the paper belongs to (has at least one )
                if (showPCBChecked) {
                    hasPCBFeature = hasAnyFeature(pcbFeatures);
                }
                if (showSolderChecked) {
                    hasSolderFeature = hasAnyFeature(solderFeatures);
                }
                if (showPCBAChecked) {
                    hasPCBAFeature = hasAnyFeature(pcbaFeatures);
                }
                // NEW: Check if the 'Other' group is enabled and the paper has the 'Other' feature
                if (showOtherChecked) { // Only check if the 'Other' checkbox is enabled
                    hasOtherFeature = hasAnyFeature(otherFeatures); // Check for 'features_other_state'
                }

                // The core OR logic:
                // Hide the row ONLY if it does NOT belong to ANY of the enabled groups.
                // In other words, show the row if it belongs to at least one enabled group.
                if (!(hasPCBFeature || hasSolderFeature || hasPCBAFeature || hasOtherFeature)) { // Add hasOtherFeature here
                    showRow = false;
                }
            }

            // Define feature fields that need to be checked for the "No Features" filter
            // These correspond to the data-field attributes in your table cells
            const featureFieldsToCheck = [
                'features_tracks', 'features_holes', 'features_bare_pcb_other',
                'features_solder_insufficient', 'features_solder_excess', 'features_solder_void', 'features_solder_crack', 'features_solder_other',
                'features_missing_component', 'features_wrong_component', 'features_component_other',
                'features_orientation', 'features_cosmetic',
                'features_other_state' // Note: 'features_other_state' is the editable cell. The actual 'other' text might be in the detail row, so filtering by its blank state might be the best we can do client-side.
            ];

            // --- Apply NEW "No Features" Filter ---
            // Only apply this filter if the checkbox is checked
            if (showRow && showNoFeaturesChecked) {
                // Check if ALL feature fields in the list are empty or contain only a space (' ')
                const hasAnyFeatureFilled = featureFieldsToCheck.some(fieldName => {
                    const cell = row.querySelector(`[data-field="${fieldName}"]`);
                    const cellText = cell ? cell.textContent.trim() : '';
                    // Consider '', '', '', '' as filled. Blank (' ') or empty string means not filled.
                    // Also consider if the cell content is just the initial blank space.
                    return cellText !== '' && cellText !== '' && cellText !== ''; // Adjust if '' is the initial state instead of ' '
                });

                // Hide the row if ANY feature was found to be filled
                if (hasAnyFeatureFilled) {
                    showRow = false;
                }
            }

            // Apply the visibility state
            row.classList.toggle('filter-hidden', !showRow);
            if (detailRow) { // Ensure detailRow exists before toggling
                detailRow.classList.toggle('filter-hidden', !showRow);
            }
        });

        applyAlternatingShading();
        if (document.body.id !== 'html-export') {
            applyDuplicateShading(document.querySelectorAll('#papersTable tbody tr[data-paper-id]:not(.filter-hidden)'));
            applyButton.style.opacity = '0';
            applyButton.style.pointerEvents = 'none';
        }
        updateCounts();

        // --- NEW: Fetch updated server-side lists after counts are updated ---
        // This ensures the lists (keywords, authors, etc.) reflect the filtered set.
        // It should only run if stats.js is loaded (relevant for HTML export vs server page).
        // Check if the function exists before calling it.
        if (typeof buildDetailRowLists === 'function') {
            // Note: buildDetailRowLists might take time. The busy cursor is removed shortly after,
            // potentially before buildDetailRowLists completes. This is generally acceptable,
            // as the main filtering and counting (the heavy part of applyLocalFilters) is done.
            // If it's critical the cursor stays until buildDetailRowLists finishes, more complex
            // state management is needed.
            buildDetailRowLists(); // Call without callback, as displayStats handles its own lists independently now.
        }
        // --- END NEW ---

        setTimeout(() => {
            document.documentElement.classList.remove('busyCursor');
        }, 150); // doesn't really work since the contents are completely replaced eliminating the animation. Not worth fixing.
    }, FILTER_DEBOUNCE_DELAY);
}


function sortTable(){
    document.documentElement.classList.add('busyCursor');

    setTimeout(() => {
        const sortBy = this.getAttribute('data-sort');
        if (!sortBy) return;

        let newDirection = 'DESC';
        if (currentClientSort.column === sortBy) {
            newDirection = currentClientSort.direction === 'DESC' ? 'ASC' : 'DESC';
        }
        const tbody = document.querySelector('#papersTable tbody');

        // --- PRE-PROCESS: Extract Sort Values and Row References ---
        const visibleMainRows = tbody.querySelectorAll('tr[data-paper-id]:not(.filter-hidden)');
        const headerIndex = Array.prototype.indexOf.call(this.parentNode.children, this);
        const sortData = [];
        let mainRow, paperId, cellValue, detailRow, cell;

        for (let i = 0; i < visibleMainRows.length; i++) {
            mainRow = visibleMainRows[i];
            paperId = mainRow.getAttribute('data-paper-id');

            // --- Extract cell value based on column type ---
            if (['title', 'year', 'journal', /*'authors',*/ 'page_count', 'estimated_score', 'relevance'].includes(sortBy)) {
                cell = mainRow.cells[headerIndex];
                cellValue = cell ? cell.textContent.trim() : '';
                if (sortBy === 'year' || sortBy === 'estimated_score' || sortBy === 'page_count' || sortBy === 'relevance') {
                    cellValue = parseFloat(cellValue) || 0;
                }
            } else if (['type', 'changed', 'changed_by', 'verified', 'verified_by', 'research_area', 'user_comment_state', 'features_other_state'].includes(sortBy)) {
                cell = mainRow.cells[headerIndex];
                cellValue = cell ? cell.textContent.trim() : '';
            } else if (sortBy === 'pdf-link') { // NEW: Handle PDF link column sorting
                cell = mainRow.cells[headerIndex]; // PDF cell is the second cell (index 1)
                cellValue = cell ? cell.textContent.trim() : '';

                // Use the weight, defaulting to 0 if symbol not found
                cellValue = SYMBOL_PDF_WEIGHTS[cellValue] ?? 0;
            } else { // Status/Feature/Technique columns
                cell = mainRow.querySelector(`.editable-status[data-field="${sortBy}"]`);
                // Use SYMBOL_SORT_WEIGHTS for sorting, defaulting to 0 if symbol not found
                cellValue = SYMBOL_SORT_WEIGHTS[cell?.textContent.trim()] ?? 0;
            }

            detailRow = mainRow.nextElementSibling; // Get the associated detail row
            sortData.push({ value: cellValue, mainRow, detailRow, paperId });
        }

        sortData.sort((a, b) => {
            let comparison = 0;
            if (a.value > b.value) comparison = 1;
            else if (a.value < b.value) comparison = -1;
            else {  // Secondary sort by paperId to ensure stable sort
                if (a.paperId > b.paperId) comparison = 1;
                else if (a.paperId < b.paperId) comparison = -1;
            }
            return newDirection === 'DESC' ? -comparison : comparison;
        });

        // --- BATCH UPDATE the DOM ---
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < sortData.length; i++) {
            fragment.appendChild(sortData[i].mainRow);
            fragment.appendChild(sortData[i].detailRow);
        }
        tbody.appendChild(fragment); // Single DOM append operation

        // --- Schedule UI Updates after DOM change ---
        // Use requestAnimationFrame to align with browser repaint
        requestAnimationFrame(() => {
            applyAlternatingShading();
            if (document.body.id !== 'html-export') {
                if (document.body.id !== "html-export") applyDuplicateShading(document.querySelectorAll('#papersTable tbody tr[data-paper-id]:not(.filter-hidden)'));
            }
            updateCounts();
        });
        currentClientSort = { column: sortBy, direction: newDirection };
        document.querySelectorAll('th .sort-indicator').forEach(ind => ind.textContent = '');
        const indicator = this.querySelector('.sort-indicator');
        if (indicator) {
            indicator.textContent = newDirection === 'ASC' ? '' : '';
        }
        // 3. Schedule removal of the busy cursor class AFTER a guaranteed delay
        // This ensures the CSS transition has time to play.
        // The delay (150ms) should be >= CSS transition duration (0.3s) + delay (0.1s) if you want full transition,
        // but even a shorter delay (longer than CSS delay) often works to trigger it.
        setTimeout(() => {
            document.documentElement.classList.remove('busyCursor');
        }, 150); // Delay slightly longer than CSS transition delay
    }, 20); // Initial defer for adding busy cursor (can keep this small or match rAF timing ~16ms)
}

document.addEventListener('DOMContentLoaded', function () {
    hideXrayCheckbox.addEventListener('change', applyLocalFilters);
    hideApprovedCheckbox.addEventListener('change', applyLocalFilters);
    onlySurveyCheckbox.addEventListener('click', cycleSurveyFilterState); // Use 'click' to handle cycling
    showPCBcheckbox.addEventListener('change', applyLocalFilters);
    showSolderCheckbox.addEventListener('change', applyLocalFilters);
    showPCBAcheckbox.addEventListener('change', applyLocalFilters);
    noFeaturesCheckbox.addEventListener('change', applyLocalFilters);
    showOtherCheckbox.addEventListener('change', applyLocalFilters);


    //server-side search disabled for now as FTS is broken. Using full-client-side search instead:
    searchInput.addEventListener('input', applyLocalFilters);

    document.getElementById('clear-search-btn').addEventListener('click', function() {
        searchInput.value = ''; // Clear the input value
        searchInput.dispatchEvent(new Event('input'));
    });

    headers.forEach(header => { header.addEventListener('click', sortTable);   });
    applyLocalFilters(); //apply initial filtering   
    updateSurveyCheckboxUI();     // Initialize the checkbox UI on page load

    // 2. After initial filters are applied (which includes the initial sortTable call
    //    if triggered by applyLocalFilters, but we'll override it),
    //    find the 'user_comment_state' header and trigger the sort.
    //    Use setTimeout with 0 delay to ensure it runs after the current
    //    execution stack (including the applyLocalFilters timeout) is clear.
    setTimeout(() => {
        const commentedHeader = document.querySelector('th[data-sort="user_comment_state"]');
        if (commentedHeader) {
            // Set the initial sort state so the UI indicator is correct
            currentClientSort = { column: "user_comment_state", direction: 'DESC' }; // Or 'ASC' if preferred

            // Call sortTable with the correct 'this' context (the header element)
            // We need to bind 'this' or call it directly on the element
            sortTable.call(commentedHeader);

            // Update the sort indicator visually
            // Clear previous indicators
            document.querySelectorAll('th .sort-indicator').forEach(ind => ind.textContent = '');
            // Set the indicator on the target header
            const indicator = commentedHeader.querySelector('.sort-indicator');
            if (indicator) {
                 // Use '' for DESC, '' for ASC based on your sortTable logic
                indicator.textContent = currentClientSort.direction === 'ASC' ? '' : '';
            }
        }
    }, 0); // Ensures it runs after applyLocalFilters' timeout finishes
});
```

```css
# static\fonts.css
/* inter-tight-300 - latin_latin-ext */
@font-face {
    font-display: swap; /* Check https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display for other options. */
    font-family: 'Inter Tight';
    font-style: normal;
    font-weight: 300;
    src: url('./fonts/inter-tight-v7-latin_latin-ext-300.woff2') format('woff2'), /* Chrome 36+, Opera 23+, Firefox 39+, Safari 12+, iOS 10+ */
            url('./fonts/inter-tight-v7-latin_latin-ext-300.ttf') format('truetype'); /* Chrome 4+, Firefox 3.5+, IE 9+, Safari 3.1+, iOS 4.2+, Android Browser 2.2+ */
}

/* inter-tight-regular - latin_latin-ext */
@font-face {
    font-display: swap; /* Check https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display for other options. */
    font-family: 'Inter Tight';
    font-style: normal;
    font-weight: 400;
    src: url('./fonts/inter-tight-v7-latin_latin-ext-regular.woff2') format('woff2'), /* Chrome 36+, Opera 23+, Firefox 39+, Safari 12+, iOS 10+ */
         url('./fonts/inter-tight-v7-latin_latin-ext-regular.ttf') format('truetype'); /* Chrome 4+, Firefox 3.5+, IE 9+, Safari 3.1+, iOS 4.2+, Android Browser 2.2+ */
}
    
/* inter-tight-600 - latin_latin-ext */
@font-face {
    font-display: swap; /* Check https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display for other options. */
    font-family: 'Inter Tight';
    font-style: normal;
    font-weight: 600;
    src: url('./fonts/inter-tight-v7-latin_latin-ext-600.woff2') format('woff2'), /* Chrome 36+, Opera 23+, Firefox 39+, Safari 12+, iOS 10+ */
            url('./fonts/inter-tight-v7-latin_latin-ext-600.ttf') format('truetype'); /* Chrome 4+, Firefox 3.5+, IE 9+, Safari 3.1+, iOS 4.2+, Android Browser 2.2+ */
}

/* noto-color-emoji-regular */
@font-face {
    font-display: swap; /* or 'optional' or 'swap' depending on your preference */
    font-family: 'Noto Color Emoji'; /* Use the standard name for the font */
    font-style: normal;
    font-weight: 400;
    src: url('./fonts/NotoColorEmoji-Regular.ttf') format('truetype'); /* Path to your local TTF file */
}

/* SegoeUIEmojiWin11 */
@font-face {
    font-display: swap; /* or 'optional' or 'swap' depending on your preference */
    font-family: 'Segoe UI Emoji Windows 11'; /* Use the standard name for the font */
    font-style: normal;
    font-weight: 400;
    src: url('./fonts/SegoeUIEmojiWin11.ttf') format('truetype'); /* Path to your local TTF file */
}
```

```javascript
# static\ghpages.js
// static/ghpages.js
// Logic exclusive to the client-side-only standalone HTML/GHpages version

const minPageCountInput = document.getElementById('min-page-count');
const yearFromInput = document.getElementById('year-from');
const yearToInput = document.getElementById('year-to');

const allRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]');
const totalPaperCount = allRows.length;


function toggleDetails(element) {   //this function is specific to GH Export! Same name function is different in comms.js for the server-based version.
    const row = element.closest('tr');
    const detailRow = row.nextElementSibling;
    const isExpanded = detailRow && detailRow.classList.contains('expanded');
    if (isExpanded) {
        if (detailRow) detailRow.classList.remove('expanded');
        element.innerHTML = '<span>Show</span>';
    } else {
        if (detailRow) detailRow.classList.add('expanded');
        element.innerHTML = '<span>Hide</span>';
    }
}

document.addEventListener('DOMContentLoaded', function () {
    //These listeners are specific to GH Export:          
    
    //server-side search disabled for now as FTS is broken. Using full-client-side search everyhwere instead:
    // searchInput.addEventListener('input', applyLocalFilters); //now defined in filtering.js
    hideOfftopicCheckbox.addEventListener('change', applyLocalFilters);
    minPageCountInput.addEventListener('input', applyLocalFilters);
    minPageCountInput.addEventListener('change', applyLocalFilters);

    yearFromInput.addEventListener('input', applyLocalFilters);
    yearFromInput.addEventListener('change', applyLocalFilters);
    yearToInput.addEventListener('input', applyLocalFilters);
    yearToInput.addEventListener('change', applyLocalFilters);
});

```

```javascript
# static\stats.js
// static/stats.js
/** This file contains client-side statistics code, shared between server-based full page and client-only HTML export.
 * Also includes all modal open/close logic for now. 
 */

// stats.js
/** Stats-related Functionality **/
let latestCounts = {}; // This will store the counts calculated by updateCounts
let latestYearlyData = {}; // NEW: Store yearly data for charts

let isStacked = false; // Default state
let isCumulative = false; // Default state
let showPieCharts = false; // Default to bar charts
let showKeywordCloud = false; // NEW: State for keyword cloud toggle

const statsBtn = document.getElementById('stats-btn');
const aboutBtn = document.getElementById('about-btn');
const modal = document.getElementById('statsModal');
const modalSmall = document.getElementById('aboutModal');
const spanClose = document.querySelector('#statsModal .close'); // Specific close button
const smallClose = document.querySelector('#aboutModal .close'); // Specific close button

// --- Define Consistent Colors for Techniques ---
// Define the fixed color order used in the Techniques Distribution chart (sorted)
const techniquesColors = [
    'hsla(347, 60%, 69%, 0.95)', // Red - Classic CV
    'hsla(204, 62%, 57%, 0.95)',  // Blue - Traditional ML
    'hsla(52, 80%, 47%, 0.95)',  // Yellow - CNN Classifier
    'hsla(180, 32%, 52%, 0.95)',  // Teal - CNN Detector
    'hsla(260, 60%, 66%, 0.95)', // Purple - R-CNN Detector
    'hsla(25, 70%, 63%, 0.95)',  // Orange - Transformer
    'hsla(0, 0%, 68%, 0.95)',   // Grey - Other DL
    'hsla(96, 66%, 49%, 0.95)', // Green - Hybrid
];
const techniquesBorderColors = [
    'hsla(347, 70%, 39%, 0.75)',
    'hsla(204, 82%, 28%, 0.75)',
    'hsla(42, 100%, 28%, 0.75)',
    'hsla(180, 48%, 28%, 0.75)',
    'hsla(260, 100%, 40%, 0.75)',
    'hsla(30, 100%, 33%, 0.75)',
    'hsla(0, 0%, 38%, 0.75)',
    'hsla(147, 48%, 38%, 0.75)',
];

// Map technique fields to their *original* color index in the unsorted list
// IMPORTANT: This list must match the order of TECHNIQUE_FIELDS_FOR_YEARLY
const TECHNIQUE_FIELDS_FOR_YEARLY = [
    'technique_classic_cv_based', 'technique_ml_traditional',
    'technique_dl_cnn_classifier', 'technique_dl_cnn_detector', 'technique_dl_rcnn_detector',
    'technique_dl_transformer', 'technique_dl_other', 'technique_hybrid'
];
const TECHNIQUE_FIELD_COLOR_MAP = {};

// Include Datasets here temporarily to get the label mapping easily,
// then filter it out for data/labels for the Techniques chart
const TECHNIQUE_FIELDS_ALL = [
    'technique_classic_cv_based', 'technique_ml_traditional',
    'technique_dl_cnn_classifier', 'technique_dl_cnn_detector', 'technique_dl_rcnn_detector',
    'technique_dl_transformer', 'technique_dl_other', 'technique_hybrid',
    'technique_available_dataset' // Included to get label easily
];

// --- Define Consistent Colors for Features ---
// These are the original colors used in the Features Distribution chart (in original order)
// Note: There are 12 features but only 5 distinct colors used.
const featuresColorsOriginalOrder = [
    'hsla(130, 27%, 60%, 0.95)',    //  - PCB - Tracks (Teal)
    'hsla(130, 27%, 60%, 0.95)',    //  - PCB - Holes (Teal)
    'hsla(130, 27%, 60%, 0.95)',    //  - PCB - other (Teal)
    'hsla(0, 0%, 68%, 0.95)',       //  - solder - Insufficient (Grey)
    'hsla(0, 0%, 68%, 0.95)',       //  - solder - Excess (Grey)
    'hsla(0, 0%, 68%, 0.95)',       //  - solder - Void (Grey)
    'hsla(0, 0%, 68%, 0.95)',       //  - solder - Crack (Grey)
    'hsla(0, 0%, 68%, 0.95)',       //  - solder - other (Grey)
    'hsla(347, 70%, 72%, 0.95)',    //  - PCBA - Orientation (Red)
    'hsla(347, 70%, 72%, 0.95)',    //  - PCBA - Missing Comp (Red)
    'hsla(347, 70%, 72%, 0.95)',    //  - PCBA - Wrong Comp (Red)
    'hsla(347, 70%, 72%, 0.95)',    //  - PCBA - Other (Red)
    'hsla(204, 88%, 70%, 0.95)',    //  - Cosmetic (Blue)
    'hsla(284, 88%, 70%, 0.95)',    //  - Other 
];
const featuresBorderColorsOriginalOrder = [
    'hsla(144, 83%, 28%, 0.75)',    // 0 - PCB - Tracks
    'hsla(144, 82%, 28%, 0.75)',    // 1 - PCB - Holes
    'hsla(144, 82%, 28%, 0.75)',    // 
    'hsla(0, 0%, 38%, 0.75)',       // 2 - solder - Insufficient
    'hsla(0, 0%, 38%, 0.75)',       // 3 - solder - Excess
    'hsla(0, 0%, 38%, 0.75)',       // 4 - solder - Void
    'hsla(0, 0%, 38%, 0.75)',       // 5 - solder - Crack
    'hsla(0, 0%, 38%, 0.75)',       // 
    'hsla(347, 70%, 39%, 0.75)',    // 6 - PCBA - Orientation
    'hsla(347, 70%, 39%, 0.75)',    // 7 - PCBA - Missing Comp
    'hsla(347, 70%, 39%, 0.75)',    // 8 - PCBA - Wrong Comp
    'hsla(347, 70%, 39%, 0.75)',    // 
    'hsla(219, 100%, 40%, 0.75)',   // 9 - Cosmetic
    'hsla(284, 82%, 47%, 0.75)',    // 10 - Other 
];

// Map feature fields to their *original* index in the unsorted list
// IMPORTANT: This list must match the order of FEATURE_FIELDS_FOR_YEARLY
const FEATURE_FIELDS_FOR_YEARLY = [
    'features_tracks', 'features_holes', 'features_bare_pcb_other', 
    'features_solder_insufficient', 'features_solder_excess', 'features_solder_void', 'features_solder_crack',  'features_solder_other',
    'features_orientation', 'features_wrong_component', 'features_missing_component', 'features_component_other', 
    'features_cosmetic', 
    'features_other_state'
];
const FEATURE_FIELD_INDEX_MAP = {};
const FEATURE_FIELDS = [
    'features_tracks', 'features_holes', 'features_bare_pcb_other', 
    'features_solder_insufficient', 'features_solder_excess', 'features_solder_void', 'features_solder_crack',  'features_solder_other',
    'features_orientation', 'features_wrong_component', 'features_missing_component', 'features_component_other', 
    'features_cosmetic', 
    'features_other_state'
];

// --- Map Feature Fields to their Color Groups for Line Chart ---
// Define the distinct color groups for the line chart based on original colors
// The keys are the indices in the original color arrays that represent unique colors
const featureColorGroups = {
    0: { label: 'Bare PCB Defects', fields: [] },      
    3: { label: 'Solder Defects', fields: [] },    
    8: { label: 'PCB Assembly Defects', fields: [] },       
    12: { label: 'Cosmetic', fields: [] },          
    13: { label: 'Other', fields: [] }
};

// Map NEW field names (data-field values / structure keys) to user-friendly labels (based on your table headers)
const FIELD_LABELS = {
    // Features
    'features_tracks': 'Tracks',
    'features_holes': 'Holes',
    'features_bare_pcb_other': 'Other (bare) PCB',
    'features_solder_insufficient': 'Insufficient Solder',
    'features_solder_excess': 'Excess Solder',
    'features_solder_void': 'Solder Voids',
    'features_solder_crack': 'Solder Cracks',
    'features_solder_other': 'Solder (Other)',
    'features_orientation': 'Orientation/Polarity', // Combined as per previous logic
    'features_wrong_component': 'Wrong Component',
    'features_missing_component': 'Missing Component',
    'features_component_other': 'Component (Other)',
    'features_cosmetic': 'Cosmetic',
    'features_other_state': 'Other',
    // Techniques
    'technique_classic_cv_based': 'Classic CV',
    'technique_ml_traditional': 'Traditional ML',
    'technique_dl_cnn_classifier': 'CNN Classifier',
    'technique_dl_cnn_detector': 'CNN Detector',
    'technique_dl_rcnn_detector': 'R-CNN Detector',
    'technique_dl_transformer': 'Transformer',
    'technique_dl_other': 'Other DL',
    'technique_hybrid': 'Hybrid',
    'technique_available_dataset': 'Datasets' // Label for Datasets
};


// Define the fields for which we want to count '':
const COUNT_FIELDS = [
    'pdf_present', 
    'pdf_annotated',

    'is_offtopic', 'is_survey', 'is_through_hole', 'is_smt', 'is_x_ray', // Classification (Top-level)

    'features_tracks', 'features_holes', 'features_bare_pcb_other',
    'features_solder_insufficient', 'features_solder_excess',
    'features_solder_void', 'features_solder_crack',  'features_solder_other',
    'features_orientation', 'features_wrong_component', 'features_missing_component',  'features_component_other',
    'features_cosmetic', 'features_other_state',

    'technique_classic_cv_based', 'technique_ml_traditional',
    'technique_dl_cnn_classifier', 'technique_dl_cnn_detector', 'technique_dl_rcnn_detector',
    'technique_dl_transformer', 'technique_dl_other', 'technique_hybrid', 'technique_available_dataset', // Techniques (Nested under 'technique')

    'changed_by', 'verified', 'verified_by', 'user_comment_state' // user counting (Top-level)
];

// Helper used by stats, comms and filtering:
function updateCounts() {
    const counts = {};
    const yearlySurveyImpl = {}; // { year: { surveys: count, impl: count } }
    const yearlyTechniques = {}; // { year: { technique_field: count, ... } }
    const yearlyFeatures =   {}; // { year: { feature_field: count, ... } }
    const yearlyPubTypes = {}; // { year: { pubtype1: count, pubtype2: count, ... } }
    // --- NEW: Store yearly model counts ---
    const yearlyModels = {}; // { year: { modelName: count, ... } }

    // Initialize counts for all defined fields
    COUNT_FIELDS.forEach(field => counts[field] = 0);

    // NEW: Initialize model counts separately if needed for distribution
    // Or just let counts['model'] hold the total number of *model mentions*
    // counts['model'] will now count individual model names, not rows

    // Select only VISIBLE main rows for counting '' and calculating visible count
    const visibleRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]:not(.filter-hidden)');
    const visiblePaperCount = visibleRows.length;

    //count on each update since server-side async can change this:
    const allRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]');
    const loadedPaperCount = allRows.length;

    // Count symbols in visible rows and collect yearly data
    visibleRows.forEach(row => {
        const pdfCell = row.cells[pdfCellIndex];
        if (pdfCell) {
            const pdfContent = pdfCell.textContent.trim();
            // Increment counts based on the emoji in the PDF cell
            if (pdfContent === '') { // PDF present
                counts['pdf_present'] = (counts['pdf_present'] || 0) + 1;
            } else if (pdfContent === '') { // Annotated PDF present
                counts['pdf_annotated'] = (counts['pdf_annotated'] || 0) + 1;
                counts['pdf_present'] =   (counts['pdf_present']   || 0) + 1;       // Also count annotated as a PDF present
            } else if (pdfContent === '') {
                counts['pdf_paywalled'] = (counts['pdf_paywalled'] || 0) + 1;
            }
            // '' means no PDF, so no increment needed for this state
        }

        COUNT_FIELDS.forEach(field => {
            // Skip the newly added PDF fields as they are handled separately above
            if (field === 'pdf_present' || field === 'pdf_annotated') {
                 return; // Skip to the next field
            }

            const cell = row.querySelector(`[data-field="${field}"]`);
            const cellText = cell ? cell.textContent.trim() : '';

            // --- NEW LOGIC FOR 'model' FIELD ---
            if (field === 'model') {
                if (cellText && cellText !== '') { // Check if there's content
                    // Split the content by comma and trim whitespace
                    const modelNames = cellText.split(',').map(name => name.trim()).filter(name => name !== '');
                    // Add the number of distinct models found in this cell to the total count
                    counts[field] += modelNames.length;

                    // --- Update Yearly Model Counts ---
                    const yearCell = row.cells[yearCellIndex];
                    const yearText = yearCell ? yearCell.textContent.trim() : '';
                    const year = yearText ? parseInt(yearText, 10) : null;
                    if (year && !isNaN(year)) {
                        if (!yearlyModels[year]) {
                            yearlyModels[year] = {};
                        }
                        modelNames.forEach(modelName => {
                            // Increment count for this specific model name in this specific year
                            yearlyModels[year][modelName] = (yearlyModels[year][modelName] || 0) + 1;
                        });
                    }
                }
                // After processing the model field, return to avoid the default '' check below
                return;
            }
            // --- END NEW LOGIC FOR 'model' FIELD ---

            if (field === 'changed_by' || field === 'verified_by') {
                if (cellText === '') {
                    counts[field]++;
                }
            } else {
                if (cellText === '') {
                    counts[field]++;
                }
            }
        });

        const yearCell = row.cells[yearCellIndex]; // Assuming Year is the 3rd column (index 2)
        const yearText = yearCell ? yearCell.textContent.trim() : '';
        const year = yearText ? parseInt(yearText, 10) : null;
        if (year && !isNaN(year)) {
            // Initialize yearly data objects for the year if they don't exist
            if (!yearlySurveyImpl[year]) {
                yearlySurveyImpl[year] = { surveys: 0, impl: 0 };
            }
            if (!yearlyTechniques[year]) {
                yearlyTechniques[year] = {};
                TECHNIQUE_FIELDS_FOR_YEARLY.forEach(f => yearlyTechniques[year][f] = 0);
            }
            if (!yearlyFeatures[year]) {
                yearlyFeatures[year] = {};
                FEATURE_FIELDS_FOR_YEARLY.forEach(f => yearlyFeatures[year][f] = 0);
            }
            // Update Publication Type counts ---
            const typeCell = row.cells[typeCellIndex]; // Assuming Type is the 1st column (index 0)
            const pubTypeText = typeCell ? typeCell.getAttribute('title') || typeCell.textContent.trim() : ''; // Use title for full type if available
            if (pubTypeText) {
                if (!yearlyPubTypes[year]) {
                    yearlyPubTypes[year] = {}; // Initialize object for this year's types
                }
                // Increment count for this type in this year
                yearlyPubTypes[year][pubTypeText] = (yearlyPubTypes[year][pubTypeText] || 0) + 1;
            }
            // Update Survey/Impl counts
            const isSurveyCell = row.querySelector('.editable-status[data-field="is_survey"]');
            const isSurvey = isSurveyCell && isSurveyCell.textContent.trim() === '';
            if (isSurvey) {
                yearlySurveyImpl[year].surveys++;
            } else {
                yearlySurveyImpl[year].impl++;
            }
            // Update Technique counts
            TECHNIQUE_FIELDS_FOR_YEARLY.forEach(field => {
                const techCell = row.querySelector(`.editable-status[data-field="${field}"]`);
                if (techCell && techCell.textContent.trim() === '') {
                    yearlyTechniques[year][field]++;
                }
            });
            // Update Feature counts
            FEATURE_FIELDS_FOR_YEARLY.forEach(field => {
                // const featCell = row.querySelector(`.editable-status[data-field="${field}"]`); //breaks "other" counts in chart, as it's a calculated, non-editable cell!
                const featCell = row.querySelector(`[data-field="${field}"]`);
                if (featCell && featCell.textContent.trim() === '') {
                    yearlyFeatures[year][field]++;
                }
            });
            // Note: Yearly model counts are updated inside the 'model' field loop above
        }
    });

    // Make counts available outside this function
    latestCounts = counts;
    latestYearlyData = {
        surveyImpl: yearlySurveyImpl,
        techniques: yearlyTechniques,
        features: yearlyFeatures,
        pubTypes: yearlyPubTypes,
        // --- ADD yearlyModels to latestYearlyData ---
        models: yearlyModels
    };

    // ... (rest of the function remains the same: visible/loaded counts, footer updates)
    if (document.body.id === 'html-export') {
        // Alternative code for specific page
        document.getElementById('visible-count-cell').innerHTML = `<strong>${visiblePaperCount}</strong> paper${visiblePaperCount !== 1 ? 's' : ''} of <strong>${totalPaperCount}</strong>`;
    } else {
        // Original code for other pages
        const visiblePapersCountCell = document.getElementById('visible-papers-count');
        const loadedPapersCountCell = document.getElementById('loaded-papers-count');
        loadedPapersCountCell.textContent = loadedPaperCount;
        visiblePapersCountCell.textContent = visiblePaperCount;
    }

    // --- Update Footer Counts ---
    COUNT_FIELDS.forEach(field => {
        // Skip the 'pdf_annotated' field for direct footer update, as it's part of the combined PDF cell
        if (field === 'pdf_annotated') {
             return; // Skip updating the individual annotated count cell directly
        }
        const countCell = document.getElementById(`count-${field}`);
        if (countCell) {
            // For 'pdf_present', set the text content to the total count
            // and add a tooltip showing both counts
            if (field === 'pdf_present') {
                countCell.textContent = counts['pdf_present'];
                countCell.title = `Stored PDFs: ${counts['pdf_present']}, Annotated PDFs: ${counts['pdf_annotated']}, Paywalled: ${counts['pdf_paywalled']}. Data for the currently filtered set.`; // Set tooltip
            } else {
                // For all other fields, set the text content normally
                // Now, counts['model'] reflects the total number of model mentions
                countCell.textContent = counts[field];
            }
        }
    });
}

function calculateJournalConferenceStats() {
    const journalCounts = {};
    const conferenceCounts = {};
    // Select only VISIBLE main rows
    const visibleRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]:not(.filter-hidden)');
    visibleRows.forEach(row => {
        const journalCell = row.cells[journalCellIndex]; // Use the global defined in globals.js
        const typeCell = row.cells[typeCellIndex]; // Use the global defined in globals.js
        if (journalCell && typeCell) {
            const journalName = journalCell.textContent.trim();
            const type = typeCell.getAttribute('title') || typeCell.textContent.trim(); // Prefer title attribute for type
            // Only count if journal name is not empty
            if (journalName) {
                if (type && type.toLowerCase() === 'article') {
                    journalCounts[journalName] = (journalCounts[journalName] || 0) + 1;
                } else if (type && type.toLowerCase() === 'inproceedings') {
                    conferenceCounts[journalName] = (conferenceCounts[journalName] || 0) + 1; // Use journal cell content for conf name
                }
            }
        }
    });
    // Sort and filter results (count >= 2)
    const sortedJournals = Object.entries(journalCounts)
        .filter(([name, count]) => count >= 1) // Filter after counting
        .sort((a, b) => b[1] - a[1]); // Sort by count descending
    const sortedConferences = Object.entries(conferenceCounts)
        .filter(([name, count]) => count >= 1) // Filter after counting
        .sort((a, b) => b[1] - a[1]); // Sort by count descending
    return {
        journals: sortedJournals.map(([name, count]) => ({ name, count })),
        conferences: sortedConferences.map(([name, count]) => ({ name, count }))
    };
}

function calculateCumulativeData(originalDataArray) {
    if (!originalDataArray || originalDataArray.length === 0) return [];
    const cumulativeData = [];
    let sum = 0;
    for (let i = 0; i < originalDataArray.length; i++) {
        sum += originalDataArray[i];
        cumulativeData.push(sum);
    }
    return cumulativeData;
}
/* ----------  AUTO-ORDER DATASETS WHEN STACKED  ---------- */
/* Correct for cumulative + stacked together.                */
function reorderDatasetsForStacking() {
    if (!isStacked) return;                // nothing to do when un-stacked
    const charts = [
        window.surveyVsImplLineChartInstance,
        window.techniquesPerYearLineChartInstance,
        window.featuresPerYearLineChartInstance,
        window.pubTypesPerYearLineChartInstance
    ].filter(Boolean);

    charts.forEach(chart => {
        const { datasets } = chart.data;

        /* Build an array of { datasetIndex, total } using the CURRENT data
           (already cumulative if cumulative is on) */
        const totals = datasets.map((ds, idx) => ({
            idx,
            total: ds.data.reduce((a, b) => a + b, 0)
        }));

        /* Sort descending by total */
        totals.sort((A, B) => B.total - A.total);

        /* Re-order only the datasets array (colours/labels stay intact) */
        chart.data.datasets = totals.map(t => datasets[t.idx]);
        chart.update();
    });
}

/* ----------  cumulative total in legend: Kimi K2 ---------- */
function cumulativeLegendLabels(chart) {
  const   defaults = Chart.defaults.plugins.legend.labels.generateLabels;
  const   labels   = defaults.call(this, chart);   // keep default click behaviour

  if (!isCumulative) return labels;                // nothing to do

  labels.forEach(lbl => {
    const ds   = chart.data.datasets[lbl.datasetIndex];
    const data = ds.data;
    const last = (Array.isArray(data) && data.length)
                 ? data[data.length - 1]           // largest cumulative value
                 : 0;
    lbl.text = `${lbl.text}  (${last})`;         // append total
  });
  return labels;
}



//Unified full-client-side stats implementation:
function buildDetailRowLists(callback) {    
    const stats = {
        journals: {}, 
        conferences: {}, 
        keywords: {},
        authors: {},
        researchAreas: {},
        otherDetectedFeatures: {},
        modelNames: {}
    };
    const visibleRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]:not(.filter-hidden)');
    visibleRows.forEach(row => {
        // --- Get Journal/Conference and Type ---
        const journalCell = row.cells[journalCellIndex]; // Index 4 (Journal/Conf column)
        const typeCell = row.cells[typeCellIndex]; // Index 5 (Type column)

        if (journalCell && typeCell) { // Ensure cells exist
            const journalConfName = journalCell.textContent.trim();
            const typeValue = (typeCell.getAttribute('title') || typeCell.textContent.trim()).toLowerCase(); // Use title if available, standardize case

            if (journalConfName) {
                // Determine if it's a journal or conference based on type
                // Common BibTeX types: 'article' -> journal, 'inproceedings', 'proceedings', 'conference' -> conference
                if (typeValue === 'article') {
                    stats.journals[journalConfName] = (stats.journals[journalConfName] || 0) + 1;
                } else if (typeValue === 'inproceedings' || typeValue === 'proceedings' || typeValue === 'conference') {
                    stats.conferences[journalConfName] = (stats.conferences[journalConfName] || 0) + 1;
                } else {
                    // Optional: Handle other types or log them if needed
                    // console.log(`Unrecognized type for ${journalConfName}: ${typeValue}`);
                    // You could add them to a 'miscellaneous' category if desired
                }
            }
        }

        // --- Existing Logic for Keywords, Authors, etc. ---
        // (Keep the rest of the loop body unchanged)
        const detailRow = row.nextElementSibling;
        if (detailRow && detailRow.classList.contains('detail-row')) {
            const keywordsPara = detailRow.querySelector('.detail-metadata p strong');
            if (keywordsPara && keywordsPara.textContent.trim() === 'Keywords:') {
                const keywordsParent = keywordsPara.parentElement;
                if (keywordsParent) {
                    let keywordsText = keywordsParent.textContent.trim();
                    const prefix = "Keywords:";
                    if (keywordsText.startsWith(prefix)) {
                        keywordsText = keywordsText.substring(prefix.length).trim();
                    }
                    const keywordsList = keywordsText.split(';')
                        .map(kw => kw.trim())
                        .filter(kw => kw.length > 0);
                    keywordsList.forEach(keyword => {
                        stats.keywords[keyword] = (stats.keywords[keyword] || 0) + 1;
                    });
                }
            }
        }
        let authorsList = [];
        const detailRowForAuthors = row.nextElementSibling;
        if (detailRowForAuthors && detailRowForAuthors.classList.contains('detail-row')) {
            const authorsPara = Array.from(detailRowForAuthors.querySelectorAll('.detail-metadata p')).find(p => {
                const strongTag = p.querySelector('strong');
                return strongTag && strongTag.textContent.trim() === 'Full Authors:';
            });
            if (authorsPara) {
                let authorsText = authorsPara.textContent.trim();
                const prefix = "Full Authors:";
                if (authorsText.startsWith(prefix)) {
                    authorsText = authorsText.substring(prefix.length).trim();
                }
                if (authorsText) {
                    authorsList = authorsText.split(';')
                        .map(author => author.trim())
                        .filter(author => author.length > 0);
                } else {
                    console.warn("Found 'Full Authors:' paragraph but no author text following it.", row);
                }
            }
        }
        authorsList.forEach(author => {
            stats.authors = stats.authors || {};
            stats.authors[author] = (stats.authors[author] || 0) + 1;
        });
        const detailRowForResearchArea = row.nextElementSibling;
        if (detailRowForResearchArea && detailRowForResearchArea.classList.contains('detail-row')) {
            const researchAreaInput = detailRowForResearchArea.querySelector('.detail-edit input[name="research_area"]');
            if (researchAreaInput) {
                const researchArea = researchAreaInput.value.trim();
                if (researchArea) {
                    stats.researchAreas[researchArea] = (stats.researchAreas[researchArea] || 0) + 1;
                }
            }
        }
        // --- New Logic for Other Detected Features ---
        const detailRowForOtherFeature = row.nextElementSibling;
        if (detailRowForOtherFeature && detailRowForOtherFeature.classList.contains('detail-row')) {
            const otherFeatureInput = detailRowForOtherFeature.querySelector('.detail-edit input[name="features_other"]');
            if (otherFeatureInput) {
                const otherFeatureText = otherFeatureInput.value.trim();
                if (otherFeatureText) {
                    // Split by semicolon, trim, filter out empty strings
                    const featuresList = otherFeatureText.split(';')
                        .map(f => f.trim())
                        .filter(f => f.length > 0);
                    featuresList.forEach(feature => {
                        // Count occurrences of each feature string
                        stats.otherDetectedFeatures[feature] = (stats.otherDetectedFeatures[feature] || 0) + 1;
                    });
                }
            }
        }
        // --- New Logic for Model Names ---
        const detailRowForModelName = row.nextElementSibling;
        if (detailRowForModelName && detailRowForModelName.classList.contains('detail-row')) {
            const modelNameInput = detailRowForModelName.querySelector('.detail-edit input[name="model_name"]'); // Adjust selector if necessary
            if (modelNameInput) {
                const modelNameText = modelNameInput.value.trim();
                if (modelNameText) {
                    // Split by comma or semicolon, trim whitespace, filter out empty strings
                    const modelNamesList = modelNameText.split(/[,;]/).map(m => m.trim()).filter(m => m.length > 0);
                    modelNamesList.forEach(modelName => {
                        // Count occurrences of each individual model name string
                        stats.modelNames[modelName] = (stats.modelNames[modelName] || 0) + 1; // Fixed: Added space around ||
                    });
                }
            }
        }
    });
    

    // Function to populate lists where items must appear more than once (count > 1)
    function populateList(listElementId, dataObj) {
        const listElement = document.getElementById(listElementId);
        if (!listElement) {
            console.warn(`List element with ID ${listElementId} not found.`);
            return;
        }
        listElement.innerHTML = '';

        const sortedEntries = Object.entries(dataObj)
            .filter(([name, count]) => count >= 1) // Keep only entries with count > 1
            .sort((a, b) => {
                if (b[1] !== a[1]) {
                    return b[1] - a[1];
                }
                return a[0].localeCompare(b[0]);
            });

        if (sortedEntries.length === 0) {
            listElement.innerHTML = '<li>No items with count > 1.</li>';
            return;
        }

        sortedEntries.forEach(([name, count]) => {
            const listItem = document.createElement('li');
            // Escape HTML to prevent XSS if data contains special characters
            const escapedName = name.replace(/&/g, "&amp;").replace(/</g, "<").replace(/>/g, ">");
            const escapedNameForTitle = escapedName.replace(/"/g, "&quot;"); // Escape quotes for title attribute

            // Create the list item content with count, search button, and name
            listItem.innerHTML = `<span class="count">${count}</span><button type="button" class="search-item-btn" title="Search for &quot;${escapedNameForTitle}&quot;"></button><span class="name">${escapedName}</span>`;

            listElement.appendChild(listItem);
        });

        // Add event listeners to the newly created search buttons
        listElement.querySelectorAll('.search-item-btn').forEach(button => {
            button.addEventListener('click', function() {
                const listItem = this.closest('li');
                const nameSpan = listItem.querySelector('.name');
                if (nameSpan) {
                    const searchTerm = nameSpan.textContent.trim();
                    searchInput.value = searchTerm; // Set the search input value
                    closeModal(); // Close the stats modal
                    applyLocalFilters(); // Trigger the filter update
                }
            });
        });
    }
    // --- New Function Call to Populate Lists with Search Buttons ---
    // Function to populate lists where items *can* appear only once (no > 1 filter)
    function populateSimpleList(listElementId, dataObj) {
        const listElement = document.getElementById(listElementId);
        if (!listElement) {
            console.warn(`List element with ID ${listElementId} not found.`);
            return;
        }
        listElement.innerHTML = '';

        // Sort entries: primarily by count (descending), then alphabetically (ascending) for ties
        const sortedEntries = Object.entries(dataObj)
            .sort((a, b) => {
                if (b[1] !== a[1]) {
                    return b[1] - a[1]; // Sort by count descending
                }
                return a[0].localeCompare(b[0]); // Sort alphabetically ascending if counts are equal
            });

        if (sortedEntries.length === 0) {
            listElement.innerHTML = '<li>No items found.</li>';
            return;
        }

        sortedEntries.forEach(([name, count]) => {
            const listItem = document.createElement('li');
            // Escape HTML to prevent XSS if data contains special characters
            const escapedName = name.replace(/&/g, "&amp;").replace(/</g, "<").replace(/>/g, ">");
            const escapedNameForTitle = escapedName.replace(/"/g, "&quot;"); // Escape quotes for title attribute

            // Create the list item content with count, search button, and name
            listItem.innerHTML = `<span class="count">${count}</span><button type="button" class="search-item-btn" title="Search for &quot;${escapedNameForTitle}&quot;"></button><span class="name">${escapedName}</span>`;

            listElement.appendChild(listItem);
        });

        // Add event listeners to the newly created search buttons
        listElement.querySelectorAll('.search-item-btn').forEach(button => {
            button.addEventListener('click', function() {
                const listItem = this.closest('li');
                const nameSpan = listItem.querySelector('.name');
                if (nameSpan) {
                    const searchTerm = nameSpan.textContent.trim();
                    searchInput.value = searchTerm; // Set the search input value
                    closeModal(); // Close the stats modal
                    applyLocalFilters(); // Trigger the filter update
                }
            });
        });
    }

    // Populate the new lists using the new helper functions
    // Populate Journals (only items with type 'article')
    // populateList('journalStatsList', stats.journals); // Uses stats.journals object
    // Populate Conferences (only items with type 'inproceedings', 'proceedings', 'conference')
    // populateList('conferenceStatsList', stats.conferences); // NEW: Uses stats.conferences object
    populateList('keywordStatsList', stats.keywords);
    populateList('authorStatsList', stats.authors);
    populateList('researchAreaStatsList', stats.researchAreas);

    populateSimpleList('otherDetectedFeaturesStatsList', stats.otherDetectedFeatures);
    populateSimpleList('modelNamesStatsList', stats.modelNames);
    
    // ---- now the lists exist; build cloud if switch is on ----
    if (document.getElementById('cloudToggle').checked) {
        toggleCloud();                     // first render
    }
    if (callback) callback(); // Call the callback function after populating lists

    // Trigger reflow and add modal-active class after charts are drawn and lists are populated
    // modal.offsetHeight; // Trigger reflow
    // modal.classList.add('modal-active');
    // return stats;
}



function displayStats() {
    document.documentElement.classList.add('busyCursor');
    setTimeout(() => {
        updateCounts(); // Run updateCounts to get the latest data for visible rows
        TECHNIQUE_FIELDS_FOR_YEARLY.forEach((field, index) => { TECHNIQUE_FIELD_COLOR_MAP[field] = index; });
        FEATURE_FIELDS_FOR_YEARLY.forEach((field, index) => { FEATURE_FIELD_INDEX_MAP[field] = index; });

        // Populate the groups with the actual feature fields
        FEATURE_FIELDS_FOR_YEARLY.forEach(field => {
            const originalIndex = FEATURE_FIELD_INDEX_MAP[field];
            const originalColorHSLA = featuresColorsOriginalOrder[originalIndex];
            // Find the base color index that matches this feature's color:
            let baseColorIndex = null;
            for (let key in featureColorGroups) {
                const keyIndex = parseInt(key);
                if (featuresColorsOriginalOrder[keyIndex] === originalColorHSLA) {
                    baseColorIndex = keyIndex;
                    break;
                }
            }
            if (baseColorIndex !== null && featureColorGroups[baseColorIndex]) {
                featureColorGroups[baseColorIndex].fields.push(field);
            } else {
                console.warn(`Could not find matching base color for feature ${field}`);
            }
        });

        // --- Read Counts from Footer Cells ---
        // We read the counts directly from the cells updated by updateCounts()
        function getCountFromFooter(fieldId) {
            const cell = document.getElementById(`count-${fieldId}`);
            if (cell) {
                const text = cell.textContent.trim();
                const number = parseInt(text, 10);
                return isNaN(number) ? 0 : number;
            }
            return 0;
        }

        // --- Prepare Features Distribution Chart Data (Original or Grouped) ---
        let featuresChartData;
        if (showPieCharts) {
            // --- Grouped Data for Pie Chart ---
            // Calculate aggregated values based on featureColorGroups
            const groupedLabels = [];
            const groupedValues = [];
            const groupedBackgroundColors = [];
            // const groupedBorderColors = [];

            // Iterate through the defined groups
            Object.keys(featureColorGroups).forEach(baseColorIndex => {
                const group = featureColorGroups[baseColorIndex];
                groupedLabels.push(group.label); // Use the group's label (e.g., 'PCB Features')

                // Sum the counts for all features within this group
                let groupSum = 0;
                group.fields.forEach(field => {
                    groupSum += getCountFromFooter(field);
                });
                groupedValues.push(groupSum);

                // Use the color associated with the base index for this group
                const colorIndex = parseInt(baseColorIndex);
                groupedBackgroundColors.push(featuresColorsOriginalOrder[colorIndex]);
                // groupedBorderColors.push(featuresBorderColorsOriginalOrder[colorIndex]);
            });

            featuresChartData = {
                labels: groupedLabels,
                datasets: [{
                    label: 'Features Count (Grouped)',
                    data: groupedValues,
                    backgroundColor: groupedBackgroundColors,
                    borderColor: "#333",         // fixed color as the translucent mapping lacks contrast for bar or pie charts
                    borderWidth: 1,
                    hoverOffset: 4
                }]
            };
        } else {
            // --- Original Data for Bar Chart ---
            const featuresLabels = FEATURE_FIELDS.map(field => FIELD_LABELS[field] || field);
            const featuresValues = FEATURE_FIELDS.map(field => getCountFromFooter(field));
            const featuresBackgroundColors = featuresColorsOriginalOrder; // Use original colors
            // const featuresBorderColors = featuresBorderColorsOriginalOrder; // Use original border colors

            featuresChartData = {
                labels: featuresLabels,
                datasets: [{
                    label: 'Features Count',
                    data: featuresValues,
                    backgroundColor: featuresBackgroundColors,
                    borderColor: "#333",         // fixed color as the translucent mapping lacks contrast for bar or pie charts
                    borderWidth: 1,
                    hoverOffset: 4
                }]
            };
        }

        // --- Prepare Techniques Distribution Chart Data (Excluding Datasets count) ---
        const TECHNIQUE_FIELDS_NO_DATASET = TECHNIQUE_FIELDS_ALL.filter(field => field !== 'technique_available_dataset');
        // Read and sort the data for the distribution chart
        const techniquesData = TECHNIQUE_FIELDS_NO_DATASET.map(field => ({
            label: FIELD_LABELS[field] || field,
            value: getCountFromFooter(field),
            originalIndex: TECHNIQUE_FIELD_COLOR_MAP[field] !== undefined ? TECHNIQUE_FIELD_COLOR_MAP[field] : -1 // Get original color index
        }));
        // Sort by value descending (largest first) for the distribution chart display
        techniquesData.sort((a, b) => b.value - a.value);
        // Extract sorted labels and values
        const sortedTechniquesLabels = techniquesData.map(item => item.label);
        const sortedTechniquesValues = techniquesData.map(item => item.value);
        // Map the sorted order back to the original colors using the stored originalIndex
        const sortedTechniquesBackgroundColors = techniquesData.map(item => techniquesColors[item.originalIndex] || 'rgba(0,0,0,0.1)');
        const sortedTechniquesBorderColors = techniquesData.map(item => techniquesBorderColors[item.originalIndex] || 'rgba(0,0,0,1)');

        const techniquesChartData = {
            labels: sortedTechniquesLabels,
            datasets: [{
                label: 'Techniques Count',
                data: sortedTechniquesValues,
                backgroundColor: sortedTechniquesBackgroundColors, // Use mapped colors
                borderColor: "#333",         // fixed color as the translucent mapping lacks contrast for bar or pie charts
                borderWidth: 1,
                hoverOffset: 4
            }]
        };

        // --- Destroy existing charts if they exist (important for re-renders) ---
        if (window.featuresBarChartInstance) {
            window.featuresBarChartInstance.destroy();
            delete window.featuresBarChartInstance;
        }
        if (window.techniquesBarChartInstance) {
            window.techniquesBarChartInstance.destroy();
            delete window.techniquesBarChartInstance;
        }
        if (window.surveyVsImplLineChartInstance) {
            window.surveyVsImplLineChartInstance.destroy();
            delete window.surveyVsImplLineChartInstance;
        }
        if (window.techniquesPerYearLineChartInstance) {
            window.techniquesPerYearLineChartInstance.destroy();
            delete window.techniquesPerYearLineChartInstance;
        }
        if (window.featuresPerYearLineChartInstance) {
            window.featuresPerYearLineChartInstance.destroy();
            delete window.featuresPerYearLineChartInstance;
        }
        if (window.pubTypesPerYearLineChartInstance) {
            window.pubTypesPerYearLineChartInstance.destroy();
            delete window.pubTypesPerYearLineChartInstance;
        }

        // --- Get Canvas Contexts for ALL charts ---
        const featuresCtx = document.getElementById('featuresPieChart')?.getContext('2d');
        const techniquesCtx = document.getElementById('techniquesPieChart')?.getContext('2d');
        const surveyVsImplCtx = document.getElementById('surveyVsImplLineChart')?.getContext('2d');
        const techniquesPerYearCtx = document.getElementById('techniquesPerYearLineChart')?.getContext('2d');
        const featuresPerYearCtx = document.getElementById('featuresPerYearLineChart')?.getContext('2d');
        const pubTypesPerYearCtx = document.getElementById('pubTypesPerYearLineChart')?.getContext('2d'); // Get context for pub types chart

        // --- Render Features Distribution Chart (Bar or Pie) ---
        const featuresChartType = showPieCharts ? 'pie' : 'bar';
        const featuresChartOptions = {
            type: featuresChartType,
            data: featuresChartData,
            options: {
                // Conditionally apply indexAxis for bar chart, omit for pie
                ...(featuresChartType === 'bar' ? { indexAxis: 'y' } : {}),
                ...(featuresChartType === 'pie' ? { radius: '90%' } : {}), // Adjust '80%' as needed (e.g., '70%', '90%')
                responsive: true,
                maintainAspectRatio: false,               

                plugins: {
                    legend: { 
                        display: featuresChartType === 'pie', // Show legend only for pie charts
                        position: 'top', // Position legend differently for pie
                        labels: {
                            usePointStyle: featuresChartType == 'pie', // Use point style for bar chart markers, not pie
                            pointStyle: 'circle',
                        }
                    },
                    title: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Show count for both bar and pie
                                return `${context.label}: ${context.raw}`;
                            }
                        }
                    }
                },
                // Only apply scales for bar chart
                ...(featuresChartType === 'bar' ? {
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: { precision: 0 }
                        }
                    }
                } : {})
            }
        };
        window.featuresBarChartInstance = new Chart(featuresCtx, featuresChartOptions); // Keep variable name for consistency if needed, or rename to featuresChartInstance

        // --- Render Techniques Distribution Chart (Bar or Pie) ---
        const techniquesChartType = showPieCharts ? 'pie' : 'bar';
        const techniquesChartOptions = {
            type: techniquesChartType,
            data: techniquesChartData, // Uses sortedTechniques* with mapped colors
            options: {
                // Conditionally apply indexAxis for bar chart, omit for pie
                ...(techniquesChartType === 'bar' ? { indexAxis: 'y' } : {}),               
                ...(featuresChartType === 'pie' ? { radius: '90%' } : {}), // Adjust '80%' as needed (e.g., '70%', '90%')
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: featuresChartType === 'pie', // Show legend only for pie charts
                        position: 'top', // Position legend differently for pie
                        labels: {
                            usePointStyle: techniquesChartType == 'pie', // Use point style for bar chart markers, not pie
                            pointStyle: 'circle'
                        }
                    },
                    title: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Show count for both bar and pie
                                return `${context.label}: ${context.raw}`;
                            }
                        }
                    }
                },
                 // Only apply scales for bar chart
                ...(techniquesChartType === 'bar' ? {
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: { precision: 0 }
                        }
                    }
                } : {})
            }
        };
        window.techniquesBarChartInstance = new Chart(techniquesCtx, techniquesChartOptions); // Keep variable name for consistency if needed, or rename to techniquesChartInstance

        // --- Render Line Charts ---
        // 1. Survey vs Implementation Papers per Year
        const surveyImplData = latestYearlyData.surveyImpl || {};
        const yearsForSurveyImpl = Object.keys(surveyImplData).map(Number).sort((a, b) => a - b);
        const surveyCounts = yearsForSurveyImpl.map(year => surveyImplData[year].surveys || 0);
        const implCounts = yearsForSurveyImpl.map(year => surveyImplData[year].impl || 0);

        let surveyCountsFinal = surveyCounts;
        let implCountsFinal = implCounts;
        if (isCumulative) {
            surveyCountsFinal = calculateCumulativeData(surveyCounts);
            implCountsFinal = calculateCumulativeData(implCounts);
        }

        window.surveyVsImplLineChartInstance = new Chart(surveyVsImplCtx, {
            type: 'line',
            data: {
                labels: yearsForSurveyImpl,
                datasets: [
                    {
                        label: 'Survey Papers',
                        data: surveyCountsFinal, // Use final data array
                        borderColor: 'hsl(204, 42%, 37%)', // Blue
                        backgroundColor: 'hsla(204, 42%, 67%, 0.95)',
                        fill: isStacked, // Fill is controlled by stacked option below
                        tension: 0.25
                    },
                    {
                        label: 'Implementation Papers',
                        data: implCountsFinal, // Use final data array
                        borderColor: 'hsla(38, 70%, 49%, 1.00)', // Red
                        backgroundColor: 'hsla(53, 50%, 69%, 0.95)',
                        fill: isStacked, // Fill is controlled by stacked option below
                        tension: 0.25
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,  // Use the point style
                            pointStyle: 'circle',  // Specify the circle style
                            generateLabels: cumulativeLegendLabels   // <-- added
                        }
                    },
                    title: { display: false, text: 'Survey vs Implementation Papers per Year' },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                return `${context.dataset.label}: ${context.raw}`;
                            }
                        }
                    }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        ticks: { precision: 0 },
                        stacked: isStacked // Apply stacking to Y-axis
                    },
                    x: { 
                        ticks: { precision: 0 },
                        stacked: isStacked // Apply stacking to X-axis if needed (usually not for line charts, but for bar compatibility)
                    }
                }
            }
        });

        // 2. Techniques per Year (Consistent Colors)
        const techniquesYearlyData = latestYearlyData.techniques || {};
        const yearsForTechniques = Object.keys(techniquesYearlyData).map(Number).sort((a, b) => a - b);
        // Create datasets for the line chart using the ORIGINAL field order and ORIGINAL colors
        // This ensures color consistency regardless of sorting in the bar chart
        const techniqueLineDatasets = TECHNIQUE_FIELDS_FOR_YEARLY.map(field => {
            const label = (typeof FIELD_LABELS !== 'undefined' && FIELD_LABELS[field]) ? FIELD_LABELS[field] : field;
            let data = yearsForTechniques.map(year => techniquesYearlyData[year]?.[field] || 0);
            if (isCumulative) {
                data = calculateCumulativeData(data);
            }
            const originalIndex = TECHNIQUE_FIELD_COLOR_MAP[field] !== undefined ? TECHNIQUE_FIELD_COLOR_MAP[field] : -1;
            // --- FIX: Use techniquesBorderColors for border, techniquesColors for background ---
            const borderColor = (originalIndex !== -1 && techniquesBorderColors[originalIndex]) ? techniquesBorderColors[originalIndex] : 'rgba(0, 0, 0, 1)'; // Use border colors array
            const backgroundColor = (originalIndex !== -1 && techniquesColors[originalIndex]) ? techniquesColors[originalIndex] : 'rgba(0, 0, 0, 0.1)'; // Use fill colors array (usually with alpha for line charts when stacked)
            return {
                label: label,
                data: data, // Use final data array
                borderColor: borderColor,       // Use the dedicated border color
                backgroundColor: backgroundColor, // Use the dedicated fill color (often with alpha)
                fill: isStacked, // Fill is controlled by stacked option below
                tension: 0.25
            };
        });

        if (techniquesPerYearCtx && techniqueLineDatasets.length > 0) {
            window.techniquesPerYearLineChartInstance = new Chart(techniquesPerYearCtx, {
                type: 'line',
                data: {
                    labels: yearsForTechniques, // Use years sorted
                    datasets: techniqueLineDatasets // Use datasets prepared with consistent colors
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,  // Use the point style
                                pointStyle: 'circle',  // Specify the circle style
                                generateLabels: cumulativeLegendLabels   // <-- added
                            }
                        },
                        title: { display: false, text: 'Techniques per Year' },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.raw}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            ticks: { precision: 0 },
                            stacked: isStacked // Apply stacking to Y-axis
                        },
                        x: { 
                            ticks: { precision: 0 },
                            stacked: isStacked // Apply stacking to X-axis if needed
                        }
                    }
                }
            });
        } else if (techniquesPerYearCtx) {
            window.techniquesPerYearLineChartInstance = new Chart(techniquesPerYearCtx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: 'Techniques per Year (No Data)' }
                    }
                }
            });
        }

        // 3. Features per Year (Summed by Color Group)
        const featuresYearlyData = latestYearlyData.features || {};
        const yearsForFeatures = Object.keys(featuresYearlyData).map(Number).sort((a, b) => a - b);
        // --- Create Aggregated Data by Color Group ---
        // Aggregate yearly data for each color group
        const aggregatedFeatureDataByColor = {};
        Object.keys(featureColorGroups).forEach(baseColorIndex => {
            const group = featureColorGroups[baseColorIndex];
            aggregatedFeatureDataByColor[group.label] = yearsForFeatures.map(year => {
                return group.fields.reduce((sum, field) => {
                    return sum + (featuresYearlyData[year]?.[field] || 0);
                }, 0);
            });
        });

        const aggregatedFeatureDataByColorFinal = {};
        Object.keys(aggregatedFeatureDataByColor).forEach(label => {
            let data = aggregatedFeatureDataByColor[label];
            if (isCumulative) {
                data = calculateCumulativeData(data);
            }
            aggregatedFeatureDataByColorFinal[label] = data;
        });
        
        // Create datasets for the line chart using the aggregated data and corresponding colors
        const featureLineDatasets = Object.keys(featureColorGroups).map(baseColorIndex => {
            const group = featureColorGroups[baseColorIndex];
            const colorIndex = parseInt(baseColorIndex); // Use the base color index to get the actual color
            // --- FIX: Use featuresBorderColorsOriginalOrder for border, featuresColorsOriginalOrder for background ---
            const borderColor = (featuresBorderColorsOriginalOrder[colorIndex]) ? featuresBorderColorsOriginalOrder[colorIndex] : 'rgba(0, 0, 0, 1)'; // Use border colors array
            const backgroundColor = (featuresColorsOriginalOrder[colorIndex]) ? featuresColorsOriginalOrder[colorIndex] : 'rgba(0, 0, 0, 0.1)'; // Use fill colors array (usually with alpha for line charts when stacked)
            // --- END FIX ---
            return {
                label: group.label,
                data: aggregatedFeatureDataByColorFinal[group.label], // Use final data array
                borderColor: borderColor,       // Use the dedicated border color
                backgroundColor: backgroundColor, // Use the dedicated fill color (often with alpha)
                fill: isStacked, // Fill is controlled by stacked option below
                tension: 0.25
            };
        });

        if (featuresPerYearCtx && featureLineDatasets.length > 0) {
            window.featuresPerYearLineChartInstance = new Chart(featuresPerYearCtx, {
                type: 'line',
                data: {
                    labels: yearsForFeatures, // Use years sorted
                    datasets: featureLineDatasets // Use datasets prepared with aggregated data and consistent colors
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,  // Use the point style
                                pointStyle: 'circle',  // Specify the circle style
                                generateLabels: cumulativeLegendLabels   // <-- added
                            }
                        },
                        title: { display: false, text: 'Features per Year' },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.raw}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            ticks: { precision: 0 },
                            stacked: isStacked // Apply stacking to Y-axis
                        },
                        x: { 
                            ticks: { precision: 0 },
                            stacked: isStacked // Apply stacking to X-axis if needed
                        }
                    }
                }
            });
        } else if (featuresPerYearCtx) {
            window.featuresPerYearLineChartInstance = new Chart(featuresPerYearCtx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: 'Features per Year (No Data)' }
                    }
                }
            });
        }

        // --- 4. Publication Types per Year ---
        const pubTypesYearlyData = latestYearlyData.pubTypes || {};
        const yearsForPubTypes = Object.keys(pubTypesYearlyData).map(Number).sort((a, b) => a - b);
        // --- Aggregate data for the chart ---
        // Get all unique publication types across all years
        const allPubTypesSet = new Set();
        Object.values(pubTypesYearlyData).forEach(yearData => {
            Object.keys(yearData).forEach(type => allPubTypesSet.add(type));
        });
        const allPubTypes = Array.from(allPubTypesSet).sort(); // Sort for consistent legend order

        // Create datasets for the line chart, one for each publication type
        const pubTypeLineDatasets = allPubTypes.map((type, index) => {
            // Generate a distinct color for each type (simple hue rotation)
            // You might want to use a more sophisticated color palette
            const hue = (index * 137.508) % 360; // Golden angle approximation for spread
            const borderColor = `hsl(${hue}, 40%, 40%)`;
            const backgroundColor = `hsla(${hue}, 30%, 65%, 0.85)`; 
            let data = yearsForPubTypes.map(year => pubTypesYearlyData[year]?.[type] || 0);
            if (isCumulative) {
                data = calculateCumulativeData(data);
            }
            return {
                label: type, // Use the raw type name as label (or map if needed)
                data: data, // Use final data array
                borderColor: borderColor,
                backgroundColor: backgroundColor,
                fill: isStacked, // Fill is controlled by stacked option below
                tension: 0.25,
                hidden: false // Start visible
            };
        });

        // --- Render the Publication Types per Year Line Chart ---
        if (pubTypesPerYearCtx && pubTypeLineDatasets.length > 0) {
            window.pubTypesPerYearLineChartInstance = new Chart(pubTypesPerYearCtx, {
                type: 'line',
                data: {
                    labels: yearsForPubTypes, // Use sorted years
                    datasets: pubTypeLineDatasets // Use datasets prepared above
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'circle',
                                generateLabels: cumulativeLegendLabels   // <-- added
                            }
                        },
                        title: { display: false, text: 'Publication Types per Year' },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `${context.dataset.label}: ${context.raw}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { precision: 0 },
                            title: {
                                display: false,
                                text: 'Count'
                            },
                            stacked: isStacked // Apply stacking to Y-axis
                        },
                        x: {
                            ticks: { precision: 0 },
                            title: {
                                display: false,
                                text: 'Year'
                            },
                            stacked: isStacked // Apply stacking to X-axis if needed
                        }
                    }
                }
            });
        } else if (pubTypesPerYearCtx) {
            // Handle case where there's no data
            window.pubTypesPerYearLineChartInstance = new Chart(pubTypesPerYearCtx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: 'Publication Types per Year (No Data)' }
                    }
                }
            });
        }

        const { journals, conferences } = calculateJournalConferenceStats();

        //comms.s or ghpages.js (different functions depending on source!)  
        //This fetches data from server on full implementation (no detail row readily available)
        //or directly from detail row contents on HTML exports
        // buildDetailRowLists(); 
    
        // --- Populate Client-side Journal/Conference Lists ---
        function populateListFromClient(listElementId, dataArray) { //for items with count >=2
            const listElement = document.getElementById(listElementId);
            listElement.innerHTML = '';
            if (!dataArray || dataArray.length === 0) {
                listElement.innerHTML = '<li>No items with count > 1.</li>';
                return;
            }
            dataArray.forEach(item => {
                const listItem = document.createElement('li');
                const escapedName = (item.name || '').toString()
                    .replace(/&/g, "&amp;").replace(/</g, "<")
                    .replace(/>/g, ">").replace(/"/g, "&quot;")
                    .replace(/'/g, "&#39;");
                // --- Preserve Original Structure ---
                const countSpan = document.createElement('span');
                countSpan.className = 'count';
                countSpan.textContent = item.count;
                const nameSpan = document.createElement('span');
                nameSpan.className = 'name';
                nameSpan.textContent = escapedName;
                const searchButton = document.createElement('button');
                searchButton.type = 'button';
                searchButton.className = 'search-item-btn';
                searchButton.title = `Search for "${item.name}"`;
                searchButton.textContent = '';
                searchButton.addEventListener('click', function(event) {
                    event.stopPropagation();
                    searchInput.value = item.name;
                    closeModal();
                    const inputEvent = new Event('input', { bubbles: true });
                    searchInput.dispatchEvent(inputEvent);
                });
                listItem.appendChild(countSpan);
                listItem.appendChild(searchButton);
                listItem.appendChild(nameSpan);
                listElement.appendChild(listItem);
            });
        }
        populateListFromClient('journalStatsList', journals);
        populateListFromClient('conferenceStatsList', conferences); // Use the new ID

        // --- Populate Metrics Table (Updated Logic) ---
        // Assume server lists (keywords, authors, etc.) are already populated
        // by an initial call to buildDetailRowLists() before displayStats() is run for the first time
        // or when filters change.
        // This function calculates metrics based on current state.
        function populateMetricsTableDirectly() { // Renamed for clarity
            const tableElement = document.getElementById('metricsTableStatsList');
            if (!tableElement) {
                console.error("Metrics table element with ID 'metricsTableStatsList' not found.");
                return;
            }

            // Clear previous content
            tableElement.innerHTML = '';

            // Calculate metrics based on latestCounts and the lists already assumed to be populated
            const filteredPapersCount = latestCounts['pdf_present'] || 0;
            const distinctJournalsCount = journals.length; // Client-side calculation
            const distinctConferencesCount = conferences.length; // Client-side calculation

            // Count distinct authors from the author list (assuming it's already populated by buildDetailRowLists)
            // This is the critical part: this function assumes authorStatsList is already up-to-date.
            const authorListElement = document.getElementById('authorStatsList');
            let distinctAuthorsCount = 0;
            if (authorListElement) {
                // Count the <li> elements inside the author list *after* it's populated by buildDetailRowLists
                distinctAuthorsCount = authorListElement.querySelectorAll('li').length;
                // console.log("Authors counted in displayStats:", distinctAuthorsCount); // Debug log
            } else {
                console.warn("Author stats list element with ID 'authorStatsList' not found for counting authors.");
            }

            // Count papers providing datasets
            const papersWithDatasetCount = latestCounts['technique_available_dataset'] || 0;

            // Create table rows - Modified to support HTML in the label
            const createRow = (labelHtml, value) => {
                const row = document.createElement('tr');
                const labelCell = document.createElement('td');
                labelCell.innerHTML = labelHtml; // Use innerHTML for formatted labels
                const valueCell = document.createElement('td');
                valueCell.innerHTML = '<strong>' + value + '</strong>'; // Use innerHTML for bold value
                labelCell.className = 'metric-label';
                valueCell.className = 'metric-value';
                row.appendChild(labelCell);
                row.appendChild(valueCell);
                return row;
            };
            
            // Select only VISIBLE main rows for counting '' and calculating visible count
            const visibleRows = document.querySelectorAll('#papersTable tbody tr[data-paper-id]:not(.filter-hidden)');
            const visiblePaperCount = visibleRows.length;
            // Append rows to the table
            tableElement.appendChild(createRow('Total <strong>filtered</strong> articles:', visiblePaperCount));
            tableElement.appendChild(createRow('Total unique <strong>journals</strong>:', distinctJournalsCount));
            tableElement.appendChild(createRow('Total unique <strong>conferences</strong>:', distinctConferencesCount));
            tableElement.appendChild(createRow('Total unique <strong>authors</strong>:', distinctAuthorsCount)); // Relies on pre-populated list
            tableElement.appendChild(createRow('Articles mentioning <strong>available dataset</strong>:', papersWithDatasetCount));
        }

        // Call the direct population function here
        populateMetricsTableDirectly();

        // ---- now the lists exist; build cloud if switch is on ----
        if (document.getElementById('cloudToggle').checked) {
            toggleCloud();                     // first render
        }

        // Trigger reflow to ensure styles are applied before adding the active class
        // This helps ensure the transition plays correctly on the first open
        modal.offsetHeight;
        // Add the active class to trigger the animation
        modal.classList.add('modal-active');
        setTimeout(() => {
            document.documentElement.classList.remove('busyCursor');
        }, 500); 
    }, 20);
}


function displayAbout(){
    modalSmall.offsetHeight;
    modalSmall.classList.add('modal-active');
}
function closeSmallModal() { modalSmall.classList.remove('modal-active'); }

function closeModal() { modal.classList.remove('modal-active'); } //for stats modal:

function buildKeywordCloud() {
    const canvas = document.querySelector('#keywordCloudCanvas canvas');
    const ctx    = canvas?.getContext('2d');
    if (!ctx) return;

    const liNodes = document.querySelectorAll('#keywordStatsList li');
    const raw = Array.from(liNodes)
                     .map(li => {
                         const nameEl  = li.querySelector('.name');
                         const countEl = li.querySelector('.count');
                         if (!nameEl || !countEl) return null;
                         return {
                             text: nameEl.textContent.trim(),
                             size: +countEl.textContent
                         };
                     })
                     .filter(Boolean);

    /*  NEW: empty list  wipe canvas and stop  */
    if (!raw.length) {
        const dpr = window.devicePixelRatio || 1;
        ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        return;
    }

    const top_k = raw.slice(0, 50);

    /* ----------  canvas setup for hiDPI ---------- */
    const dpr = window.devicePixelRatio || 1;

    const displayWidth = canvas.parentElement.clientWidth;   // CSS pixels
    const displayHeight = 280;                               // CSS px (matches markup)

    canvas.width = displayWidth * dpr;                       // physical px
    canvas.height = displayHeight * dpr;
    canvas.style.width = displayWidth + 'px';
    canvas.style.height = displayHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);                // auto-scale draws

    ctx.clearRect(0, 0, displayWidth, displayHeight);

    /* ----------  font scale ---------- */
    const sizeScale = d3.scaleLinear()
                        .domain([top_k[top_k.length - 1].size, top_k[0].size])
                        .range([8, 40]);

    /* ----------  cloud layout ---------- */
    const layout = d3.layout.cloud()
        .size([displayWidth, displayHeight])
        .words(top_k.map(d => ({...d, size: sizeScale(d.size)})))
        .padding(4)
        .rotate(() => (Math.random() - 0.5) * 0)
        .font('sans-serif')
        .fontSize(d => d.size)
        .on('end', draw);

    layout.start();

    function draw(words) {
        ctx.save();
        ctx.translate(displayWidth / 2, displayHeight / 2);
        words.forEach(w => {
            ctx.save();
            ctx.translate(w.x, w.y);
            ctx.rotate(w.rotate * Math.PI / 180);
            ctx.font = `${w.size}px sans-serif`;
            ctx.fillStyle = techniquesBorderColors[w.text.length % techniquesBorderColors.length];
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(w.text, 0, 0);
            ctx.restore();
        });
        ctx.restore();
    }
}


function toggleCloud() {
    const list   = document.getElementById('keywordStatsList');
    const canvas = document.getElementById('keywordCloudCanvas');
    const on     = document.getElementById('cloudToggle').checked;

    list.style.display   = on ? 'none' : 'block';
    canvas.style.display = on ? 'block' : 'none';

    if (!on) return; //  dont build if turning off

    const liNodes = list.querySelectorAll('li');
    if (liNodes.length === 0) return; //  dont build if no keywords

    buildKeywordCloud(); //  safe to build
}

document.addEventListener('DOMContentLoaded', function () {

    const stackingToggle = document.getElementById('stackingToggle');
    const cumulativeToggle = document.getElementById('cumulativeToggle');
    const pieToggle = document.getElementById('pieToggle');
    const cloudToggle = document.getElementById('cloudToggle');

    stackingToggle.checked = false;
    cumulativeToggle.checked = false;
    pieToggle.checked = false;
    cloudToggle.checked = false; // NEW: Initialize the cloud toggle state

    statsBtn.addEventListener('click', function () {
        document.documentElement.classList.add('busyCursor');
        setTimeout(() => {
            // NEW: Call buildDetailRowLists only once when opening the modal,
            // or whenever filters change significantly.
            // Move the call OUTSIDE of displayStats and only call it here initially,
            // OR call it whenever search/filter results update.
            // For now, let's assume it should run when the modal opens IF the lists are stale/empty.
            // A simple approach: Call it once on first open, or if a flag indicates refresh is needed.

            // Option A: Always fetch on open (less efficient if data rarely changes)
            // buildDetailRowLists(() => displayStats()); // Pass displayStats as the callback

            // Option B: Fetch once initially, then only when filters change significantly (e.g., search)
            // This requires a variable to track if data needs refreshing.
            // Let's implement Option B for better performance.

            // Assume a flag or check might be needed later to decide if refetch is necessary
            // For now, since filters (like search) likely trigger updateCounts and maybe a general refresh,
            // we might call buildDetailRowLists from the search/filter logic.
            // For the button click, just call displayStats, assuming data is fresh enough or fetched elsewhere.
            // UNLESS it's the very first time the modal is opened.

            // Let's add a simple flag to fetch once on first open of the stats modal.
            if (typeof window.detailRowsFetched === 'undefined' || !window.detailRowsFetched) {
                buildDetailRowLists(() => {
                    window.detailRowsFetched = true; // Set the flag after fetching
                    displayStats(); // Now display stats with potentially updated lists
                });
            } else {
                // If lists were already fetched, just display stats directly
                displayStats();
            }

            // OR, if you want to ensure the most up-to-date lists every time the modal opens
            // (accepting the potential latency), use:
            // buildDetailRowLists(() => displayStats());

        }, 10); // Keep the initial timeout
    });


    stackingToggle.addEventListener('change', function() {
        isStacked = this.checked; // Update the state variable
        // Update the chart options for stacking
        if (window.surveyVsImplLineChartInstance) {
            window.surveyVsImplLineChartInstance.options.scales.y.stacked = isStacked;
            window.surveyVsImplLineChartInstance.options.scales.x.stacked = isStacked;
            window.surveyVsImplLineChartInstance.data.datasets.forEach(dataset => {
                 dataset.fill = isStacked;
            });
            window.surveyVsImplLineChartInstance.update(); // Update the chart
        }
        if (window.techniquesPerYearLineChartInstance) {
            window.techniquesPerYearLineChartInstance.options.scales.y.stacked = isStacked;
            window.techniquesPerYearLineChartInstance.options.scales.x.stacked = isStacked;
            window.techniquesPerYearLineChartInstance.data.datasets.forEach(dataset => {
                 dataset.fill = isStacked;
            });
            window.techniquesPerYearLineChartInstance.update();
        }
        if (window.featuresPerYearLineChartInstance) {
            window.featuresPerYearLineChartInstance.options.scales.y.stacked = isStacked;
            window.featuresPerYearLineChartInstance.options.scales.x.stacked = isStacked;
            window.featuresPerYearLineChartInstance.data.datasets.forEach(dataset => {
                 dataset.fill = isStacked;
            });
            window.featuresPerYearLineChartInstance.update();
        }
        if (window.pubTypesPerYearLineChartInstance) {
            window.pubTypesPerYearLineChartInstance.options.scales.y.stacked = isStacked;
            window.pubTypesPerYearLineChartInstance.options.scales.x.stacked = isStacked;
            window.pubTypesPerYearLineChartInstance.data.datasets.forEach(dataset => {
                 dataset.fill = isStacked;
            });
            window.pubTypesPerYearLineChartInstance.update();
        }
        reorderDatasetsForStacking();
    });

    cumulativeToggle.addEventListener('change', function() {
        isCumulative = this.checked; // Update the state variable
        // Re-display the stats to recalculate data and re-render charts with the new state
        // Since data changes, we need to call displayStats again
        // However, we need to preserve the current toggle state *before* calling displayStats
        // The state variables `isStacked` and `isCumulative` are already updated by the event handler
        // So calling displayStats should work correctly with the new state.
        // We can call displayStats directly, but it might be slow if counts are recalculated.
        // A more efficient way would be to extract the chart updating logic into a separate function.
        // For now, we'll re-call displayStats, assuming the performance impact is acceptable within the modal.
        // A more efficient approach would be to store the original yearly data separately
        // and only re-calculate the cumulative/stacked data and update the datasets.
        // Let's implement the re-display approach first.
        displayStats(); // This will re-run the entire display process, including data recalculation and chart rendering
        // Note: This might cause the modal to flicker slightly or re-open if not handled carefully.
        // A more robust solution would be to refactor the chart creation logic into a separate function
        // that can be called with the current `isStacked` and `isCumulative` values without re-fetching server data.
        // For the purpose of this modification, calling displayStats is a functional solution.
        // To prevent the modal from closing if it was already open, we need to ensure the active class is maintained.
        // Since displayStats adds the class, we need to ensure the modal is still considered open.
        // The setTimeout in displayStats should handle the cursor, but the modal state might be reset.
        // A better approach might be to only update the datasets and options of the existing charts,
        // rather than recreating them entirely.
        // However, changing cumulative requires re-processing the data arrays, which is easier with a full redraw.
        // Stacking can be updated via options.update().
        // For now, let's assume calling displayStats is acceptable.
        // If flickering or performance becomes an issue, the chart update logic should be refactored.
        if (isStacked) reorderDatasetsForStacking();    //doesn't really work, though.
    });

    pieToggle.addEventListener('change', function() {
        showPieCharts = this.checked; // Update the state variable
        displayStats(); // Re-display to recreate charts with new type
    });
    
    aboutBtn.addEventListener('click', displayAbout);
    // --- Close Modal
    spanClose.addEventListener('click', closeModal);
    smallClose.addEventListener('click', closeSmallModal);
    document.addEventListener('keydown', function (event) {
        // Check if the pressed key is 'Escape' and if the modal is currently active
        if (event.key === 'Escape') { closeModal(); closeSmallModal(); 
            if (document.body.id !== "html-export") {closeBatchModal(); closeExporthModal(); closeImportModal()} }
    });

    cloudToggle.addEventListener('change', toggleCloud);

    cloudToggle.checked = true;          // 1. UI match
    showKeywordCloud = true;             // 2. keep state in sync
    
    window.addEventListener('click', function (event) {
        if (event.target === modal || event.target === modalSmall) {
            closeModal();
            closeSmallModal();
        }
        
        if (document.body.id !== 'html-export') {
            if (event.target === batchModal || event.target === importModal || event.target === exportModal) {
                closeBatchModal();
                closeImportModal();
                closeExporthModal();
            }
        }
    });

});

```

```css
# static\style.css
@keyframes spin {
    0% {
        transform: rotate(0deg)
    }

    to {
        transform: rotate(360deg)
    }
}

:root {
    --text-color: #393939;
    --background-color: #f5f7fa;
    --table-row-even: #00000006;
    --table-row-odd: #0000;
    --highlighted-col-background: #bbccbb22;
    --primary-ui-color: hsl(188, 31%, 29%);
    --primary-ui-color-darker: hsl(188, 34%, 27%);
    --inferred-ui-color: hsl(154.6, 35.8%, 32.4%);
    --inferred-gradient-end-color: rgb(57, 106, 53);
    --stats-primary-ui-color: var(--primary-ui-color);
    --modal-wrapper-background: #eee6;
    --classify-btn-color: hsl(246, 29%, 40%);
    --verify-btn-color: hsl(276, 29%, 40%);
    --save-btn-color: rgb(58, 136, 47);
    --export-html-btn-color: rgb(54, 90, 145);
    --export-xlsx-btn-color: rgb(58, 136, 47);
    --restore-btn-color: var(--primary-ui-color-darker);
    --backup-btn-color: var(--primary-ui-color);
    --light-colored-btn-color: rgb(185, 209, 209);
    --light-colored-btn-text: #0a5662;
    --dark-shadow: 1px 0 5px #0006;
    --light-shadow: 1px 0 5px #fff6;
    --th-border-color: #0000003b;
    --link-color: rgb(0, 45, 115);
    --detail-button-background: linear-gradient(180deg, hsl(210, 24%, 87%) 0%, hsl(210, 32%, 93%) 60%);
    --min-width: 1660px;
}

body {
    font-family: "Inter Tight",Arial,sans-serif;
    margin: 8px;
    background-color: var(--background-color);
    color: var(--text-color);
}

html.busyCursor body,html.busyCursor body * {
    cursor: wait
}

.loading-overlay {
    position: fixed;
    top: 58px;
    left: 9px;
    margin: 0;
    padding: 0;
    width: calc(100% - 18px);
    height: calc(100% - 67px);
    backdrop-filter: blur(12px);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity .3s ease;
    transition-delay: .33s;
    border-radius: 8px;
    background: var(--modal-wrapper-background);
    flex-direction: column;
    gap: 40px;
}

html.busyCursor .loading-overlay {
    opacity: 1;
    pointer-events: all;
}

.loading-spinner {
    width: 60px;
    height: 60px;
    border: 12px solid var(--primary-ui-color);
    border-top: 12px solid transparent;
    border-radius: 50%;
    animation: spin .75s linear infinite
}

.table-container {
    box-shadow: 0 2px 8px rgba(0,0,0,.35);
    border: 1px solid var(--primary-ui-color);
    overflow-y: auto;
    max-height: calc(100vh - 18px);
    position: relative;
    border-radius: 8px
}

h3,th {
    position: sticky;
    top: 0;
    text-shadow: var(--dark-shadow);
    z-index: 100;
}

h3 {
    margin: 0;
    padding: 10px 0 10px 10px;
    background: var(--stats-primary-ui-color);
    color: #fefefe;
    display: inline-block;
    font-weight: 400;
    width: calc(100% - 10px);
    background: linear-gradient(180deg,var(--primary-ui-color) 50%,var(--primary-ui-color-darker) 100%)
}

table {
    border-collapse: collapse;
    width: 100%;
    background-color: #fff;
    min-width: var(--min-width);
    border-radius: 6px;
}

td {
    padding: 9px 6px;
}

th.rotate-header {
    white-space: nowrap;
    padding: 0
}


.header-branding{
    font-size: 24pt;
    justify-self: center;
    font-family: "Arial Narrow";
    font-weight: 400;
    color: #3f8d82;
    text-shadow: var(--light-shadow);
}


th.rotate-header>div {
    transform: rotate(-90deg) translateX(-40px);
    width: 27px;
    margin: 52px 0;
}

th.rotate-header>div>span {
    display: block;
    text-align: left;
    max-height: 100px
}

th {
    vertical-align: bottom;
    background-color: var(--primary-ui-color);
    color: #fff;
    font-weight: 700;
    box-shadow: inset 0 0 0 .75px var(--th-border-color);
    padding: 6px;
    text-align: left;
    z-index: 10;
    font-size: 8.5pt
}

tr:nth-child(4) th:not(.inferred-header) {
    background: linear-gradient(180deg,var(--primary-ui-color) 50%,var(--primary-ui-color-darker) 100%)
}

th[data-sort]:hover {
    filter: contrast(1.25) brightness(.9);
    cursor: pointer
}

td.highlight-status {
    background: var(--highlighted-col-background)
}

.alt-shade-1,li:nth-child(even),  #metricsTableStatsList :nth-child(even) {
    background-color: var(--table-row-even);
}

.alt-shade-2,li:nth-child(odd),  #metricsTableStatsList :nth-child(odd) {
    background-color: var(--table-row-odd);
}

.secondary-text-cell {
    font-size: 10pt;
    font-family: "Arial Narrow"
}

.detail-content {
    text-align: justify
}

.toggle-btn {
    cursor: pointer;
    text-decoration: none;
    color: #000b;
    background: var(--detail-button-background);
    font-size: 9.5pt;
    font-weight: 400;
    transition: filter .3s ease-in-out;
    text-align: center;
    box-shadow: inset 0 0 0 .5px #0006
}

.toggle-btn:hover {
    filter: saturate(200%) contrast(110%)
}

.sort-indicator {
    position: absolute;
    right: 8px;
    top: 36px;
    transform: translateY(-50%);
    font-size: .9em
}

input[type=search] {
    width: calc(100% - 4px);
    box-sizing: border-box;
    padding: 8px;
    border: 1px solid #0008;
    font-family: inherit;
    height: 42px;
    font-size: 11pt;
    font-style: italic;
    margin: 2px;
    color: #fff;
    background: #0000002a;
    -webkit-text-fill-color: #fff;
    -webkit-opacity: 1;
    opacity: .66;
    border-radius: 6px;
    transition: .25s all ease
}

input[type=search]:focus,input[type=search]:hover {
    opacity: 1;
    transition: .25s all ease
}

input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration,input[type=search]::-webkit-search-results-button,input[type=search]::-webkit-search-results-decoration {
    -webkit-appearance: none
}

input[type=search]::placeholder {
    color: rgba(255,255,255,.7);
    opacity: 1
}

input[type=search]::-webkit-input-placeholder {
    color: rgba(255,255,255,.7);
    opacity: 1
}

.filter-item input[type=number] {
    height: 28px;
    width: 55px;
    background: 0 0;
    color: #eee;
    font-size: 10.5pt;
    border: 0;
    padding: 3px 4px;
    margin: 0-18px 0 0;
    transition: .25s all ease;
    -moz-appearance: textfield;
    appearance: textfield;
    font-weight: 700
}

.filter-item input[type=number]:hover {
    background: #0002;
    border-radius: 3px;
    transition: .25s all ease;
    -moz-appearance: unset;
    appearance: unset;
    z-index: 9999
}

.action-btn {
    margin: 0 2px;
    /*! padding: 10px 20px; */
    background-color: var(--primary-ui-color);
    color: #fff;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11pt;
    transition: all .33s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,.15);
    min-width: 160px;
    height: 40px;
    text-shadow: var(--dark-shadow);
    border: 1px solid #0002;
}

.action-btn:hover {
    filter: contrast(1.2) brightness(1.2);
    box-shadow: 0 3px 5px rgba(0,0,0,.15)
}

.action-btn:active {
    transform: translateY(1px);
    filter: contrast(1.2) brightness(.8);
    transition: all .1s ease
}

.action-btn:disabled {
    opacity: .5
}

.action-btn:disabled:hover {
    filter: unset;
    transform: unset
}

.action-btn:disabled:active {
    filter: unset
}

.edit-section {
    margin-top: 15px;
    padding-top: 15px
}

form label {
    display: block;
    font-weight: 700;
    line-height: 2em
}

form input[type=text] {
    margin-bottom: 10px
}

.changed-by-cell,.changed-cell {
    font-size: 9.5pt;
    color: #7f8c8d
}

.status-cell {
    text-align: center;
    font-size: 1.25em;
    padding: 0px;
    font-family: "Segoe UI Emoji Windows 11";
}

.editable-status,.editable-verify, .pdf-status {
    cursor: pointer;
    transition: background-color .2s,transform .1s;
    border-radius: 3px;
    box-shadow: 0 1px 2px rgba(64,64,64,.1);
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none
}

.editable-status:hover,.editable-verify:hover, .pdf-status:hover {
    background-color: var(--light-colored-btn-color);
    transform: scale(1.1);
    box-shadow: 0 2px 4px rgba(0,0,0,.1)
}

.editable-status:active,.editable-verify:active, .pdf-status:active {
    transform: scale(.95);
    background-color: var(--light-colored-btn-color)
}

.detail-flex-container {
    max-height: 0;
    overflow: hidden;
    transition: max-height .25s ease-in-out,opacity .3s ease-in-out;
    display: grid;
    grid-template-columns: 1fr 1fr 530px;
    grid-template-rows: auto;
    gap: 9px;
    box-sizing: border-box;
    width: 100%;
    padding: 0 0 0 10px;
    margin: 0
}

.detail-row.expanded .detail-flex-container {
    max-height: 3000px;
    opacity: 1;
    transition: max-height .5s ease-in-out,opacity .4s ease-in-out;
    border-bottom: 1px solid #e0e0e0
}

.detail-content {
    min-width: 0;
    box-sizing: border-box;
    padding: 4px
}

.detail-edit {
    min-width: 0;
    grid-column: 3/4;
    grid-row: 1/3
}

.detail-content p,.detail-edit p {
    text-align: justify;
    white-space: normal;
    margin-bottom: .5em;
    line-height: 1.3em
}

.detail-row>td {
    padding: 0
}

.detail-edit input[type=text] {
    padding: 6px;
    border: 1px solid #dadada;
    border-radius: 5px;
    font-family: inherit;
    font-size: 1em;
    background: #ffffffa0
}

.save-btn {
    background-color: var(--save-btn-color);
    width: 170px;
    font-weight: 700
}

#classify-all-btn,#classify-remaining-btn,.classify-btn {
    background: var(--classify-btn-color)
}

#verify-all-btn,#verify-remaining-btn,.verify-btn {
    background: var(--verify-btn-color);
}

#classify-all-btn strong,#verify-all-btn strong {
    text-decoration: underline
}

#export-html-btn {
    background: var(--export-html-btn-color)
}

#export-xlsx-btn {
    background: var(--export-xlsx-btn-color)
}
#backup-btn{
    background: var(--backup-btn-color);
}
#restore-btn{
    background: var(--restore-btn-color)
}
#stats-btn {
    width: 160px;
    max-width: 160px;
    min-width: 160px;
    background: var(--stats-primary-ui-color);
}
#para-tools-btn{
    background: var(--classify-btn-color);
}

#batchModal, #importModal, #exportModal{
    backdrop-filter: unset;
    background: unset;
}
#apply-serverside-filters, #html-export #stats-btn {
    background: var(--light-colored-btn-color);
    width: 125px;
    max-width: 125px;
    min-width: 125px;
    color: var(--light-colored-btn-text);
    font-size: 10pt;
    text-shadow: var(--light-shadow);
    transition: .2s all ease-in-out;
    padding: 0;
}

#html-export #about-btn {
    background: var(--light-colored-btn-color);
    color: var(--light-colored-btn-text);
    width: 30px;
    min-width: 30px;
    padding: 0;
}

#fullscreen-btn {
    background: 0 0;
    width: 28px;
    max-width: 28px;
    min-width: 28px;
    height: 36px;
    padding: 0;
    box-shadow: none;
    display: none
}

#about-btn {
    width: 30px;
    min-width: 30px;
    padding: 0
}

a {
    text-decoration: none;
    color: var(--link-color);
    font-weight: 400
}

th.inferred-header {
    background: var(--inferred-ui-color)
}

th.inferred-header-2 {
    filter: contrast(1.1) saturate(.95) hue-rotate(-16deg)
}

th.inferred-header-3 {
    filter: contrast(1.15) saturate(.95) hue-rotate(-36deg)
}

#inferred-header-title {
    background: linear-gradient(90deg,var(--inferred-ui-color),var(--inferred-gradient-end-color))
}

#inferred-header-title div, .inferred-header:not(.rotate-header) div {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    padding: 0 6px 0 0px;
    align-items: end;
}

.filter-item {
    white-space: nowrap
}

input[type=checkbox] {
    height: 12px;
    width: 12px;
    margin: 0;
    transform: scale(1.85,2) translate(1px,-1.5px);
    border-radius: 0;
    opacity: .5
}

input[type="checkbox"]:checked, input[type="checkbox"]:indeterminate {
    opacity: 1;
    filter: hue-rotate(-50deg) brightness(1.3)
}

.filter-item label {
    margin-bottom: 0
}

tr.filter-hidden {
    display: none
}

#counts-footer {
    position: sticky;
    bottom: 0;
    z-index: 998;
    border-radius: 6px
}

#counts-footer tr {
    background-color: var(--primary-ui-color);
    color: #fff;
    font-weight: 700;
}

#counts-footer td {
    text-align: center;
    font-size: 8.5pt;
    padding: 9px 0
}

.trace-content {
    white-space: pre-wrap;
    word-wrap: break-word;
    word-break: break-word;
    padding: 8px 12px;
    border: 1px solid #dadada;
    background-color: #aaaaaa0b;
    border-radius: 5px;
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    margin: 6px 0 10px;
    font-size: 10.5pt;
    grid-column: 1/3;
}

.detail-evaluator-trace,.detail-verifier-trace {
    display: grid;
    min-width: 100%;
    grid-template-columns: 1fr 170px;
    grid-template-rows: max-content max-content;
    align-items: end;
}

#main-header-wrapper {
    padding: 0
}

.main-header {
    display: grid;
    grid-template-columns: auto auto 1fr auto auto auto;
    grid-template-rows: auto;
    gap: 4px;
    align-items: center;
    background-color: #e0e6ed;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
    min-width: var(--min-width);
    height: 48px;
    background: var(--detail-button-background);
    border-radius: 8px 8px 0 0
}

.header-title h2 {
    margin: 0;
    color: #2c3e50;
    font-size: 1.5em
}

.header-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: center;
    color: #eee;
    font-weight: 400;
    justify-content: space-between
}

.filter-item {
    display: inline-flex;
    align-items: center;
    padding: 5px;
    font-size: 10.5pt
}

.menu-message {
    font-size: 10pt;
    padding: 4px;
}

#batch-actions, #import-actions, #export-actions{
    z-index: 1000;
    overflow: auto;
    opacity: 1;
    /*! pointer-events: none; */
    display: flex;
    justify-content: center;
    align-items: center;
    position: fixed;
    background: var(--modal-wrapper-background);
    backdrop-filter: blur(16px);
    perspective: 100vh;
    flex-direction: column;
    padding: 10px;
    gap: 16px;
    border-radius: 8px;
    background: #f5f7fad9;
    border: 1px solid #444;
    box-shadow: 0 48px 96px 32px rgba(64,64,64, 0.5);
    box-sizing: border-box;
    transition: opacity .3s ease-in-out, transform .3s ease-out;
    /*! background: linear-gradient(180deg,var(--classify-btn-color) 0%,var(--verify-btn-color) 48px,#f5f7fad9 20px); */
    width: 358px;
    text-align: justify;
}
#batch-actions{
    top: 56px;
    right: 220px;
    transform: scale3d(.75,.66,1) translateY(-66px) translateX(40px);
}
#import-actions{
    top: 56px;
    left: 10px;
    transform: scale3d(.75,.66,1) translateY(-66px) translateX(-40px);
}
#export-actions{
    top: 56px;
    left: 180px;
    transform: scale3d(.75,.66,1) translateY(-66px) translateX(-40px);
}


.header-controls {
    margin: 0 4px
}

.detail-edit {
    display: grid;
    height: 100%;
    padding: 0 12px 12px 0;
    box-sizing: border-box
}

.detail-edit form {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 90px;
    grid-template-rows: auto auto 1fr auto;
    gap: 10px;
    height: calc(100% - 16px)
}

.detail-edit form>label:nth-of-type(1) {
    grid-column: 1/3;
    grid-row: 1/2
}

.detail-edit form>label:nth-of-type(2) {
    grid-column: 3/5;
    grid-row: 1/2
}

.detail-edit form>label:nth-of-type(3) {
    grid-column: 1/3;
    grid-row: 2/3
}

.detail-edit form>label:nth-of-type(4) {
    grid-column: 3/4;
    grid-row: 2/3
}

.detail-edit form>label:nth-of-type(5) {
    grid-column: 4/5;
    grid-row: 2/3
}

.detail-edit input[type=text] {
    width: 100%;
    box-sizing: border-box
}

.detail-edit form>label:nth-of-type(6) {
    grid-column: 1/-1;
    grid-row: 3/4;
    display: flex;
    flex-direction: column
}

.detail-edit form textarea.editable {
    width: 100%;
    min-width: 100%;
    height: 100%;
    box-sizing: border-box;
    min-height: 150px;
    border-radius: 5px;
    display: block;
    resize: none;
    background: #ffffffa0;
    border: 1px solid #dadada
}

.detail-edit form>.row-actions {
    grid-column: 1/-1;
    grid-row: 4/5;
    text-align: left;
    display: flex;
    align-content: space-around;
    justify-content: space-between
}

.number-cell {
    text-align: center
}

.ontop-header {
    z-index: 100
}

.modal-content,.modal-small-content {
    background: linear-gradient(180deg,var(--stats-primary-ui-color) 0%,var(--stats-primary-ui-color) 20px,#f5f7fad9 20px);
    /*! border: 2px solid var(--stats-primary-ui-color); */
    border-radius: 8px;
    box-shadow: 0 16px 96px -0px rgba(0,0,0,.66);
    position: relative;
    box-sizing: border-box;
    overflow: hidden;
    transform: scale3d(.94,.94,1) rotate3d(2,1,0,2.5deg) translateY(-20px);
    transition: transform .3s ease-out;
    display: grid
}

.modal-content {
    width: calc(100vw - 60px);
    min-width: calc(var(--min-width) + 70px);
    height: calc(100vh - 12px);
    grid-template-columns: 640px 1fr;
}

.modal-small-content {
    width: 1400px;
    grid-template-columns: 1fr 340px;
    min-width: 1400px;
}

.modal-small-section h4,.modal-small-section p,.modal-small-section ul {
    padding: 0 18px
}

.close {
    color: #eee;
    float: right;
    font-size: 28px;
    font-weight: 700;
    position: absolute;
    right: 16px;
    top: 4px;
    cursor: pointer;
    z-index: 1001;
    text-shadow: var(--dark-shadow)
}

.close:focus,.close:hover {
    color: #fff;
    text-decoration: none
}

.stats-section ul {
    list-style-type: none;
    padding-left: 0;
    margin: 0;
    overflow: hidden;
    border-right: 2px solid var(--stats-primary-ui-color);
}

.stats-section li {
    padding: 4px 3px;
    font-size: 9.5pt
}

.stats-section li span.count {
    font-weight: 700;
    min-width: 40px;
    display: inline-block;
    text-align: center
}

.stats-section p {
    padding: 0 10px;
    font-size: 10.5pt
}

.stats-list-multicolumn-short {
    column-count: 3;
    padding: 0 10px;
    max-height: 2048px;
}

.stats-list-multicolumn-2,.stats-list-multicolumn-short {
    column-gap: 0;
    break-inside: avoid-column
}

.stats-list-multicolumn li {
    break-inside: avoid
}

.modal {
    z-index: 1000;
    overflow: auto;
    opacity: 0;
    pointer-events: none;
    transition: opacity .25s ease-in-out;
    display: flex;
    justify-content: center;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--modal-wrapper-background);
    backdrop-filter: blur(12px);
    perspective: 100vh
}

.modal p {
    text-align: justify
}

.modal.modal-active {
    opacity: 1;
    pointer-events: auto;
    transition-delay: .3s
}

.modal.modal-active .modal-content,
.modal.modal-active .modal-small-content,
.modal.modal-active #batch-actions,
.modal.modal-active #import-actions, 
.modal.modal-active #export-actions {
    transform: none;
    transition-delay: .2s
}

.stats-section {
    overflow-y: scroll;
    overflow-x: hidden;
    /*! border-right: 2px solid var(--stats-primary-ui-color); */
}

.stats-lists {
    display: grid;
    /* grid-template-rows: 1fr 1fr 1.5fr 1fr 90px 1fr 1fr; */
    grid-template-rows: 1fr 328px 1fr 197px;

    grid-template-columns: 1fr 1fr;
    min-height: 0;
    /*! border-right: 2px solid var(--stats-primary-ui-color); */
}

.stats-charts{
    display: grid;
    grid-template-columns: 152px 152px 1fr 1fr 1fr 1fr;
    grid-template-rows: calc(36vh - 6px) calc(36vh - 6px) calc(28vh - 8px);
}
.stats-charts .stats-section:nth-child(1) {
    grid-row: 1/2;
    grid-column: 1/3;
/*     height: calc(32vh - 10px); */
}
.stats-charts .stats-section:nth-child(2) {
    grid-row: 2/3;
    grid-column: 1/3;
/*     height: calc(32vh - 10px); */
}
.stats-charts .stats-section:nth-child(3) {
    grid-row: 3/4;
    grid-column: 1/4;
    height: calc(32vh - 10px);
}
.stats-charts .stats-section:nth-child(4) {
    grid-row: 1/2;
    grid-column: 3/7;
/*     height: calc(32vh - 10px); */
}
.stats-charts .stats-section:nth-child(5) {
    grid-row: 2/3;
    grid-column: 3/7;
/*     height: calc(32vh - 10px); */
    
}
.stats-charts .stats-section:nth-child(6) {
    grid-row: 3/4;
    grid-column: 4/7;
    height: calc(32vh - 10px);
    
}








/* Style for the search button inside the stats list items */
.search-item-btn {
    background: none;
    border: none; /* Optional: Add a border */
     /* Optional: Adjust color */
    cursor: pointer;
    font-size: 0.9em; /* Make it smaller */
     /* Space it from the text */
     /* Small padding */
    border-radius: 3px; /* Rounded corners */
    padding: 1px 2px;
    transform: scale(1.5) translate(-4px,-0.5px);
    opacity: 0.5;
    transition: 0.5s opacity ease;
}

.search-item-btn:hover {
    background-color: #f0f0f0; /* Light background on hover */
    opacity: 1; /* Darker border on hover */
}





/* Ensure the list items layout accommodates the button */
li {
    display: flex; /* Use flexbox */
    justify-content: space-between; /* Distribute space */
    align-items: center; /* Align items vertically */
    gap: 4px; /* Add a small gap between elements */
}

.stats-list-multicolumn-2 li .count,
.stats-list-multicolumn-short li .count {
    flex-shrink: 0; /* Don't shrink the count */
}

.stats-list-multicolumn-2 li .name,
.stats-list-multicolumn-short li .name {
    flex-grow: 1; /* Allow the name to grow */
    word-break: break-word; /* Break long names if necessary */
}

.stats-list-multicolumn-2 li .search-item-btn,
.stats-list-multicolumn-short li .search-item-btn {
    flex-shrink: 0; /* Don't shrink the button */
}



/* Container for the search input and clear button */
.search-container {
    position: relative;
    display: inline-block; /* Or 'block' depending on desired layout behavior */
    width: 100%; /* Adjust width as needed, often 100% to fill the table cell */
}

/* Style the clear button */
.clear-btn {
    position: absolute;
    right: 5px; 
    top: 50%; 
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #aaa; 
    cursor: pointer;
    font-size: 24px;
    width: 32px; 
    height: 32px;
    display: none;
    transition: opacity 0.2s; /* Smooth opacity transition */
}

/* Show the clear button when search has content */
#search-input:not(:placeholder-shown) + .clear-btn {
    display: inline;
}

/* Optional: Style the clear button on hover */
.clear-btn:hover {
    color: #eee; /* Darker color on hover */
}

#metricsTableStatsList{
    min-width: 0;
    font-size: 10pt;
    background: #0000;
    border-right: 2px solid var(--stats-primary-ui-color);
    text-align: right;
}
#metricsTableStatsList td{
    padding: 7px;
}
#keywordCloud span {
  display: inline-block;
  margin: 4px 6px;
  cursor: pointer;
  transition: transform .15s;
}
#keywordCloud span:hover {
  transform: scale(1.15);
}



@media screen and (max-width:1880px) {
    body {
        margin: 0
    }

    .table-container {
        max-height: calc(100vh);
        border-radius: 0;
        background: var(--primary-ui-color);
        border: 0
    }

    .loading-overlay {
        left: 0;
        width: calc(100%);
        height: calc(100%);
        border-radius: 0
    }

    .main-header {
        border-radius: 0
    }
    #batch-actions{
        top: 48px;
        right: 216px;
    }
    #import-actions{
        top: 48px;
        left: 6px;
    }
    #export-actions{
        top: 48px;
        left: 176px;
    }
}

::-webkit-scrollbar {
    width: 0;
    height: 0
}
```

```text
# static\pdfjs\LICENSE

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS
```

```javascript
# static\pdfjs\web\autosave.js
document.addEventListener('DOMContentLoaded', function () {
    const PDFViewerApplication = window.PDFViewerApplication;
    if (!PDFViewerApplication) {
        console.error("PDFViewerApplication is not available.");
        return;
    }

    // --- 1. Get the paper_id from the URL ---
    const urlParams = new URLSearchParams(window.location.search);
    const fileUrl = urlParams.get('file');
    let paperId = '';
    if (fileUrl) {
        // The URL is now /serve_pdf/paper_id
        paperId = decodeURIComponent(fileUrl.split('/').pop());
    }

    if (!paperId) {
        console.error("Could not determine the paper_id from the URL.");
        return;
    }

    // --- 2. Debounce function ---
    function debounce(func, delay) {
        let timeoutId;
        return function (...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }

    // --- 3. Function to save and upload the annotated PDF ---
    async function saveAndUploadPdf() {
        try {
            // This is the core PDF.js function to get the modified file data [13-15]
            const updatedPdfData = await PDFViewerApplication.pdfDocument.saveDocument();
            const blob = new Blob([updatedPdfData], { type: 'application/pdf' });
            const formData = new FormData();
            formData.append('pdf_file', blob, "annotated.pdf");

            // Construct the NEW server route using the paper_id
            const uploadUrl = `/upload_annotated_pdf/${encodeURIComponent(paperId)}`;
            
            // --- 4. Send the file to the new server route ---
            const response = await fetch(uploadUrl, {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error(`Server responded with status: ${response.status}`);
            }
            const result = await response.json();
            if (result.status === 'success') {
                console.log('Auto-save successful:', result.message);
            } else {
                console.error('Auto-save failed:', result.message);
            }
        } catch (error) {
            console.error('An error occurred during auto-save:', error);
        }
    }

    // --- 5. Create debounced version of the save function ---
    const debouncedSaveAndUploadPdf = debounce(saveAndUploadPdf, 5000); // 5 seconds

    // --- 6. Listen for annotation events to trigger the debounced auto-save ---
    // 'annotationeditorstateschanged' is a robust event for this purpose [16]
    PDFViewerApplication.eventBus.on('annotationeditorstateschanged', (evt) => {
        if (evt.details.isEditing) {
            console.log('Annotation change detected, triggering debounced auto-save.');
            debouncedSaveAndUploadPdf();
        }
    });

    console.log(`Auto-save script initialized for paper_id: ${paperId}.`);
});
```

```html
# static\pdfjs\web\viewer.html
<!DOCTYPE html>
<!--
Copyright 2012 Mozilla Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Adobe CMap resources are covered by their own copyright but the same license:

    Copyright 1990-2015 Adobe Systems Incorporated.

See https://github.com/adobe-type-tools/cmap-resources
-->
<html dir="ltr" mozdisallowselectionprint>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google" content="notranslate">
  <title>ResearchPara PDF Annotator</title>

  <!-- This snippet is used in production (included from viewer.html) -->
  <link rel="resource" type="application/l10n" href="locale/locale.json">
  <script src="../build/pdf.mjs" type="module"></script>

  <link rel="stylesheet" href="viewer.css">
  <link rel="stylesheet" href="viewer_mods.css">

  <script src="viewer.mjs" type="module"></script>
</head>

<body tabindex="0">
  <div id="outerContainer">
    <span id="viewer-alert" class="visuallyHidden" role="alert"></span>

    <div id="sidebarContainer">
      <div id="toolbarSidebar" class="toolbarHorizontalGroup">
        <div id="toolbarSidebarLeft">
          <div id="sidebarViewButtons" class="toolbarHorizontalGroup toggled" role="radiogroup">
            <button id="viewThumbnail" class="toolbarButton toggled" type="button" tabindex="0"
              data-l10n-id="pdfjs-thumbs-button" role="radio" aria-checked="true" aria-controls="thumbnailView">
              <span data-l10n-id="pdfjs-thumbs-button-label"></span>
            </button>
            <button id="viewOutline" class="toolbarButton" type="button" tabindex="0"
              data-l10n-id="pdfjs-document-outline-button" role="radio" aria-checked="false"
              aria-controls="outlineView">
              <span data-l10n-id="pdfjs-document-outline-button-label"></span>
            </button>
            <button id="viewAttachments" class="toolbarButton" type="button" tabindex="0"
              data-l10n-id="pdfjs-attachments-button" role="radio" aria-checked="false" aria-controls="attachmentsView">
              <span data-l10n-id="pdfjs-attachments-button-label"></span>
            </button>
            <button id="viewLayers" class="toolbarButton" type="button" tabindex="0" data-l10n-id="pdfjs-layers-button"
              role="radio" aria-checked="false" aria-controls="layersView">
              <span data-l10n-id="pdfjs-layers-button-label"></span>
            </button>
          </div>
        </div>

        <div id="toolbarSidebarRight">
          <div id="outlineOptionsContainer" class="toolbarHorizontalGroup">
            <div class="verticalToolbarSeparator"></div>

            <button id="currentOutlineItem" class="toolbarButton" type="button" disabled="disabled" tabindex="0"
              data-l10n-id="pdfjs-current-outline-item-button">
              <span data-l10n-id="pdfjs-current-outline-item-button-label"></span>
            </button>
          </div>
        </div>
      </div>
      <div id="sidebarContent">
        <div id="thumbnailView">
        </div>
        <div id="outlineView" class="hidden">
        </div>
        <div id="attachmentsView" class="hidden">
        </div>
        <div id="layersView" class="hidden">
        </div>
      </div>
      <div id="sidebarResizer"></div>
    </div> <!-- sidebarContainer -->

    <div id="mainContainer">
      <div class="toolbar">
        <div id="toolbarContainer">
          <div id="toolbarViewer" class="toolbarHorizontalGroup">
            <div id="toolbarViewerLeft" class="toolbarHorizontalGroup">
              <button id="sidebarToggleButton" class="toolbarButton" type="button" tabindex="0"
                data-l10n-id="pdfjs-toggle-sidebar-button" aria-expanded="false" aria-haspopup="true"
                aria-controls="sidebarContainer">
                <span data-l10n-id="pdfjs-toggle-sidebar-button-label"></span>
              </button>
              <div class="toolbarButtonSpacer"></div>

              <div class="toolbarHorizontalGroup">
                <span class="loadingInput start toolbarHorizontalGroup">
                  <input type="number" id="pageNumber" class="toolbarField" value="1" min="1" tabindex="0"
                    data-l10n-id="pdfjs-page-input" autocomplete="off">
                </span>
                <span id="numPages" class="toolbarLabel"></span>
              </div>

              <div class="toolbarHorizontalGroup hiddenSmallView">
                <button class="toolbarButton" type="button" id="previous" tabindex="0"
                  data-l10n-id="pdfjs-previous-button">
                  <span data-l10n-id="pdfjs-previous-button-label"></span>
                </button>
                <!-- <div class="splitToolbarButtonSeparator"></div> -->
                <button class="toolbarButton" type="button" id="next" tabindex="0" data-l10n-id="pdfjs-next-button">
                  <span data-l10n-id="pdfjs-next-button-label"></span>
                </button>
              </div>


              
              <div class="toolbarButtonSpacer"></div>



              <span id="scaleSelectContainer" class="dropdownToolbarButton">
                <select id="scaleSelect" tabindex="0" data-l10n-id="pdfjs-zoom-select">
                  <option id="pageAutoOption" value="auto" selected="selected" data-l10n-id="pdfjs-page-scale-auto">
                  </option>
                  <option id="pageActualOption" value="page-actual" data-l10n-id="pdfjs-page-scale-actual"></option>
                  <option id="pageFitOption" value="page-fit" data-l10n-id="pdfjs-page-scale-fit"></option>
                  <option id="pageWidthOption" value="page-width" data-l10n-id="pdfjs-page-scale-width"></option>
                  <option id="customScaleOption" value="custom" disabled="disabled" hidden="true"
                    data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 0 }'></option>
                  <option value="0.5" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 50 }'></option>
                  <option value="0.75" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 75 }'>
                  </option>
                  <option value="1" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 100 }'></option>
                  <option value="1.25" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 125 }'>
                  </option>
                  <option value="1.5" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 150 }'>
                  </option>
                  <option value="2" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 200 }'></option>
                  <option value="3" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 300 }'></option>
                  <option value="4" data-l10n-id="pdfjs-page-scale-percent" data-l10n-args='{ "scale": 400 }'></option>
                </select>
              </span>
              
              <div class="toolbarHorizontalGroup">
                <button id="zoomOutButton" class="toolbarButton" type="button" tabindex="0"
                  data-l10n-id="pdfjs-zoom-out-button">
                  <span data-l10n-id="pdfjs-zoom-out-button-label"></span>
                </button>
                <!-- <div class="splitToolbarButtonSeparator"></div> -->
                <button id="zoomInButton" class="toolbarButton" type="button" tabindex="0"
                  data-l10n-id="pdfjs-zoom-in-button">
                  <span data-l10n-id="pdfjs-zoom-in-button-label"></span>
                </button>
              </div>

              <div class="toolbarButtonSpacer"></div>

              <div class="toolbarButtonWithContainer">
                <button id="viewFindButton" class="toolbarButton" type="button" tabindex="0"
                  data-l10n-id="pdfjs-findbar-button" aria-expanded="false" aria-controls="findbar">
                  <span data-l10n-id="pdfjs-findbar-button-label"></span>
                </button>
                <div class="hidden doorHanger toolbarHorizontalGroup" id="findbar">
                  <div id="findInputContainer" class="toolbarHorizontalGroup">
                    <span class="loadingInput end toolbarHorizontalGroup">
                      <input id="findInput" class="toolbarField" tabindex="0" data-l10n-id="pdfjs-find-input"
                        aria-invalid="false">
                    </span>
                    <div class="toolbarHorizontalGroup">
                      <button id="findPreviousButton" class="toolbarButton" type="button" tabindex="0"
                        data-l10n-id="pdfjs-find-previous-button">
                        <span data-l10n-id="pdfjs-find-previous-button-label"></span>
                      </button>
                      <!-- <div class="splitToolbarButtonSeparator"></div> -->
                      <button id="findNextButton" class="toolbarButton" type="button" tabindex="0"
                        data-l10n-id="pdfjs-find-next-button">
                        <span data-l10n-id="pdfjs-find-next-button-label"></span>
                      </button>
                    </div>
                  </div>
                  <div id="findbarOptionsOneContainer" class="toolbarHorizontalGroup">
                    <div class="toggleButton toolbarLabel">
                      <input type="checkbox" id="findHighlightAll" tabindex="0" />
                      <label for="findHighlightAll" data-l10n-id="pdfjs-find-highlight-checkbox"></label>
                    </div>
                    <div class="toggleButton toolbarLabel">
                      <input type="checkbox" id="findMatchCase" tabindex="0" />
                      <label for="findMatchCase" data-l10n-id="pdfjs-find-match-case-checkbox-label"></label>
                    </div>
                  </div>
                  <div id="findbarOptionsTwoContainer" class="toolbarHorizontalGroup">
                    <div class="toggleButton toolbarLabel">
                      <input type="checkbox" id="findMatchDiacritics" tabindex="0" />
                      <label for="findMatchDiacritics"
                        data-l10n-id="pdfjs-find-match-diacritics-checkbox-label"></label>
                    </div>
                    <div class="toggleButton toolbarLabel">
                      <input type="checkbox" id="findEntireWord" tabindex="0" />
                      <label for="findEntireWord" data-l10n-id="pdfjs-find-entire-word-checkbox-label"></label>
                    </div>
                  </div>

                  <div id="findbarMessageContainer" class="toolbarHorizontalGroup" aria-live="polite">
                    <span id="findResultsCount" class="toolbarLabel"></span>
                    <span id="findMsg" class="toolbarLabel"></span>
                  </div>
                </div> <!-- findbar -->
              </div>
            </div>
            <div id="toolbarViewerMiddle" class="toolbarHorizontalGroup">
            </div>
            <div id="toolbarViewerRight" class="toolbarHorizontalGroup">
              <div class="header-branding"><span>Research</span><span style="font-weight: 600; color: var(--primary-ui-color);">Para</span> <span style="color:rgb(70, 55, 51)">Annotator</span></div>
              <div class="toolbarButtonSpacer"></div>
              <div id="editorModeButtons" class="toolbarHorizontalGroup" role="radiogroup">
                <div id="editorComment" class="toolbarButtonWithContainer" hidden="true">
                  <button id="editorCommentButton" class="toolbarButton" type="button" tabindex="0" disabled="disabled"
                    role="radio" aria-expanded="false" aria-haspopup="true" aria-controls="editorCommentParamsToolbar"
                    data-l10n-id="pdfjs-editor-comment-button">
                    <span data-l10n-id="pdfjs-editor-comment-button-label"></span>
                  </button>
                  <div class="editorParamsToolbar sidebar hidden menu" id="editorCommentParamsToolbar">
                    <div id="editorCommentsSidebar" class="menuContainer" role="landmark"
                      aria-labelledby="editorCommentsSidebarHeader">
                      <div id="editorCommentsSidebarHeader" role="heading" aria-level="2">
                        <span class="commentCount">
                          <span id="editorCommentsSidebarTitle" data-l10n-id="pdfjs-editor-comments-sidebar-title"
                            data-l10n-args='{ "count": 0 }'></span>
                          <span id="editorCommentsSidebarCount"></span>
                        </span>
                        <button id="editorCommentsSidebarCloseButton" type="button" tabindex="0"
                          data-l10n-id="pdfjs-editor-comments-sidebar-close-button">
                          <span data-l10n-id="pdfjs-editor-comments-sidebar-close-button-label"></span>
                        </button>
                      </div>
                      <ul id="editorCommentsSidebarList"></ul>
                    </div>
                  </div>
                </div>
                <div id="editorSignature" class="toolbarButtonWithContainer" hidden="true">
                  <button id="editorSignatureButton" class="toolbarButton" type="button" tabindex="0"
                    disabled="disabled" role="radio" aria-expanded="false" aria-haspopup="true"
                    aria-controls="editorSignatureParamsToolbar" data-l10n-id="pdfjs-editor-signature-button">
                    <span data-l10n-id="pdfjs-editor-signature-button-label"></span>
                  </button>
                  <div class="editorParamsToolbar hidden doorHangerRight menu" id="editorSignatureParamsToolbar">
                    <div id="addSignatureDoorHanger" class="menuContainer" role="region"
                      data-l10n-id="pdfjs-editor-add-signature-container">
                      <button id="editorSignatureAddSignature" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-editor-signature-add-signature-button">
                        <span data-l10n-id="pdfjs-editor-signature-add-signature-button-label"
                          class="editorParamsLabel"></span>
                      </button>
                    </div>
                  </div>
                </div>
                <div id="editorHighlight" class="toolbarButtonWithContainer">
                  <button id="editorHighlightButton" class="toolbarButton toggled" type="button" disabled="disabled"
                    role="radio" aria-expanded="false" aria-haspopup="true" aria-controls="editorHighlightParamsToolbar"
                    tabindex="0" data-l10n-id="pdfjs-editor-highlight-button">
                    <span data-l10n-id="pdfjs-editor-highlight-button-label"></span>
                  </button>
                  <div class="editorParamsToolbar hidden doorHangerRight" id="editorHighlightParamsToolbar">
                    <div id="highlightParamsToolbarContainer" class="editorParamsToolbarContainer">
                      <div id="editorHighlightColorPicker" class="colorPicker">
                        <span id="highlightColorPickerLabel" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-highlight-colorpicker-label"></span>
                      </div>
                      <div id="editorHighlightThickness">
                        <label for="editorFreeHighlightThickness" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-free-highlight-thickness-input"></label>
                        <div class="thicknessPicker">
                          <input type="range" id="editorFreeHighlightThickness" class="editorParamsSlider"
                            data-l10n-id="pdfjs-editor-free-highlight-thickness-title" value="12" min="8" max="24"
                            step="1" tabindex="0">
                        </div>
                      </div>
                      <div id="editorHighlightVisibility">
                        <div class="divider"></div>
                        <div class="toggler">
                          <label for="editorHighlightShowAll" class="editorParamsLabel"
                            data-l10n-id="pdfjs-editor-highlight-show-all-button-label"></label>
                          <button id="editorHighlightShowAll" class="toggle-button" type="button"
                            data-l10n-id="pdfjs-editor-highlight-show-all-button" aria-pressed="true"
                            tabindex="0"></button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div id="editorFreeText" class="toolbarButtonWithContainer">
                  <button id="editorFreeTextButton" class="toolbarButton" type="button" disabled="disabled" role="radio"
                    aria-expanded="false" aria-haspopup="true" aria-controls="editorFreeTextParamsToolbar" tabindex="0"
                    data-l10n-id="pdfjs-editor-free-text-button">
                    <span data-l10n-id="pdfjs-editor-free-text-button-label"></span>
                  </button>
                  <div class="editorParamsToolbar hidden doorHangerRight" id="editorFreeTextParamsToolbar">
                    <div class="editorParamsToolbarContainer">
                      <div class="editorParamsSetter">
                        <label for="editorFreeTextColor" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-free-text-color-input"></label>
                        <input type="color" id="editorFreeTextColor" class="editorParamsColor" tabindex="0">
                      </div>
                      <div class="editorParamsSetter">
                        <label for="editorFreeTextFontSize" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-free-text-size-input"></label>
                        <input type="range" id="editorFreeTextFontSize" class="editorParamsSlider" value="10" min="5"
                          max="100" step="1" tabindex="0">
                      </div>
                    </div>
                  </div>
                </div>
                <div id="editorInk" class="toolbarButtonWithContainer">
                  <button id="editorInkButton" class="toolbarButton" type="button" disabled="disabled" role="radio"
                    aria-expanded="false" aria-haspopup="true" aria-controls="editorInkParamsToolbar" tabindex="0"
                    data-l10n-id="pdfjs-editor-ink-button">
                    <span data-l10n-id="pdfjs-editor-ink-button-label"></span>
                  </button>
                  <div class="editorParamsToolbar hidden doorHangerRight" id="editorInkParamsToolbar">
                    <div class="editorParamsToolbarContainer">
                      <div class="editorParamsSetter">
                        <label for="editorInkColor" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-ink-color-input"></label>
                        <input type="color" id="editorInkColor" class="editorParamsColor" tabindex="0">
                      </div>
                      <div class="editorParamsSetter">
                        <label for="editorInkThickness" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-ink-thickness-input"></label>
                        <input type="range" id="editorInkThickness" class="editorParamsSlider" value="1" min="1"
                          max="20" step="1" tabindex="0">
                      </div>
                      <div class="editorParamsSetter">
                        <label for="editorInkOpacity" class="editorParamsLabel"
                          data-l10n-id="pdfjs-editor-ink-opacity-input"></label>
                        <input type="range" id="editorInkOpacity" class="editorParamsSlider" value="1" min="0.05"
                          max="1" step="0.05" tabindex="0">
                      </div>
                    </div>
                  </div>
                </div>
                <div id="editorStamp" class="toolbarButtonWithContainer"  style="display:none">
                  <button id="editorStampButton" class="toolbarButton" type="button" disabled="disabled" role="radio"
                    aria-expanded="false" aria-haspopup="true" aria-controls="editorStampParamsToolbar" tabindex="0"
                    data-l10n-id="pdfjs-editor-stamp-button">
                    <span data-l10n-id="pdfjs-editor-stamp-button-label"></span>
                  </button>
                  <div class="editorParamsToolbar hidden doorHangerRight menu" id="editorStampParamsToolbar">
                    <div class="menuContainer">
                      <button id="editorStampAddImage" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-editor-stamp-add-image-button">
                        <span class="editorParamsLabel" data-l10n-id="pdfjs-editor-stamp-add-image-button-label"></span>
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <div id="editorModeSeparator" class="verticalToolbarSeparator" style="display:none"></div>

              <div class="toolbarHorizontalGroup hiddenMediumView">

              </div>

              <!-- <div class="verticalToolbarSeparator hiddenMediumView"></div> -->
                             <div class="toolbarButtonSpacer"></div>


              <div id="secondaryToolbarToggle" class="toolbarButtonWithContainer">
                <button id="secondaryToolbarToggleButton" class="toolbarButton" type="button" tabindex="0"
                  data-l10n-id="pdfjs-tools-button" aria-expanded="false" aria-haspopup="true"
                  aria-controls="secondaryToolbar">
                  <span data-l10n-id="pdfjs-tools-button-label"></span>
                </button>
                <div id="secondaryToolbar" class="hidden doorHangerRight menu">
                  <div id="secondaryToolbarButtonContainer" class="menuContainer">
                    <button id="secondaryOpenFile" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-open-file-button" style="display:none">
                      <span data-l10n-id="pdfjs-open-file-button-label"></span>
                    </button>

                    <div class="visibleMediumView" >
                      <button id="secondaryPrint" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-print-button">
                        <span data-l10n-id="pdfjs-print-button-label"></span>
                      </button>

                      <button id="secondaryDownload" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-save-button">
                        <span data-l10n-id="pdfjs-save-button-label"></span>
                      </button>

                    </div>
                    <button id="downloadButton" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-save-button">
                      <span data-l10n-id="pdfjs-save-button-label"></span>
                    </button>

                    <button id="printButton" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-print-button">
                      <span data-l10n-id="pdfjs-print-button-label"></span>
                    </button>

                    <div class="horizontalToolbarSeparator"></div>
                    
                    <button id="presentationMode" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-presentation-mode-button">
                      <span data-l10n-id="pdfjs-presentation-mode-button-label"></span>
                    </button>

                    <a href="#" id="viewBookmark" class="toolbarButton labeled" tabindex="0"
                      data-l10n-id="pdfjs-bookmark-button">
                      <span data-l10n-id="pdfjs-bookmark-button-label"></span>
                    </a>

                    <div id="viewBookmarkSeparator" class="horizontalToolbarSeparator"></div>

                    <button id="firstPage" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-first-page-button">
                      <span data-l10n-id="pdfjs-first-page-button-label"></span>
                    </button>
                    <button id="lastPage" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-last-page-button">
                      <span data-l10n-id="pdfjs-last-page-button-label"></span>
                    </button>

                    <div class="horizontalToolbarSeparator"></div>

                    <button id="pageRotateCw" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-page-rotate-cw-button">
                      <span data-l10n-id="pdfjs-page-rotate-cw-button-label"></span>
                    </button>
                    <button id="pageRotateCcw" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-page-rotate-ccw-button">
                      <span data-l10n-id="pdfjs-page-rotate-ccw-button-label"></span>
                    </button>

                    <div class="horizontalToolbarSeparator"></div>

                    <div id="cursorToolButtons" role="radiogroup">
                      <button id="cursorSelectTool" class="toolbarButton labeled toggled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-cursor-text-select-tool-button" role="radio" aria-checked="true">
                        <span data-l10n-id="pdfjs-cursor-text-select-tool-button-label"></span>
                      </button>
                      <button id="cursorHandTool" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-cursor-hand-tool-button" role="radio" aria-checked="false">
                        <span data-l10n-id="pdfjs-cursor-hand-tool-button-label"></span>
                      </button>
                    </div>

                    <div class="horizontalToolbarSeparator"></div>

                    <div id="scrollModeButtons" role="radiogroup">
                      <button id="scrollPage" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-scroll-page-button" role="radio" aria-checked="false">
                        <span data-l10n-id="pdfjs-scroll-page-button-label"></span>
                      </button>
                      <button id="scrollVertical" class="toolbarButton labeled toggled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-scroll-vertical-button" role="radio" aria-checked="true">
                        <span data-l10n-id="pdfjs-scroll-vertical-button-label"></span>
                      </button>
                      <button id="scrollHorizontal" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-scroll-horizontal-button" role="radio" aria-checked="false">
                        <span data-l10n-id="pdfjs-scroll-horizontal-button-label"></span>
                      </button>
                      <button id="scrollWrapped" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-scroll-wrapped-button" role="radio" aria-checked="false">
                        <span data-l10n-id="pdfjs-scroll-wrapped-button-label"></span>
                      </button>
                    </div>

                    <div class="horizontalToolbarSeparator"></div>

                    <div id="spreadModeButtons" role="radiogroup">
                      <button id="spreadNone" class="toolbarButton labeled toggled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-spread-none-button" role="radio" aria-checked="true">
                        <span data-l10n-id="pdfjs-spread-none-button-label"></span>
                      </button>
                      <button id="spreadOdd" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-spread-odd-button" role="radio" aria-checked="false">
                        <span data-l10n-id="pdfjs-spread-odd-button-label"></span>
                      </button>
                      <button id="spreadEven" class="toolbarButton labeled" type="button" tabindex="0"
                        data-l10n-id="pdfjs-spread-even-button" role="radio" aria-checked="false">
                        <span data-l10n-id="pdfjs-spread-even-button-label"></span>
                      </button>
                    </div>

                    <div id="imageAltTextSettingsSeparator" class="horizontalToolbarSeparator hidden"></div>
                    <button id="imageAltTextSettings" type="button" class="toolbarButton labeled hidden" tabindex="0"
                      data-l10n-id="pdfjs-image-alt-text-settings-button" aria-controls="altTextSettingsDialog">
                      <span data-l10n-id="pdfjs-image-alt-text-settings-button-label"></span>
                    </button>

                    <div class="horizontalToolbarSeparator"></div>

                    <button id="documentProperties" class="toolbarButton labeled" type="button" tabindex="0"
                      data-l10n-id="pdfjs-document-properties-button" aria-controls="documentPropertiesDialog">
                      <span data-l10n-id="pdfjs-document-properties-button-label"></span>
                    </button>
                  </div>
                </div> <!-- secondaryToolbar -->
              </div>
            </div>
          </div>
          <div id="loadingBar">
            <div class="progress">
              <div class="glimmer">
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="viewerContainer" tabindex="0">
        <div id="viewer" class="pdfViewer"></div>
      </div>
    </div> <!-- mainContainer -->

    <div id="dialogContainer">
      <dialog id="passwordDialog">
        <div class="row">
          <label for="password" id="passwordText" data-l10n-id="pdfjs-password-label"></label>
        </div>
        <div class="row">
          <input type="password" id="password" class="toolbarField">
        </div>
        <div class="buttonRow">
          <button id="passwordCancel" class="dialogButton" type="button"><span
              data-l10n-id="pdfjs-password-cancel-button"></span></button>
          <button id="passwordSubmit" class="dialogButton" type="button"><span
              data-l10n-id="pdfjs-password-ok-button"></span></button>
        </div>
      </dialog>
      <dialog id="documentPropertiesDialog">
        <div class="row">
          <span id="fileNameLabel" data-l10n-id="pdfjs-document-properties-file-name"></span>
          <p id="fileNameField" aria-labelledby="fileNameLabel">-</p>
        </div>
        <div class="row">
          <span id="fileSizeLabel" data-l10n-id="pdfjs-document-properties-file-size"></span>
          <p id="fileSizeField" aria-labelledby="fileSizeLabel">-</p>
        </div>
        <div class="separator"></div>
        <div class="row">
          <span id="titleLabel" data-l10n-id="pdfjs-document-properties-title"></span>
          <p id="titleField" aria-labelledby="titleLabel">-</p>
        </div>
        <div class="row">
          <span id="authorLabel" data-l10n-id="pdfjs-document-properties-author"></span>
          <p id="authorField" aria-labelledby="authorLabel">-</p>
        </div>
        <div class="row">
          <span id="subjectLabel" data-l10n-id="pdfjs-document-properties-subject"></span>
          <p id="subjectField" aria-labelledby="subjectLabel">-</p>
        </div>
        <div class="row">
          <span id="keywordsLabel" data-l10n-id="pdfjs-document-properties-keywords"></span>
          <p id="keywordsField" aria-labelledby="keywordsLabel">-</p>
        </div>
        <div class="row">
          <span id="creationDateLabel" data-l10n-id="pdfjs-document-properties-creation-date"></span>
          <p id="creationDateField" aria-labelledby="creationDateLabel">-</p>
        </div>
        <div class="row">
          <span id="modificationDateLabel" data-l10n-id="pdfjs-document-properties-modification-date"></span>
          <p id="modificationDateField" aria-labelledby="modificationDateLabel">-</p>
        </div>
        <div class="row">
          <span id="creatorLabel" data-l10n-id="pdfjs-document-properties-creator"></span>
          <p id="creatorField" aria-labelledby="creatorLabel">-</p>
        </div>
        <div class="separator"></div>
        <div class="row">
          <span id="producerLabel" data-l10n-id="pdfjs-document-properties-producer"></span>
          <p id="producerField" aria-labelledby="producerLabel">-</p>
        </div>
        <div class="row">
          <span id="versionLabel" data-l10n-id="pdfjs-document-properties-version"></span>
          <p id="versionField" aria-labelledby="versionLabel">-</p>
        </div>
        <div class="row">
          <span id="pageCountLabel" data-l10n-id="pdfjs-document-properties-page-count"></span>
          <p id="pageCountField" aria-labelledby="pageCountLabel">-</p>
        </div>
        <div class="row">
          <span id="pageSizeLabel" data-l10n-id="pdfjs-document-properties-page-size"></span>
          <p id="pageSizeField" aria-labelledby="pageSizeLabel">-</p>
        </div>
        <div class="separator"></div>
        <div class="row">
          <span id="linearizedLabel" data-l10n-id="pdfjs-document-properties-linearized"></span>
          <p id="linearizedField" aria-labelledby="linearizedLabel">-</p>
        </div>
        <div class="buttonRow">
          <button id="documentPropertiesClose" class="dialogButton" type="button"><span
              data-l10n-id="pdfjs-document-properties-close-button"></span></button>
        </div>
      </dialog>
      <dialog class="dialog altText" id="altTextDialog" aria-labelledby="dialogLabel"
        aria-describedby="dialogDescription">
        <div id="altTextContainer" class="mainContainer">
          <div id="overallDescription">
            <span id="dialogLabel" data-l10n-id="pdfjs-editor-alt-text-dialog-label" class="title"></span>
            <span id="dialogDescription" data-l10n-id="pdfjs-editor-alt-text-dialog-description"></span>
          </div>
          <div id="addDescription">
            <div class="radio">
              <div class="radioButton">
                <input type="radio" id="descriptionButton" name="altTextOption" tabindex="0"
                  aria-describedby="descriptionAreaLabel" checked>
                <label for="descriptionButton" data-l10n-id="pdfjs-editor-alt-text-add-description-label"></label>
              </div>
              <div class="radioLabel">
                <span id="descriptionAreaLabel" data-l10n-id="pdfjs-editor-alt-text-add-description-description"></span>
              </div>
            </div>
            <div class="descriptionArea">
              <textarea id="descriptionTextarea" aria-labelledby="descriptionAreaLabel"
                data-l10n-id="pdfjs-editor-alt-text-textarea" tabindex="0"></textarea>
            </div>
          </div>
          <div id="markAsDecorative">
            <div class="radio">
              <div class="radioButton">
                <input type="radio" id="decorativeButton" name="altTextOption" aria-describedby="decorativeLabel">
                <label for="decorativeButton" data-l10n-id="pdfjs-editor-alt-text-mark-decorative-label"></label>
              </div>
              <div class="radioLabel">
                <span id="decorativeLabel" data-l10n-id="pdfjs-editor-alt-text-mark-decorative-description"></span>
              </div>
            </div>
          </div>
          <div id="buttons">
            <button id="altTextCancel" class="secondaryButton" type="button" tabindex="0"><span
                data-l10n-id="pdfjs-editor-alt-text-cancel-button"></span></button>
            <button id="altTextSave" class="primaryButton" type="button" tabindex="0"><span
                data-l10n-id="pdfjs-editor-alt-text-save-button"></span></button>
          </div>
        </div>
      </dialog>
      <dialog class="dialog newAltText" id="newAltTextDialog" aria-labelledby="newAltTextTitle"
        aria-describedby="newAltTextDescription" tabindex="0">
        <div id="newAltTextContainer" class="mainContainer">
          <div class="title">
            <span id="newAltTextTitle" data-l10n-id="pdfjs-editor-new-alt-text-dialog-edit-label" role="sectionhead"
              tabindex="0"></span>
          </div>
          <div id="mainContent">
            <div id="descriptionAndSettings">
              <div id="descriptionInstruction">
                <div id="newAltTextDescriptionContainer">
                  <div class="altTextSpinner" role="status" aria-live="polite"></div>
                  <textarea id="newAltTextDescriptionTextarea" aria-labelledby="descriptionAreaLabel"
                    data-l10n-id="pdfjs-editor-new-alt-text-textarea" tabindex="0"></textarea>
                </div>
                <span id="newAltTextDescription" role="note"
                  data-l10n-id="pdfjs-editor-new-alt-text-description"></span>
                <div id="newAltTextDisclaimer" role="note">
                  <div><span data-l10n-id="pdfjs-editor-new-alt-text-disclaimer1"></span> <a
                      href="https://support.mozilla.org/en-US/kb/pdf-alt-text" target="_blank" rel="noopener noreferrer"
                      id="newAltTextLearnMore" data-l10n-id="pdfjs-editor-new-alt-text-disclaimer-learn-more-url"
                      tabindex="0"></a></div>
                </div>
              </div>
              <div id="newAltTextCreateAutomatically" class="toggler">
                <button id="newAltTextCreateAutomaticallyButton" class="toggle-button" type="button" aria-pressed="true"
                  tabindex="0"></button>
                <label for="newAltTextCreateAutomaticallyButton" class="togglerLabel"
                  data-l10n-id="pdfjs-editor-new-alt-text-create-automatically-button-label"></label>
              </div>
              <div id="newAltTextDownloadModel" class="hidden">
                <span id="newAltTextDownloadModelDescription"
                  data-l10n-id="pdfjs-editor-new-alt-text-ai-model-downloading-progress" aria-valuemin="0"
                  data-l10n-args='{ "totalSize": 0, "downloadedSize": 0 }'></span>
              </div>
            </div>
            <div id="newAltTextImagePreview"></div>
          </div>
          <div id="newAltTextError" class="messageBar">
            <div>
              <div>
                <span class="title" data-l10n-id="pdfjs-editor-new-alt-text-error-title"></span>
                <span class="description" data-l10n-id="pdfjs-editor-new-alt-text-error-description"></span>
              </div>
              <button id="newAltTextCloseButton" class="closeButton" type="button" tabindex="0"><span
                  data-l10n-id="pdfjs-editor-new-alt-text-error-close-button"></span></button>
            </div>
          </div>
          <div id="newAltTextButtons" class="dialogButtonsGroup">
            <button id="newAltTextCancel" type="button" class="secondaryButton hidden" tabindex="0"><span
                data-l10n-id="pdfjs-editor-alt-text-cancel-button"></span></button>
            <button id="newAltTextNotNow" type="button" class="secondaryButton" tabindex="0"><span
                data-l10n-id="pdfjs-editor-new-alt-text-not-now-button"></span></button>
            <button id="newAltTextSave" type="button" class="primaryButton" tabindex="0"><span
                data-l10n-id="pdfjs-editor-alt-text-save-button"></span></button>
          </div>
        </div>
      </dialog>

      <dialog class="dialog" id="altTextSettingsDialog" aria-labelledby="altTextSettingsTitle">
        <div id="altTextSettingsContainer" class="mainContainer">
          <div class="title">
            <span id="altTextSettingsTitle" data-l10n-id="pdfjs-editor-alt-text-settings-dialog-label"
              role="sectionhead" tabindex="0" class="title"></span>
          </div>
          <div id="automaticAltText">
            <span data-l10n-id="pdfjs-editor-alt-text-settings-automatic-title"></span>
            <div id="automaticSettings">
              <div id="createModelSetting">
                <div class="toggler">
                  <button id="createModelButton" type="button" class="toggle-button" aria-pressed="true"
                    tabindex="0"></button>
                  <label for="createModelButton" class="togglerLabel"
                    data-l10n-id="pdfjs-editor-alt-text-settings-create-model-button-label"></label>
                </div>
                <div id="createModelDescription" class="description">
                  <span data-l10n-id="pdfjs-editor-alt-text-settings-create-model-description"></span> <a
                    href="https://support.mozilla.org/en-US/kb/pdf-alt-text" target="_blank" rel="noopener noreferrer"
                    id="altTextSettingsLearnMore" data-l10n-id="pdfjs-editor-new-alt-text-disclaimer-learn-more-url"
                    tabindex="0"></a>
                </div>
              </div>
              <div id="aiModelSettings">
                <div>
                  <span data-l10n-id="pdfjs-editor-alt-text-settings-download-model-label"
                    data-l10n-args='{ "totalSize": 180 }'></span>
                  <div id="aiModelDescription" class="description">
                    <span data-l10n-id="pdfjs-editor-alt-text-settings-ai-model-description"></span>
                  </div>
                </div>
                <button id="deleteModelButton" type="button" class="secondaryButton" tabindex="0"><span
                    data-l10n-id="pdfjs-editor-alt-text-settings-delete-model-button"></span></button>
                <button id="downloadModelButton" type="button" class="secondaryButton" tabindex="0"><span
                    data-l10n-id="pdfjs-editor-alt-text-settings-download-model-button"></span></button>
              </div>
            </div>
          </div>
          <div class="dialogSeparator"></div>
          <div id="altTextEditor">
            <span data-l10n-id="pdfjs-editor-alt-text-settings-editor-title"></span>
            <div id="showAltTextEditor">
              <div class="toggler">
                <button id="showAltTextDialogButton" type="button" class="toggle-button" aria-pressed="true"
                  tabindex="0"></button>
                <label for="showAltTextDialogButton" class="togglerLabel"
                  data-l10n-id="pdfjs-editor-alt-text-settings-show-dialog-button-label"></label>
              </div>
              <div id="showAltTextDialogDescription" class="description">
                <span data-l10n-id="pdfjs-editor-alt-text-settings-show-dialog-description"></span>
              </div>
            </div>
          </div>
          <div id="buttons" class="dialogButtonsGroup">
            <button id="altTextSettingsCloseButton" type="button" class="primaryButton" tabindex="0"><span
                data-l10n-id="pdfjs-editor-alt-text-settings-close-button"></span></button>
          </div>
        </div>
      </dialog>

      <dialog class="dialog signatureDialog" id="addSignatureDialog" aria-labelledby="addSignatureDialogLabel">
        <span id="addSignatureDialogLabel" data-l10n-id="pdfjs-editor-add-signature-dialog-label"></span>
        <div id="addSignatureContainer" class="mainContainer">
          <div class="title">
            <span role="sectionhead" data-l10n-id="pdfjs-editor-add-signature-dialog-title" tabindex="0"></span>
          </div>
          <div role="tablist" id="addSignatureOptions">
            <button id="addSignatureTypeButton" type="button" role="tab" aria-selected="true"
              aria-controls="addSignatureTypeContainer" data-l10n-id="pdfjs-editor-add-signature-type-button"
              tabindex="0"></button>
            <button id="addSignatureDrawButton" type="button" role="tab" aria-selected="false"
              aria-controls="addSignatureDrawContainer" data-l10n-id="pdfjs-editor-add-signature-draw-button"
              tabindex="0"></button>
            <button id="addSignatureImageButton" type="button" role="tab" aria-selected="false"
              aria-controls="addSignatureImageContainer" data-l10n-id="pdfjs-editor-add-signature-image-button"
              tabindex="-1"></button>
          </div>
          <div id="addSignatureActionContainer" data-selected="type">
            <div id="addSignatureTypeContainer" role="tabpanel" aria-labelledby="addSignatureTypeContainer">
              <input id="addSignatureTypeInput" type="text" data-l10n-id="pdfjs-editor-add-signature-type-input"
                tabindex="0"></input>
            </div>
            <div id="addSignatureDrawContainer" role="tabpanel" aria-labelledby="addSignatureDrawButton" tabindex="-1">
              <svg id="addSignatureDraw" xmlns="http://www.w3.org/2000/svg"
                aria-labelledby="addSignatureDrawPlaceholder"></svg>
              <span id="addSignatureDrawPlaceholder" data-l10n-id="pdfjs-editor-add-signature-draw-placeholder"></span>
              <div id="thickness">
                <div>
                  <label for="addSignatureDrawThickness"
                    data-l10n-id="pdfjs-editor-add-signature-draw-thickness-range-label"></label>
                  <input type="range" id="addSignatureDrawThickness" min="1" max="5" step="1" value="1"
                    data-l10n-id="pdfjs-editor-add-signature-draw-thickness-range" data-l10n-args='{ "thickness": 1 }'
                    tabindex="0">
                </div>
              </div>
            </div>
            <div id="addSignatureImageContainer" role="tabpanel" aria-labelledby="addSignatureImageButton"
              tabindex="-1">
              <svg id="addSignatureImage" xmlns="http://www.w3.org/2000/svg"
                aria-labelledby="addSignatureImagePlaceholder"></svg>
              <div id="addSignatureImagePlaceholder">
                <span data-l10n-id="pdfjs-editor-add-signature-image-placeholder"></span>
                <label id="addSignatureImageBrowse" for="addSignatureFilePicker" tabindex="0">
                  <a data-l10n-id="pdfjs-editor-add-signature-image-browse-link"></a>
                </label>
                <input id="addSignatureFilePicker" type="file"></input>
              </div>
            </div>
            <div id="addSignatureControls">
              <div id="horizontalContainer">
                <div id="addSignatureDescriptionContainer">
                  <label for="addSignatureDescInput"
                    data-l10n-id="pdfjs-editor-add-signature-description-label"></label>
                  <span id="addSignatureDescription" class="inputWithClearButton">
                    <input id="addSignatureDescInput" type="text"
                      data-l10n-id="pdfjs-editor-add-signature-description-input" tabindex="0"></input>
                    <button class="clearInputButton" type="button" tabindex="0" aria-hidden="true"></button>
                  </span>
                </div>
                <button id="clearSignatureButton" type="button" data-l10n-id="pdfjs-editor-add-signature-clear-button"
                  tabindex="0"><span data-l10n-id="pdfjs-editor-add-signature-clear-button-label"></span></button>
              </div>
              <div id="addSignatureSaveContainer">
                <input type="checkbox" id="addSignatureSaveCheckbox"></input>
                <label for="addSignatureSaveCheckbox" data-l10n-id="pdfjs-editor-add-signature-save-checkbox"></label>
                <span></span>
                <span id="addSignatureSaveWarning"
                  data-l10n-id="pdfjs-editor-add-signature-save-warning-message"></span>
              </div>
            </div>
            <div id="addSignatureError" hidden="true" class="messageBar">
              <div>
                <div>
                  <span id="addSignatureErrorTitle" class="title"
                    data-l10n-id="pdfjs-editor-add-signature-image-upload-error-title"></span>
                  <span id="addSignatureErrorDescription" class="description"
                    data-l10n-id="pdfjs-editor-add-signature-image-upload-error-description"></span>
                </div>
                <button id="addSignatureErrorCloseButton" class="closeButton" type="button" tabindex="0"><span
                    data-l10n-id="pdfjs-editor-add-signature-error-close-button"></span></button>
              </div>
            </div>
            <div class="dialogButtonsGroup">
              <button id="addSignatureCancelButton" type="button" class="secondaryButton" tabindex="0"><span
                  data-l10n-id="pdfjs-editor-add-signature-cancel-button"></span></button>
              <button id="addSignatureAddButton" type="button" class="primaryButton" disabled tabindex="0"><span
                  data-l10n-id="pdfjs-editor-add-signature-add-button"></span></button>
            </div>
          </div>
        </div>
      </dialog>

      <dialog class="dialog signatureDialog" id="editSignatureDescriptionDialog"
        aria-labelledby="editSignatureDescriptionTitle">
        <div id="editSignatureDescriptionContainer" class="mainContainer">
          <div class="title">
            <span id="editSignatureDescriptionTitle" role="sectionhead"
              data-l10n-id="pdfjs-editor-edit-signature-dialog-title" tabindex="0"></span>
          </div>
          <div id="editSignatureDescriptionAndView">
            <div id="editSignatureDescriptionContainer">
              <label for="editSignatureDescInput" data-l10n-id="pdfjs-editor-add-signature-description-label"></label>
              <span id="editSignatureDescription" class="inputWithClearButton">
                <input id="editSignatureDescInput" type="text"
                  data-l10n-id="pdfjs-editor-add-signature-description-input" tabindex="0"></input>
                <button class="clearInputButton" type="button" tabindex="0" aria-hidden="true"></button>
              </span>
            </div>
            <svg id="editSignatureView" xmlns="http://www.w3.org/2000/svg"></svg>
          </div>
          <div class="dialogButtonsGroup">
            <button id="editSignatureCancelButton" type="button" class="secondaryButton" tabindex="0"><span
                data-l10n-id="pdfjs-editor-add-signature-cancel-button"></span></button>
            <button id="editSignatureUpdateButton" type="button" class="primaryButton" disabled tabindex="0"><span
                data-l10n-id="pdfjs-editor-edit-signature-update-button"></span></button>
          </div>
        </div>
      </dialog>

      <dialog class="dialog commentManager" id="commentManagerDialog">
        <div class="mainContainer">
          <div id="commentManagerToolbar">
            <button id="commentActionsButton" class="toolbarButton" type="button" aria-expanded="false"
              aria-haspopup="true" aria-controls="commentActionsMenu" tabindex="0"
              data-l10n-id="pdfjs-editor-edit-comment-actions-button">
              <span data-l10n-id="pdfjs-editor-edit-comment-actions-button-label"></span>
            </button>
            <menu class="hidden" role="menu" id="commentActionsMenu">
              <button id="commentActionsEditButton" role="menuitem" type="button" tabindex="0">
                <span data-l10n-id="pdfjs-editor-edit-comment-actions-edit-button-label"></span>
              </button>
              <button id="commentActionsDeleteButton" role="menuitem" type="button" tabindex="0">
                <span data-l10n-id="pdfjs-editor-edit-comment-actions-delete-button-label"></span>
              </button>
            </menu>
            <button id="commentCloseButton" class="toolbarButton" type="button" tabindex="0"
              data-l10n-id="pdfjs-editor-edit-comment-close-button">
              <span data-l10n-id="pdfjs-editor-edit-comment-close-button-label"></span>
            </button>
          </div>
          <textarea class="hidden" id="commentManagerTextInput"
            data-l10n-id="pdfjs-editor-edit-comment-manager-text-input"></textarea>
          <div class="hidden" id="commentManagerTextView"></div>
          <div class="dialogButtonsGroup">
            <button id="commentManagerCancelButton" type="button" class="secondaryButton" tabindex="0">
              <span data-l10n-id="pdfjs-editor-edit-comment-manager-cancel-button"></span>
            </button>
            <button id="commentManagerSaveButton" type="button" class="primaryButton" disabled tabindex="0">
              <span data-l10n-id="pdfjs-editor-edit-comment-manager-save-button"></span>
            </button>
          </div>
        </div>
      </dialog>

      <dialog id="printServiceDialog" style="min-width: 200px;">
        <div class="row">
          <span data-l10n-id="pdfjs-print-progress-message"></span>
        </div>
        <div class="row">
          <progress value="0" max="100"></progress>
          <span data-l10n-id="pdfjs-print-progress-percent" data-l10n-args='{ "progress": 0 }'
            class="relative-progress">0%</span>
        </div>
        <div class="buttonRow">
          <button id="printCancel" class="dialogButton" type="button"><span
              data-l10n-id="pdfjs-print-progress-close-button"></span></button>
        </div>
      </dialog>
    </div> <!-- dialogContainer -->

    <div id="editorUndoBar" class="messageBar" role="status" aria-labelledby="editorUndoBarMessage" tabindex="-1"
      hidden>
      <div>
        <div>
          <span id="editorUndoBarMessage" class="description"></span>
        </div>
        <button id="editorUndoBarUndoButton" class="undoButton" type="button" tabindex="0"
          data-l10n-id="pdfjs-editor-undo-bar-undo-button">
          <span data-l10n-id="pdfjs-editor-undo-bar-undo-button-label"></span>
        </button>
        <button id="editorUndoBarCloseButton" class="closeButton" type="button" tabindex="0"
          data-l10n-id="pdfjs-editor-undo-bar-close-button">
          <span data-l10n-id="pdfjs-editor-undo-bar-close-button-label"></span>
        </button>
      </div>
    </div> <!-- editorUndoBar -->

  </div> <!-- outerContainer -->
  <div id="printContainer"></div>
  <script src="autosave.js"></script>
</body>

</html>
```

```html
# templates\about_modal_content.html
<!-- templates/stats_modal_content.html -->
<div class="modal-small-section">
    <h3><strong>Quick Help</strong> Guide</h3>
    <p style="margin-bottom: 0"><strong>Understanding the Symbols:</strong></p>
    <ul style="list-style-type: none;  padding-left: 0;  margin: 0; column-count: 2; gap: 0">
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: Confirmed "Yes" (e.g., paper is a Survey, uses SMT, etc.);</p></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: Confirmed "No";</p></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: Unknown / Not Classified / Not Applicable;</p></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: Last changed or verified by the (hopefully human) user;</p></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: Last changed or verified by an AI Model (hover for model name);</p></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: A PDF is attached to this paper;</li></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: An <strong>annotated</strong> PDF is attached to this paper;</li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: The PDF for this paper is <strong>paywalled</strong></li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: This is a <strong>Journal</strong> paper</li>
        <li><p style="margin: 0"><strong style="font-size:1.75em"></strong>: This is a <strong>Conference</strong> paper</li>
    </ul>
    <p><strong>How to Use:</strong></p>
        <p><strong>Filter Papers:</strong> Use the year range, minimum page count, and the search bar at the top. Press "Apply" (appears on change) for server-side filters.</p>
        <p><strong>Checkbox filters:</strong> Use checkboxes like "Hide Offtopic", "Hide X-Ray", or "Only Survey" for quick client-side filtering. As the checkboxes have no permanent labels, hover each checkbox to identify the purpose for each.</p>
        <p><strong>Classify/Verify:</strong> Click the "Classify this paper" or "Verify this paper" button in the detail row to run LLM-based classification on a single paper. Use the top buttons in the "Batch Actions" menu to classify or verify<em>remaining</em>  or <em>all</em> papers.</p>
        <p><strong>Edit Data:</strong> Click on any <strong style="padding-left: 9px; padding-right: 9px; display: inline-block;transform: scale(1.25)">    </strong> symbol in the main table to cycle its value (this is automatically saved on change). Click 'show' in the details column to edit text fields (like "Model Name" or "Other Defects").
            These have to be saved manually by clicking on "Save Changes". <em>Unavailable inside HTML exports.</em></p> 
        <p><strong>Search:</strong> Type on the search bar for instant search on all relevant fields. User comments are searchable. Classifier/Verifier traces are not (to avoid false-positives/noise)</p>
        <p><strong>View Statistics:</strong> Click the "View Statistics" button to see charts and lists of repeating journals, authors, keywords, and mentioned features/models as well as relevant charts. 
            The stats are calculated based on currently visible filtered data.</p>
        <p><strong>Export and Backup:</strong> Use the "Export HTML" or "Export XLSX" buttons inside the "Export & Backup" menu to download the currently filtered dataset, 
            or use the backup / restore buttons to work woith full <em>*.para.zst</em> backups. 
            Backups include the database, original and annotated PDFs, HTML export and a XLSX spreadsheet. <em>Unavailable inside HTML exports.</em>
        </p>
        <p><strong>Import Data:</strong> Use the "Import BibTeX" button to add new papers to the database from a .bib file. <em>Unavailable inside HTML exports.</em></p>
        <p><strong>Attach PDF:</strong> Click on the <strong style="padding-left: 9px; padding-right: 9px; display: inline-block;transform: scale(1.25)"></strong> in the PDF column of a paper to upload a PDF to it. <em>Unavailable inside HTML exports.</em></p>
        <p><strong>Read/Annotate PDF:</strong> Click on the <strong style="padding-left: 9px; padding-right: 9px; display: inline-block;transform: scale(1.25)"></strong> or <strong style="padding-left: 9px; padding-right: 9px; display: inline-block;transform: scale(1.25)"></strong> of an existing PDF to open the integrated PDF.js annotator. 
            All annotations are autosaved after 5 seconds. The annotated status only changes from <strong style="padding-left: 9px; padding-right: 9px; display: inline-block;transform: scale(1.25)"></strong> to <strong style="padding-left: 9px; padding-right: 9px; display: inline-block;transform: scale(1.25)"></strong> after a page reload. This doesn't affect annotation saving.
            For the HTML export, the PDF is loaded directly (read-only) on the user's default reader instead. This requires the PDF to be in the correct folder structure, as obtained from a full backup.</p>
    <p><strong>Tip:</strong> The table is pre-sorted to show papers with user comments first. You can click any column header to sort by that field.</p>
</div>
<div class="modal-small-section" style="background: var(--detail-button-background);">
    <h3><strong>About</strong></h3>
        <div class="header-branding" style="padding: 10px 0 0;  text-align: center;"><span>Research</span><span style="font-weight: 600; color: var(--primary-ui-color);">Para</span></div>
        <p><strong><a href="https://github.com/Zidrewndacht/bibtex-custom-parser" target="_blank" rel="noopener">ReseachPara</a> - PCB Inspection Papers Database Browser.</a></strong></p>
        <p>Developed by <a href="https://zidrewndacht.github.io/" target="_blank" rel="noopener"><strong>Luis Alfredo da Silva</strong></a>, 
            to assist his own Master's degree research at <strong><a href="https://www.udesc.br/cct" target="_blank" rel="noopener">Universidade do Estado de Santa Catarina <strong>(UDESC)</strong></a></strong>. </p>
        <p>The following open source libraries, and its dependencies, are leveraged by this software:</p>
        <p><strong>Backend:</strong> 
            <a href="https://www.python.org/" target="_blank" rel="noopener">Python</a>, 
            <a href="https://flask.palletsprojects.com/" target="_blank" rel="noopener">Flask</a>, 
            <a href="https://www.sqlite.org/" target="_blank" rel="noopener">SQLite3</a>
        </p>
        <p><strong>Frontend:</strong> 
            <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5" target="_blank" rel="noopener">HTML5</a>, 
            <a href="https://developer.mozilla.org/en-US/docs/Web/CSS" target="_blank" rel="noopener">CSS3</a>, 
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noopener">Vanilla JS</a>
        </p>
        <p><strong>Data Visualization:</strong> 
            <a href="https://www.chartjs.org/" target="_blank" rel="noopener">Chart.js</a>
        </p>
        
        <p><strong>PDF View/Annotation/Autosave:</strong> 
            <a href="https://mozilla.github.io/pdf.js/getting_started/" target="_blank" rel="noopener">PDF.js</a>
        </p>
        <p><strong>Utilities:</strong> 
            <a href="https://opensource.perlig.de/rcssmin/" target="_blank" rel="noopener">rcssmin</a>, 
            <a href="https://opensource.perlig.de/rjsmin/" target="_blank" rel="noopener">rjsmin</a> (minification), 
            <a href="https://openpyxl.readthedocs.io/" target="_blank" rel="noopener">openpyxl</a> (Excel export), 
            <a href="https://nodeca.github.io/pako/" target="_blank" rel="noopener">pako</a> (compressed HTML export),
            <a href="https://github.com/facebook/zstd" target="_blank" rel="noopener">Zstandard</a> (backup/restore).
        </p>
        <p>Classification and verification was inferenced by Unsloth's Dynamic quants of <strong><a href="https://huggingface.co/unsloth/Qwen3-30B-A3B-Thinking-2507-GGUF" target="_blank" rel="noopener">Qwen3-30B-A3B-Thinking-2507</a></strong> model from <strong><a href="https://www.alibabacloud.com/en/solutions/generative-ai/qwen?_p_lc=1" target="_blank" rel="noopener">Qwen/Alibaba Cloud</a>.</strong></p>
        <p><strong>Local Inference engine:</strong> <a href="https://github.com/ggerganov/llama.cpp" target="_blank" rel="noopener">llama.cpp</a>.</p>
        <p>Original papers data (BibTeX) was sourced from 
            <a href="https://www.scopus.com/" target="_blank" rel="noopener">Scopus</a>, 
            <a href="https://ieeexplore.ieee.org/" target="_blank" rel="noopener">IEEE Xplore</a> (some) and 
            <a href="https://dl.acm.org/" target="_blank" rel="noopener">ACM Digital Library</a>
        </p>
        <p><strong>Original search query:</strong>
            <span style="font-size:0.75em">("printed circuit*" OR "Circuit board*" OR pcb OR pcba) AND (inspection OR manufactur* OR assembly OR defect* OR solder* OR weld* OR "Automat* optical")</span>
        </p>
    </div>
</div>
```

```html
# templates\detail_row.html
<!-- templates/detail_row.html -->
{% block detail_row_content %}
<div class="detail-flex-container">
    <div class="detail-content detail-abstract">
        <p><strong>Abstract:</strong> {{ paper.abstract }}</p>
    </div>
    <div class="detail-content detail-metadata">
        <p><strong>Keywords:</strong> {{ paper.keywords }}</p>
        <p><strong>Type:</strong> {{ paper.type }}</p>
        <p><strong>DOI:</strong>
            {% if paper.doi %}
                <a href="https://doi.org/{{ paper.doi }}" target="_blank">{{ paper.doi }}</a>
            {% else %}
                {{ paper.doi }}
            {% endif %}
        </p>
        <p><strong>ISSN:</strong> {{ paper.issn }}</p>
        <p><strong>Pages:</strong> {{ paper.pages }}</p>
        <p><strong>ID:</strong> {{ paper.id }}</p> <!-- Show ID in details -->
        <p><strong>Full Authors:</strong> {{ paper.authors }}</p> <!-- Show full authors in details -->
        <p><strong>Year:</strong> {{ paper.year }}</p>
    </div>
    <div class="edit-section detail-edit">
        <form id="form-{{ paper.id }}" data-paper-id="{{ paper.id }}">
            <label>Research Area:
                <input type="text" class="editable" name="research_area" value="{{ paper.research_area or '' }}">
            </label>
            <label>Model Name:
                <input type="text" class="editable" name="model_name" value="{{ paper.technique.model or '' }}">
            </label>
            <label>Other defects:
                <input type="text" class="editable" name="features_other" value="{{ paper.features.other or '' }}">
            </label>
            <label>Page count:
                <input type="text" class="editable" name="page_count" value="{{ paper.page_count or '' }}">
            </label>
            <label>Relevance:
                <input type="text" class="editable" name="relevance" value="{{ paper.relevance or '' }}" placeholder="0 - 10">
            </label>
            <label>User comments:
                <textarea class="editable" name="user_trace">{{ paper.user_trace or '' }}</textarea>
            </label>
            <!-- NEW: Per-Row Action Buttons -->
            <div class="row-actions">
                <button type="button" class="action-btn classify-btn" data-paper-id="{{ paper.id }}">Classify <strong>this paper</strong></button>
                <button type="button" class="action-btn verify-btn" data-paper-id="{{ paper.id }}">Verify <strong>this paper</strong></button>
                <button type="button" class="action-btn save-btn" onclick="saveChanges('{{ paper.id }}')">Save Changes</button>
            </div>
            
        </form>
    </div>

    <div class="detail-content detail-trace detail-evaluator-trace">
        <strong>Evaluator Reasoning Trace:</strong>
        <div class="trace-content">{{ paper.reasoning_trace or 'No trace available.' }}</div> <!-- Load trace directly -->
    </div>
    <div class="detail-content detail-trace detail-verifier-trace">
        <strong>Verifier Reasoning Trace:</strong>
        <div class="trace-content">{{ paper.verifier_trace or 'No trace available.' }}</div> <!-- Load trace directly -->
    </div>
</div>
{% endblock %}
```

```html
# templates\index.html
<!-- templates/index.html -->
<!DOCTYPE html>
<html class="busyCursor">
<head>
    <title>ResearchPara - PCB Inspection Papers</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='fonts.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">

    <script src="{{ url_for('static', filename='libs/chart.min.js') }}"></script>
    <script src="{{ url_for('static', filename='libs/d3.min.js') }}"></script>
    <script src="{{ url_for('static', filename='libs/d3-cloud.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='stats.js') }}" defer></script>
    <script src="{{ url_for('static', filename='comms.js') }}" defer></script>
    <script src="{{ url_for('static', filename='filtering.js') }}" defer></script>
    
</head>
<body>
<input type="file" id="bibtex-file-input" accept=".bib" style="display: none;"> <!-- Hidden file input for BibTeX upload -->
<div class="table-container">
    <div id="papers-table-container">
        <table id="papersTable" style="table-layout: fixed;">
            <colgroup>
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- PDF (Rotated Header) -->
                <col style="width: 66%"> <!-- Title (Should Expand)-->
                <col style="width: 40px; min-width: 40px; max-width:40px;"> <!--  Year -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Pages (Rotated Header) -->
                <col style="width: 34%"> <!-- Journal/Conf (Should Expand) -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Type (Rotated Header) -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Off-topic -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Relevance -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Survey -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- THT -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- SMT -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- X-Ray -->

                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Tracks -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Holes -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- pcb other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Insufficient -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Excess -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Void -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Crack -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Missing Comp -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Wrong Comp -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Orientation -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- compoonet other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Cosmetic -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Other -->

                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Classic CV -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- ML -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- CNN Classifier -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- CNN Detector -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- R-CNN Detector -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Transformers -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Hybrid -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Datasets  -->
                
                <col style="width: 56px; min-width: 56px; max-width: 56px;"> <!-- Last Changed -->
                <col style="width: 40px; min-width: 40px; max-width: 40px;"> <!-- Changed By -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Verified -->
                <col style="width: 32px; min-width: 32px; max-width: 32px;"> <!-- Accr. Score -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Verified By -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- user comments state -->
                <col style="width: 44px; min-width: 44px; max-width: 44px;"> <!-- Details -->
            </colgroup>
            <thead>
                <tr>
                    <th id="main-header-wrapper" colspan=42>
                        <div class="main-header">
                            <div class="header-controls">
                                <button class="action-btn" id="import-btn" style="display:none">Import / Restore</button> <!-- currently unused, kept if a menu is desired later here instead-->
                                <button class="action-btn" id="import-bibtex-btn">Import <strong>BibTeX</strong></button>                                
                            </div>
                            <div class="header-controls">
                                <button class="action-btn" id="export-btn"><strong>Export</strong> & Backup</button>
                            </div>
                            <div class="header-branding"><span>Research</span><span style="font-weight: 600; color: var(--primary-ui-color);">Para</span></div>
                            <div class="header-controls">
                                <button class="action-btn" id="para-tools-btn" ><strong>Batch</strong> Tasks</button>
                            </div>
                            <div class="header-controls">
                                <button class="action-btn" id="stats-btn">View <strong>Statistics</strong></button>
                            </div>
                            <div class="header-controls">
                                <button class="action-btn" id="about-btn" title="About / Help" ><span>?</span></button>
                            </div>
                        </div>
                    </th>
                </tr>
                <tr>
                    <th class="ontop-header" colspan="6" rowspan="2"> 
                        <div class="header-filters">
                            <div class="filter-item">
                                <label for="min-page-count">Min. page count </label>
                                <input type="number" id="min-page-count" value="{{ min_page_count_value }}" min="0" max="9">
                            </div>
                            <div class="filter-item">
                                <label for="year-from">Year:</label>
                                <input type="number" id="year-from" value="{{ year_from_value }}" min="2010" max="2026">
                                <label for="year-to">to</label>
                                <input type="number" id="year-to" value="{{ year_to_value }}" min="2010" max="2026">
                            </div>
                            <!-- This button will now trigger a page reload with updated URL parameters -->
                            <button class="action-btn" id="apply-serverside-filters" style="opacity:0; pointer-events: none;"><span>Apply</span></button>
                        </div>
                    </th>
                    <th class="inferred-header" id="inferred-header-title" colspan="29">
                        <div>
                            <span>Inferred data </span>
                            <div style="margin:0; padding:0">
                                Potential Misclassifications:
                                <input type="checkbox" title="Enable to show only papers with NO features filled in (including 'Other')" id="no-features-checkbox" style="margin-left:8px; margin-right:16px">
                                <input type="checkbox" title="Enable to only show papers marked as misclassified by the verifier" id="hide-approved-checkbox">
                            </div>
                        </div><!--NLP--->
                    </th>
                    <th class="ontop-header" colspan="7" rowspan="2" >
                        <!-- <input type="search" id="search-input" placeholder="Type to search all fields..." value="{{ search_query_value }}"> -->
                        <div class="search-container">
                            <input type="search" id="search-input" placeholder="Type to search all fields..." value="{{ search_query_value }}">
                            <button type="button" id="clear-search-btn" class="clear-btn" title="Clear search">&times;</button>
                        </div>
                    </th>
                </tr>
                <tr>
                    <th class="inferred-header ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" title="Enable to Hide Offtopic papers" id="hide-offtopic-checkbox" {% if hide_offtopic == true %}checked{% endif %}>
                        </div>
                    </th>
                    <th class="inferred-header ontop-header" colspan="1"></th>
                    <th class="inferred-header ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" title="Enable to only show Surveys" id="only-survey-checkbox">
                        </div>
                    </th>
                    <th class="inferred-header ontop-header" colspan="2"></th>
                    <th class="inferred-header ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" title="Enable to Hide X-Ray" id="hide-xray-checkbox" checked>    <!-- client-side, default enabled -->
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="3">
                        <div>
                            <span>PCB</span>
                            <input type="checkbox" title="Enable to include (or limit to if it's the only checkbox enabled) papers about PCB features." id="show-pcb-checkbox">
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="5">
                        <div>
                            <span>Solder</span>
                            <input type="checkbox" checked title="Enable to include (or limit to if it's the only checkbox enabled) papers about solder features" id="show-solder-checkbox">
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="5">
                        <div>
                            <span>PCBA / Other</span>
                            <input type="checkbox" checked title="Enable to include (or limit to if it's the only checkbox enabled) papers about PCBA features" id="show-pcba-checkbox">    
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" checked title="Enable to include (or limit to if it's the only checkbox enabled) papers about PCBA features" id="show-other-checkbox">    
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-3 ontop-header" colspan="8">Techniques</th>
                    <!-- <th class="inferred-header inferred-header-3 ontop-header" colspan="6">DL-based</th> -->
                    <th class="inferred-header inferred-header-3 ontop-header" colspan="1"></th>
                </tr>
                <tr>
                    <th class="rotate-header status-header editable-header" data-sort="pdf-link"><div><span>PDF</span></div> <span class="sort-indicator"></span></th>
                    <th data-sort="title">Title (Click for article) <span class="sort-indicator"></span></th>
                    <th data-sort="year">Year <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="page_count" ><div><span>Pages</span></div> <span class="sort-indicator"></span></th>
                    <th data-sort="journal">Journal/Conf <span class="sort-indicator"></span></th>    
                    <th class="rotate-header status-header editable-header" data-sort="type"><div><span>Type</span></div> <span class="sort-indicator"></span></th>

                    <!-- Classification Summary Columns -->
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_offtopic"><span class="sort-indicator"></span><div><span>Off-topic</span></div></th>
                    <th class="inferred-header rotate-header status-header" data-sort="relevance"><span class="sort-indicator"></span><div><span>Relevance</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_survey"><span class="sort-indicator"></span><div><span>Survey</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_through_hole"><span class="sort-indicator"></span><div><span>THT</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_smt"><span class="sort-indicator"></span><div><span>SMT</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_x_ray"><span class="sort-indicator"></span><div><span>X-Ray</span></div></th>

                    <!-- Features Summary Columns (Updated list) -->
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_tracks"><span class="sort-indicator"></span><div><span>Tracks</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_holes"><span class="sort-indicator"></span><div><span>Holes / Vias</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_bare_pcb_other"><span class="sort-indicator"></span><div><span>(Bare) PCB Other</span></div></th>

                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_insufficient"><span class="sort-indicator"></span><div><span>Insufficient</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_excess"><span class="sort-indicator"></span><div><span>Excessive</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_void"><span class="sort-indicator"></span><div><span>Void / Hole</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_crack"><span class="sort-indicator"></span><div><span>Crack / Cold</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_other"><span class="sort-indicator"></span><div><span>Solder (Other)</span></div></th>
                    
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_missing_component"><span class="sort-indicator"></span><div><span>Missing Comp</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_wrong_component"><span class="sort-indicator"></span><div><span>Wrong Comp</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_orientation"><span class="sort-indicator"></span><div><span>Orientation</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_component_other"><span class="sort-indicator"></span><div><span>Comp (Other)</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_cosmetic"><span class="sort-indicator"></span><div><span>Cosmetic</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_other_state"><span class="sort-indicator"></span><div><span>Other</span></div></th>

                    <!-- Techniques Summary Columns (Updated list) -->
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_classic_cv_based"><span class="sort-indicator"></span><div><span>Classic CV</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_ml_traditional"><span class="sort-indicator"></span><div><span>Traditional ML</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_cnn_classifier"><span class="sort-indicator"></span><div><span>CNN Classifier</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_cnn_detector"><span class="sort-indicator"></span><div><span>CNN Detector</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_rcnn_detector"><span class="sort-indicator"></span><div><span>R-CNN Detector</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_transformer"><span class="sort-indicator"></span><div><span>Transformer</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_other"><span class="sort-indicator"></span><div><span>Other DL</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_hybrid"><span class="sort-indicator"></span><div><span>Hybrid</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_available_dataset"><span class="sort-indicator"></span><div><span>Datasets</span></div></th>

                    <th data-sort="changed">Last Changed <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="changed_by"><div><span>Changed By</span></div> <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="verified">
                        <div><span>Verified</span></div> <span class="sort-indicator"></span>
                    </th>
                    <th class="rotate-header" data-sort="estimated_score"><div><span>Accr. Score</span></div> <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="verified_by"><div><span>Verified By</span></div> <span class="sort-indicator"></span></th>
                    <th class="rotate-header status-header" data-sort="user_comment_state"><span class="sort-indicator"></span><div><span>Commented</span></div></th>
                    <th class="rotate-header"><div>Details</div></th> <!-- must be 50px due to 'collapse' button text -->
                </tr>
            </thead>
                <!-- tbody and tfoot come from the papers_table template-->
                {{ papers_table_content | safe }}        
                
                {% include 'papers_table_tfoot.html' %}
                <!-- Use the rendered table content passed from the server --> 
        </table>
    </div>

<div id="batchModal" class="modal">
    <div id="batch-actions">
        <div>
            <button class="action-btn" id="classify-remaining-btn">Classify <strong>Remaining</strong> </button>
            <button class="action-btn" id="classify-all-btn">Re-Classify <strong>All</strong></button>
        </div>
        <div>
            <button class="action-btn" id="verify-remaining-btn">Verify <strong>Remaining</strong></button>
            <button class="action-btn" id="verify-all-btn">Re-Verify <strong>All</strong></button>
        </div>
        <span class="menu-message">These tools stay running in background after being called. Reload the webpage (not the server) after a while to see updated results.
            <br><br> For actions on single papers, user the buttons in the corresponding paper's detail pane instead.
        </span> 
    </div>
</div>

<div id="importModal" class="modal">
    <div id="import-actions">
        <!-- unused, kept if a menu is desired here later (animations, etc. already done) -->
    </div>
</div>

<div id="exportModal" class="modal">
    <div id="export-actions">
        <div>
            <button class="action-btn" id="export-html-btn">Export <strong>HTML</strong></button>
            <button class="action-btn" id="export-xlsx-btn">Export <strong>XLSX</strong></button>
        </div>        
        <div>
            <button class="action-btn" id="backup-btn" > <strong>Create </strong>Backup</button>
            <button class="action-btn" id="restore-btn" > <strong>Restore </strong>Backup</button>
        </div>
        <span class="menu-message" id="backup-status-message">Backups include the database, original and annotated PDFs, HTML export and a XLSX spreadsheet.
            <br><br>Restoring from a backup overwrites all existing data!
        </span>
    </div>
</div>

<div id="statsModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        {% include 'stats_modal_content.html' %}
    </div>
</div>

<div id="aboutModal" class="modal">
    <div class="modal-small-content">
        <span class="close">&times;</span>      
        {% include 'about_modal_content.html' %}
    </div>
</div>
</body>
</html>
```

```html
# templates\index_static_export.html
<!DOCTYPE html>
<html class="busyCursor">
<head>
    <title>HTML Export - ResearchPara - PCB Inspection Papers</title>
    <link rel="stylesheet" type="text/css" href="static/fonts.css">
    <style>
    {{ style_css_content | safe }}
    /* Overrides for static export: Disable editable status hover/active, doing it here because .editable-status is used by JS for sorting, etc.*/        
    .editable-status:active,.editable-status:hover,.editable-verify:active,.editable-verify:hover{transform:unset;background-color:unset;cursor:default}
    .editable-status:hover,.editable-verify:hover{box-shadow:0 1px 2px rgba(0,0,0,.1)}
    /* fix ? / stats buttons misalingment cross-browser gaslighting: */
    .header-filters > div:last-child { 
        display: flex;
        align-items: center; /* Align items vertically in the center */
        gap: 4px; /* Control spacing between items */
    }
    </style>
    <script>
    {{ chart_js_content | safe }}
    {{ d3_js_content | safe }}
    {{ d3_cloud_js_content | safe }}
    </script>
</head>
<body id="html-export">
<div class="table-container">
    <div id="papers-table-container">
        <table id="papersTable" style="table-layout: fixed;">
            <colgroup>
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- PDF (Rotated Header) -->
                <col style="width: 66%"> <!-- Title (Should Expand)-->
                <col style="width: 40px; min-width: 40px; max-width:40px;"> <!--  Year -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Pages (Rotated Header) -->
                <col style="width: 34%"> <!-- Journal/Conf (Should Expand) -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Type (Rotated Header) -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Off-topic -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Relevance -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Survey -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- THT -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- SMT -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- X-Ray -->

                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Tracks -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Holes -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- pcb other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Insufficient -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Excess -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Void -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder Crack -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Solder other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Missing Comp -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Wrong Comp -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Orientation -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- compoonet other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Cosmetic -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Other -->

                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Classic CV -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- ML -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- CNN Classifier -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- CNN Detector -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- R-CNN Detector -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Transformers -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Other -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Hybrid -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Datasets  -->
                <!-- Columns 31-36: Other Data (Mixed Sizes) -->
                <col style="width: 56px; min-width: 56px; max-width: 56px;"> <!-- Last Changed -->
                <col style="width: 40px; min-width: 40px; max-width: 40px;"> <!-- Changed By -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Verified -->
                <col style="width: 32px; min-width: 32px; max-width: 32px;"> <!-- Accr. Score -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- Verified By -->
                <col style="width: 27px; min-width: 27px; max-width: 27px;"> <!-- user comments state -->
                <col style="width: 44px; min-width: 44px; max-width: 44px;"> <!-- Details -->
            </colgroup>
            <thead>
                <tr>
                    <th id="main-header-wrapper" colspan=42 style="display: none;"></th> <!-- this must exist for CSS consistency between export and real page (uses nth-child, etc.) -->
                </tr>
                <tr>
                    <th class="ontop-header" colspan="6" rowspan="2"> 
                        <div class="header-filters">
                            <div class="filter-item">
                                <input type="checkbox" id="hide-short-checkbox"  style="display: none;">
                                <label for="min-page-count">Min. page count </label>
                                <input type="number" id="min-page-count" value="{{ min_page_count_value }}" min="{{ min_page_count_value }}" max="9" title="Exported file contains papers with at least {{ min_page_count_value }} pages">
                            </div>
                            <div class="filter-item">
                                <label for="year-from">Year:</label>
                                <input type="number" id="year-from" value="{{ year_from_value }}" min="{{ year_from_value }}" max="{{ year_to_value }}" title="Exported file contains papers from {{ year_from_value }} to {{ year_to_value }}.">
                                <label for="year-to">to</label>
                                <input type="number" id="year-to" value="{{ year_to_value }}" min="{{ year_from_value }}" max="{{ year_to_value }}" title="Exported file contains papers from {{ year_from_value }} to {{ year_to_value }}.">
                            </div>
                            <div>
                                <button class="action-btn" id="about-btn" title="About / Help" ><span>?</span></button>
                                <button class="action-btn" id="stats-btn">View <strong>Statistics</strong></button>
                            </div>
                        </div>
                    </th>
                    <th class="inferred-header" id="inferred-header-title" colspan="29">
                        <div>
                            <span>Inferred data</span>
                            <div style="font-size: 7pt; font-family: 'Arial Narrow'; text-shadow: var(--light-shadow); transform:scale(2.2) translateY(-2px);">
                                <span style="font-weight: 400; opacity: 0.7;">Research</span><span style="font-weight: 600; opacity: 0.85;">Para</span>
                            </div>                            
                            <div style="margin:0; padding:0">
                                Potential Misclassifications:
                                <input type="checkbox" title="Enable to show only papers with NO features filled in (including 'Other')" id="no-features-checkbox" style="margin-left:8px; margin-right:16px">
                                <input type="checkbox" title="Enable to only show papers marked as misclassified by the verifier" id="hide-approved-checkbox">
                            </div>
                        </div>
                    </th>
                    
                    <th class="ontop-header" colspan="7" rowspan="2" >
                        <div class="search-container">
                            <input type="search" id="search-input" placeholder="Type to search all fields..." value="{{ search_query_value }}">
                            <button type="button" id="clear-search-btn" class="clear-btn" title="Clear search">&times;</button>
                        </div>
                    </th>
                </tr>
                <tr>
                    <th class="inferred-header ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" id="hide-offtopic-checkbox" {% if hide_offtopic == true %}checked disabled title="Can't unhide offtopic papers. File was exported only with ontopic papers"{% endif %}></th>
                        </div>
                    <th class="inferred-header ontop-header" colspan="1"></th>
                    <th class="inferred-header ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" title="Enable to only show Surveys" id="only-survey-checkbox">
                        </div>
                    </th>
                    <th class="inferred-header ontop-header" colspan="2"></th>
                    <th class="inferred-header ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" title="Enable to Hide X-Ray" id="hide-xray-checkbox" checked>    <!-- client-side, default enabled -->
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="3">
                        <div>
                            <span>PCB</span>
                            <input type="checkbox" title="Enable to include papers about PCB features" id="show-pcb-checkbox">   
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="5">
                        <div>
                            <span>Solder</span>
                            <input type="checkbox" title="Enable to include papers about solder features" id="show-solder-checkbox">
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="5">
                        <div>
                            <span>PCBA / Other</span>
                            <input type="checkbox" title="Enable to include (or limit to if it's the only checkbox enabled) papers about PCBA features" id="show-pcba-checkbox">    
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-2 ontop-header" colspan="1">
                        <div>
                            <input type="checkbox" title="Enable to include (or limit to if it's the only checkbox enabled) papers about PCBA features" id="show-other-checkbox">    
                        </div>
                    </th>
                    <th class="inferred-header inferred-header-3 ontop-header" colspan="8">Techniques</th>
                    <!-- <th class="inferred-header inferred-header-3 ontop-header" colspan="6">DL-based</th> -->
                    <th class="inferred-header inferred-header-3 ontop-header" colspan="1"></th>
                </tr>
                <tr>
                    <th class="rotate-header status-header editable-header" data-sort="pdf-link"><div><span>PDF</span></div> <span class="sort-indicator"></span></th>
                    <th data-sort="title">Title (Click for article) <span class="sort-indicator"></span></th>
                    <th data-sort="year">Year <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="page_count" ><div><span>Pages</span></div> <span class="sort-indicator"></span></th>
                    <th data-sort="journal">Journal/Conf <span class="sort-indicator"></span></th>    
                    <th class="rotate-header status-header editable-header" data-sort="type"><div><span>Type</span></div> <span class="sort-indicator"></span></th>
                    <!-- Classification Summary Columns -->
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_offtopic"><span class="sort-indicator"></span><div><span>Off-topic</span></div></th>
                    <th class="inferred-header rotate-header status-header" data-sort="relevance"><span class="sort-indicator"></span><div><span>Relevance</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_survey"><span class="sort-indicator"></span><div><span>Survey</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_through_hole"><span class="sort-indicator"></span><div><span>THT</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_smt"><span class="sort-indicator"></span><div><span>SMT</span></div></th>
                    <th class="inferred-header rotate-header status-header editable-header" data-sort="is_x_ray"><span class="sort-indicator"></span><div><span>X-Ray</span></div></th>

                    <!-- Features Summary Columns (Updated list) -->
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_tracks"><span class="sort-indicator"></span><div><span>Tracks</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_holes"><span class="sort-indicator"></span><div><span>Holes / Vias</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_bare_pcb_other"><span class="sort-indicator"></span><div><span>(Bare) PCB Other</span></div></th>

                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_insufficient"><span class="sort-indicator"></span><div><span>Insufficient</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_excess"><span class="sort-indicator"></span><div><span>Excessive</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_void"><span class="sort-indicator"></span><div><span>Void / Hole</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_crack"><span class="sort-indicator"></span><div><span>Crack / Cold</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_solder_other"><span class="sort-indicator"></span><div><span>Solder (Other)</span></div></th>
                    
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_missing_component"><span class="sort-indicator"></span><div><span>Missing Comp</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_wrong_component"><span class="sort-indicator"></span><div><span>Wrong Comp</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_orientation"><span class="sort-indicator"></span><div><span>Orientation</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_component_other"><span class="sort-indicator"></span><div><span>Comp (Other)</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_cosmetic"><span class="sort-indicator"></span><div><span>Cosmetic</span></div></th>
                    <th class="inferred-header inferred-header-2 rotate-header status-header editable-header" data-sort="features_other_state"><span class="sort-indicator"></span><div><span>Other</span></div></th>

                    <!-- Techniques Summary Columns (Updated list) -->
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_classic_cv_based"><span class="sort-indicator"></span><div><span>Classic CV</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_ml_traditional"><span class="sort-indicator"></span><div><span>Traditional ML</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_cnn_classifier"><span class="sort-indicator"></span><div><span>CNN Classifier</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_cnn_detector"><span class="sort-indicator"></span><div><span>CNN Detector</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_rcnn_detector"><span class="sort-indicator"></span><div><span>R-CNN Detector</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_transformer"><span class="sort-indicator"></span><div><span>Transformer</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_dl_other"><span class="sort-indicator"></span><div><span>Other DL</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_hybrid"><span class="sort-indicator"></span><div><span>Hybrid</span></div></th>
                    <th class="inferred-header inferred-header-3 rotate-header status-header editable-header" data-sort="technique_available_dataset"><span class="sort-indicator"></span><div><span>Datasets</span></div></th>

                    <th data-sort="changed">Last Changed <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="changed_by"><div><span>Changed By</span></div> <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="verified">
                        <div><span>Verified</span></div> <span class="sort-indicator"></span>
                    </th>
                    <th class="rotate-header" data-sort="estimated_score"><div><span>Accr. Score</span></div> <span class="sort-indicator"></span></th>
                    <th class="rotate-header" data-sort="verified_by"><div><span>Verified By</span></div> <span class="sort-indicator"></span></th>
                    <th class="rotate-header status-header" data-sort="user_comment_state"><span class="sort-indicator"></span><div><span>Commented</span></div></th>
                    <th class="rotate-header"><div>Details</div></th> <!-- must be 50px due to 'collapse' button text -->
                </tr>
        </thead>
        {{ papers_table_static_export | safe }}
        {% include 'papers_table_tfoot.html' %}
    </table>
</div>

<div id="statsModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        {% include 'stats_modal_content.html' %}
    </div>
</div>

<div id="aboutModal" class="modal">
    <div class="modal-small-content">
        <span class="close">&times;</span>      
        {% include 'about_modal_content.html' %}
    </div>
</div>

<script>
    {{ ghpages_js_content | safe }}
    {{ stats_js_content | safe }}
    {{ filtering_js_content | safe }}
</script>
</body>
</html>
```

```html
# templates\loader.html
<!-- templates/loader.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Loading ResearchPara...</title>
    <style>
        /* Minimal styling for the loading indicator */
        body { font-family: sans-serif; display: flex; flex-direction: column; gap: 40px; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #f5f5f5; }
        .loading, #previewMessage { text-align: center; }
        /* .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto 10px; } */    
        .spinner {
            width: 60px;
            height: 60px;
            border: 12px solid hsl(188, 36%, 30%);
            border-top: 12px solid transparent;
            border-radius: 50%;
            animation: spin 0.75s linear infinite;
            margin: 0 auto 30px; 
        }
        .header-branding{
            font-size: 48pt;
            justify-self: center;
            font-family: "Arial Narrow";
            font-weight: 400;
            color: #3f8d82;
            text-shadow: 1px 0 5px #fff6;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <!-- Inline the Pako library for Gzip decompression -->
    <script>
    {{ pako_js_content | safe }} 
    </script>
</head>
<body>
    <div class="header-branding"><span>Research</span><span style="font-weight: 600; color: hsl(188, 31%, 29%);">Para</span></div>
    <div class="loading" id="splash-spinner">
        <div class="spinner"></div>
        <p>Trying to decompress and load HTML static export...</p>
        <p>This file requires JavaScript to decompress and load its content.<br>
        Download and open it in a full web browser to view.</p>
    </div>
    <script>
        const compressedDataBase64 = "{{ compressed_html_data | safe }}"; // The compressed HTML data passed from Flask

        function loadContent() {
            try {
                const compressedBytes = Uint8Array.from(atob(compressedDataBase64), c => c.charCodeAt(0));  // 1. Decode Base64 to get compressed bytes (as Uint8Array)
                const decompressedBytes = pako.inflate(compressedBytes);                                    // 2. Decompress using Pako (inflate)                
                const decompressedHtmlString = new TextDecoder("utf-8").decode(decompressedBytes);          // 3. Decode bytes back to string (assuming UTF-8)

                // 4. Write the full HTML content to the document, replacing this loader
                // Using document.write after the page loads replaces the entire document
                document.open();
                document.write(decompressedHtmlString);
                document.close();
            } catch (error) {
                console.error("Failed to decompress or load content:", error);
                document.body.innerHTML = "<p style='color:red;'>Error loading data. Please check the console for details.</p>";
            }
        }

        // Start loading when the window loads
        window.addEventListener('load', loadContent);
    </script>
</body>
</html>
```

```html
# templates\papers_table.html
<!-- templates/papers_table.html -->
{% block papers_table_content %}
<tbody style="position: relative;">
<tr>
    <td style="padding:0;">
        <div class="loading-overlay">
            <div class="header-branding"><span>Research</span><span style="font-weight: 600; color: var(--primary-ui-color);">Para</span></div>
            <div class="loading-spinner"></div>
            <div>Reprocessing table. Wait patiently. </div>
        </div>
    </td>
</tr>
{% for paper in papers %}
    <tr data-paper-id="{{ paper.id }}" >
        <td class="status-cell pdf-status">
            {% if paper.pdf_filename %}
                <a href="{{ url_for('static', filename='pdfjs/web/viewer.html') }}?file={{ url_for('serve_pdf', paper_id=paper.id) | urlencode }}" target="_blank" class="pdf-link" 
                title="{% if paper.pdf_state == 'annotated' %}Open this annotated PDF in the Annotator{% else %}Open this PDF in the Annotator{% endif %}">
                        {{ pdf_emojis.get(paper.pdf_state) }}
                </a>
            {% else %}
                <a href="#" class="pdf-upload-link" data-paper-id="{{ paper.id }}" 
                title="{% if paper.pdf_state == 'paywalled' %}Article is paywalled. Click to upload if a copy is available{% else %}No PDF stored yet. Click to upload PDF for this article{% endif %}">
                    {{ pdf_emojis.get(paper.pdf_state) }}
                </a>
            {% endif %}
        </td>

        </td><td class="title-cell">
            {% if paper.doi %}
                <a href="https://doi.org/{{ paper.doi }}" target="_blank">{{ paper.title }}</a>
            {% else %}
                <span style="font-weight: 300;">{{paper.title}}</span> 
            {% endif %}
        </td>

        <td class="secondary-text-cell number-cell">{{ paper.year or '' }}</td>
        <td class="secondary-text-cell number-cell">{{ paper.page_count or '' }}</td>
        <td class="secondary-text-cell">{{ paper.journal }}</td>        
        <td class="status-cell" title="{{ paper.type }}">{{ type_emojis.get(paper.type, default_type_emoji) }}
        
        

        <td class="status-cell editable-status" data-field="is_offtopic">{{ paper.is_offtopic | render_status }}</td>
        <td class="secondary-text-cell number-cell">{{ paper.relevance or '' }}</td>
        <td class="status-cell editable-status" data-field="is_survey">{{ paper.is_survey | render_status }}</td>
        <td class="status-cell editable-status" data-field="is_through_hole">{{ paper.is_through_hole | render_status }}</td>
        <td class="status-cell editable-status" data-field="is_smt">{{ paper.is_smt | render_status }}</td>
        <td class="status-cell editable-status" data-field="is_x_ray">{{ paper.is_x_ray | render_status }}</td>

        <td class="status-cell editable-status highlight-status" data-field="features_tracks">{{ paper.features.tracks | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_holes">{{ paper.features.holes | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_bare_pcb_other">{{ paper.features.bare_pcb_other | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_insufficient">{{ paper.features.solder_insufficient | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_excess">{{ paper.features.solder_excess | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_void">{{ paper.features.solder_void | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_crack">{{ paper.features.solder_crack | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_other">{{ paper.features.solder_other | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_missing_component">{{ paper.features.missing_component | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_wrong_component">{{ paper.features.wrong_component | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_orientation">{{ paper.features.orientation | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_component_other">{{ paper.features.component_other | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_cosmetic">{{ paper.features.cosmetic | render_status }}</td>
        <td class="status-cell highlight-status" data-field="features_other_state">{{ '' if paper.features.other and (paper.features.other|string).strip() else '' }}</td>

        <td class="status-cell editable-status" data-field="technique_classic_cv_based">{{ paper.technique.classic_cv_based | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_ml_traditional">{{ paper.technique.ml_traditional | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_cnn_classifier">{{ paper.technique.dl_cnn_classifier | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_cnn_detector">{{ paper.technique.dl_cnn_detector | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_rcnn_detector">{{ paper.technique.dl_rcnn_detector | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_transformer">{{ paper.technique.dl_transformer | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_other">{{ paper.technique.dl_other | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_hybrid">{{ paper.technique.hybrid | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="technique_available_dataset">{{ paper.technique.available_dataset | render_status }}</td>

        <td class="secondary-text-cell changed-cell highlight-status">{{ paper.changed_formatted }}</td> <!-- Use formatted timestamp -->
        <td class="status-cell changed-by-cell highlight-status" data-field="changed_by">{{ paper.changed_by | render_changed_by }}</td>           
        <td class="status-cell editable-status" data-field="verified">{{ paper.verified | render_status }}</td>
        <td class="secondary-text-cell number-cell" data-field="verified">{{ paper.estimated_score  or '' }}</td>
        <td class="status-cell editable-verify" data-field="verified_by">{{ paper.verified_by | render_verified_by }}</td>                 
        <td class="status-cell" data-field="user_comment_state">{{ '' if paper.user_trace and (paper.user_trace|string).strip() else '' }}</td> 
        <td class="toggle-btn" onclick="toggleDetails(this)"><span>Show</span></td>
    </tr>
    <tr class="detail-row">
        <td colspan="42">
            <div class="detail-content-placeholder">
                <!-- Comment detail-flex-container out when debugging with Firefox Element inspector (the mere existence if this makes the whole debugger unusably laggy for unknown reasons) -->
                <!-- <div class="detail-flex-container">
                    <div class="detail-content detail-metadata">
                        <p><strong>Keywords:</strong> {{ paper.keywords }}</p>
                        <p><strong>Full Authors:</strong> {{ paper.authors }}</p>
                    </div>
                    <div class="edit-section detail-edit">
                        <form id="form-{{ paper.id }}" data-paper-id="{{ paper.id }}">
                            <label>Research Area:
                                <input type="text" class="editable" name="research_area" value="{{ paper.research_area or '' }}" disabled>
                            </label>
                            <label>Model Name:
                                <input type="text" class="editable" name="model_name" value="{{ paper.technique.model or '' }}" disabled>
                            </label>
                            <label>Other defects:
                                <input type="text" class="editable" name="features_other" value="{{ paper.features.other or '' }}" disabled>
                            </label>
                            <label>User comments:
                                <textarea class="editable" name="user_trace" disabled>{{ paper.user_trace or '' }}</textarea>
                            </label>
                        </form>
                    </div>
                </div> -->

            </div>
        </td>
    </tr>
{% endfor %}
</tbody>
{% endblock %}
```

```html
# templates\papers_table_static_export.html
{% block papers_table_static_export %}
<tbody style="position: relative;">
<tr>
    <td style="padding:0;">
        <div class="loading-overlay">
            <div class="header-branding"><span>Research</span><span style="font-weight: 600; color: var(--primary-ui-color);">Para</span></div>
            <div class="loading-spinner"></div>
            <div>Reprocessing table. Wait patiently. </div>
        </div>
    </td>
</tr>
{% for paper in papers %}
    <tr data-paper-id="{{ paper.id }}" >
        {% if paper.pdf_filename %}
        <td class="status-cell pdf-status">
            {% if paper.pdf_state == 'annotated' %}
                <a href="data/pdf_annotated/{{ paper.pdf_filename }}" target="_blank" class="pdf-link" title="Open PDF">
                    {{ pdf_emojis.get(paper.pdf_state) }}
                </a>
            {% else %}
                <a href="data/pdf/{{ paper.pdf_filename }}" target="_blank" class="pdf-link" title="Open PDF">
                    {{ pdf_emojis.get(paper.pdf_state) }}
                </a>
            {% endif %}
        </td>
        {% else %}
        <td>
            {% if paper.pdf_state == 'paywalled' %}
                <span title="This paper is paywalled">
                    {{ pdf_emojis.get(paper.pdf_state) }}
                </span>
            </td>
            {% endif %}
        {% endif %}
        </td><td class="title-cell">
            {% if paper.doi %}
                <a href="https://doi.org/{{ paper.doi }}" target="_blank">{{ paper.title }}</a>
            {% else %}
                <span style="font-weight: 300;">{{paper.title}}</span> 
            {% endif %}
        </td>

        <td class="secondary-text-cell number-cell">{{ paper.year or '' }}</td>
        <td class="secondary-text-cell number-cell">{{ paper.page_count or '' }}</td>
        <td class="secondary-text-cell">{{ paper.journal }}</td>        
        <td class="status-cell" title="{{ paper.type }}">{{ type_emojis.get(paper.type, default_type_emoji) }}
        

        <td class="status-cell editable-status" data-field="is_offtopic">{{ paper.is_offtopic | render_status }}</td>
        <td class="secondary-text-cell number-cell">{{ paper.relevance or '' }}</td>
        <td class="status-cell editable-status" data-field="is_survey">{{ paper.is_survey | render_status }}</td>
        <td class="status-cell editable-status" data-field="is_through_hole">{{ paper.is_through_hole | render_status }}</td>
        <td class="status-cell editable-status" data-field="is_smt">{{ paper.is_smt | render_status }}</td>
        <td class="status-cell editable-status" data-field="is_x_ray">{{ paper.is_x_ray | render_status }}</td>

        <td class="status-cell editable-status highlight-status" data-field="features_tracks">{{ paper.features.tracks | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_holes">{{ paper.features.holes | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_bare_pcb_other">{{ paper.features.bare_pcb_other | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_insufficient">{{ paper.features.solder_insufficient | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_excess">{{ paper.features.solder_excess | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_void">{{ paper.features.solder_void | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_crack">{{ paper.features.solder_crack | render_status }}</td>
        <td class="status-cell editable-status" data-field="features_solder_other">{{ paper.features.solder_other | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_missing_component">{{ paper.features.missing_component | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_wrong_component">{{ paper.features.wrong_component | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_orientation">{{ paper.features.orientation | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_component_other">{{ paper.features.component_other | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="features_cosmetic">{{ paper.features.cosmetic | render_status }}</td>
        <td class="status-cell highlight-status" data-field="features_other_state">{{ '' if paper.features.other and (paper.features.other|string).strip() else '' }}</td>

        <td class="status-cell editable-status" data-field="technique_classic_cv_based">{{ paper.technique.classic_cv_based | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_ml_traditional">{{ paper.technique.ml_traditional | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_cnn_classifier">{{ paper.technique.dl_cnn_classifier | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_cnn_detector">{{ paper.technique.dl_cnn_detector | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_rcnn_detector">{{ paper.technique.dl_rcnn_detector | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_transformer">{{ paper.technique.dl_transformer | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_dl_other">{{ paper.technique.dl_other | render_status }}</td>
        <td class="status-cell editable-status" data-field="technique_hybrid">{{ paper.technique.hybrid | render_status }}</td>
        <td class="status-cell editable-status highlight-status" data-field="technique_available_dataset">{{ paper.technique.available_dataset | render_status }}</td>

        <td class="secondary-text-cell changed-cell highlight-status">{{ paper.changed_formatted }}</td> <!-- Use formatted timestamp -->
        <td class="status-cell changed-by-cell highlight-status" data-field="changed_by">{{ paper.changed_by | render_changed_by }}</td>           
        <td class="status-cell editable-status" data-field="verified">{{ paper.verified | render_status }}</td>
        <td class="secondary-text-cell number-cell" data-field="verified">{{ paper.estimated_score  or '' }}</td>
        <td class="status-cell editable-verify" data-field="verified_by">{{ paper.verified_by | render_verified_by }}</td>                 
        <td class="status-cell" data-field="user_comment_state">{{ '' if paper.user_trace and (paper.user_trace|string).strip() else '' }}</td> 
        <td class="toggle-btn" onclick="toggleDetails(this)"><span>Show</span></td>
    </tr>
    <tr class="detail-row">
        <td colspan="42">
            <div class="detail-flex-container">
                <div class="detail-content detail-abstract">
                    <p><strong>Abstract:</strong> {{ paper.abstract or 'No abstract available.' }}</p>
                </div>
                <div class="detail-content detail-metadata">
                    <p><strong>Keywords:</strong> {{ paper.keywords }}</p>
                    <p><strong>Type:</strong> {{ paper.type }}</p>
                    <p><strong>DOI:</strong>
                        {% if paper.doi %}
                            <a href="https://doi.org/{{ paper.doi }}" target="_blank">{{ paper.doi }}</a>
                        {% else %}
                            {{ paper.doi }}
                        {% endif %}
                    </p>
                    <p><strong>ISSN:</strong> {{ paper.issn }}</p>
                    <p><strong>Pages:</strong> {{ paper.pages }}</p>
                    <p><strong>ID:</strong> {{ paper.id }}</p>
                    <p><strong>Full Authors:</strong> {{ paper.authors }}</p>
                    <p><strong>Year:</strong> {{ paper.year }}</p>
                </div>
                <div class="edit-section detail-edit">
                    <form id="form-{{ paper.id }}" data-paper-id="{{ paper.id }}">
                        <label>Research Area:
                            <input type="text" class="editable" name="research_area" value="{{ paper.research_area or '' }}" disabled>
                        </label>
                        <label>Model Name:
                            <input type="text" class="editable" name="model_name" value="{{ paper.technique.model or '' }}" disabled>
                        </label>
                        <label>Other defects:
                            <input type="text" class="editable" name="features_other" value="{{ paper.features.other or '' }}" disabled>
                        </label>
                        <label>Page count:
                            <input type="text" class="editable" name="page_count" value="{{ paper.page_count or '' }}" disabled>
                        </label>
                        <label>Relevance:
                            <input type="text" class="editable" name="relevance" value="{{ paper.relevance or '' }}" placeholder="0 - 10" disabled>
                        </label>
                        <label>User comments:
                            <textarea class="editable" name="user_trace" disabled>{{ paper.user_trace or '' }}</textarea>
                        </label>
                        <div class="row-actions">
                            <button type="button" class="action-btn classify-btn" data-paper-id="{{ paper.id }}" disabled>Classify <strong>this paper</strong></button>
                            <button type="button" class="action-btn verify-btn" data-paper-id="{{ paper.id }}" disabled>Verify <strong>this paper</strong></button>
                            <button type="button" class="action-btn save-btn" onclick="saveChanges('{{ paper.id }}')" disabled>Save Changes</button>
                        </div>
                    </form>
                </div>
                <div class="detail-content detail-trace detail-evaluator-trace">
                    <strong>Evaluator Reasoning Trace:</strong>
                    <div class="trace-content">{{ paper.reasoning_trace or 'No trace available.' }}</div>
                </div>
                <div class="detail-content detail-trace detail-verifier-trace">
                    <strong>Verifier Reasoning Trace:</strong>
                    <div class="trace-content">{{ paper.verifier_trace or 'No trace available.' }}</div>
                </div>
            </div>
        </td>
    </tr>
{% endfor %}
</tbody>
{% endblock %}
```

```html
# templates\papers_table_tfoot.html
<!-- templates/papers_table_tfoot.html -->
<tfoot id="counts-footer">
    <tr>
        <!-- Empty cells to align with non-count columns -->
        <td id="count-pdf_present" title=""></td> <!-- Combined PDF/Annotated Count Cell -->
        <td style="font-weight: 400;" id="visible-count-cell">
            Filtered: <span style="font-weight: bold;" id="visible-papers-count"></span>, 
            Loaded: <span style="font-weight: bold;" id="loaded-papers-count"></span>, 
            Total: <span style="font-weight: bold;" id="total-papers-count">{{ total_paper_count | safe }}</span>, <!-- Title -->
            Duplicate: <span style="font-weight: bold;" id="duplicate-papers-count"></span>
        </td>
        <!-- <td></td> Authors -->
        <td></td> <!-- Year -->
        <td></td> <!-- Type -->
        <td></td> <!-- Journal -->
        <td></td> <!-- Page Count -->
        <!-- Classification Counts -->
        <td id="count-is_offtopic" class="count-cell" title="Offtopic"></td>
        <td></td> <!-- Relevance -->
        <td id="count-is_survey" class="count-cell" title="Survey"></td>
        <td id="count-is_through_hole" class="count-cell" title="THT"></td>
        <td id="count-is_smt" class="count-cell" title="SMT"></td>
        <td id="count-is_x_ray" class="count-cell" title="X-Ray"></td>
        
        <!-- Features Counts (Updated list - 10 columns now) -->
        <td id="count-features_tracks" class="count-cell" title="Tracks"></td>
        <td id="count-features_holes" class="count-cell" title="Holes"></td>
        <td id="count-features_bare_pcb_other" class="count-cell" title="Bare PCB other"></td>
        <td id="count-features_solder_insufficient" class="count-cell" title="Insufficient Solder"></td>
        <td id="count-features_solder_excess" class="count-cell" title="Excess solder"></td>
        <td id="count-features_solder_void" class="count-cell" title="Solder void"></td>
        <td id="count-features_solder_crack" class="count-cell" title="Solder crack"></td>
        <td id="count-features_solder_other" class="count-cell" title="Solder other"></td>
        <td id="count-features_missing_component" class="count-cell" title="Missing component"></td>
        <td id="count-features_wrong_component" class="count-cell" title="Wrong component"></td>
        <td id="count-features_orientation" class="count-cell" title="Orientation"></td>
        <td id="count-features_component_other" class="count-cell" title="Component Other"></td>
        <td id="count-features_cosmetic" class="count-cell" title="Cosmetic"></td>
        <td id="count-features_other_state" class="count-cell" title="Other"></td>

        <!-- Techniques Counts (Updated list - 9 columns now) -->
        <td id="count-technique_classic_cv_based" class="count-cell" title="Classic CV"></td>
        <td id="count-technique_ml_traditional" class="count-cell" title="Traditional ML"></td>
        <td id="count-technique_dl_cnn_classifier" class="count-cell" title="CNN Classifier"></td>
        <td id="count-technique_dl_cnn_detector" class="count-cell" title="CNN Detector (single-stage)"></td>
        <td id="count-technique_dl_rcnn_detector" class="count-cell" title="R-CNN Detector"></td>
        <td id="count-technique_dl_transformer" class="count-cell" title="Transformer"></td>
        <td id="count-technique_dl_other" class="count-cell" title="Other DL"></td>
        <td id="count-technique_hybrid" class="count-cell" title="Hybrid"></td>
        <td id="count-technique_available_dataset" class="count-cell" title="Available Dataset"></td>

        <!-- Empty cells for remaining columns -->
        <td></td> <!-- Last Changed -->
        <td id="count-changed_by" class="count-cell" title="Changed by User"></td>
        <td id="count-verified" class="count-cell" title="Verified"></td>
        <td></td> <!-- Estimated Score -->
        <td id="count-verified_by" class="count-cell" title="Verified by User"></td> 
        <td id="count-user_comment_state" class="count-cell" title="Commented by User"></td> 
        <td></td> <!-- Actions -->
    </tr>
</tfoot>
```

```html
# templates\stats_modal_content.html
<!-- templates/stats_modal_content.html -->
<!-- <p> Data in <strong>all lists</strong> below is dynamically calculated based on <strong>currently visible</strong> papers:</p> -->
<div class="stats-lists">
    <div class="stats-section">
        <h3>Repeating <strong>Journals</strong> <span style="font-size:0.6em"><!--  Scroll down on each list for more--> </span></h3>
        <ul id="journalStatsList" class="stats-list-multicolumn-2"></ul>
    </div>
    <div class="stats-section">
        <h3>Repeating <strong>Conferences</strong> <span style="font-size:0.6em"></span></h3>
        <ul id="conferenceStatsList" class="stats-list-multicolumn-2"></ul> 
    </div>
    <div class="stats-section" style="grid-column: 1/3;">
        <h3>Repeating <strong>Keywords</strong> <span style="font-size:0.6em"></span>
            <span style="font-size:0.6em;padding-left: 30px;position: absolute; right: 30px;top: 16px;">
                <label style="margin-left:10px;">
                    Cloud <input checked type="checkbox" id="cloudToggle" style="transform: scale(2) translate(5px,-0.5px);">
                </label>
            </span>
        </h3>
        <ul id="keywordStatsList" class="stats-list-multicolumn-short"></ul>     
        <div id="keywordCloudCanvas"
            style="display: block; margin: auto; width: 100%; height: 285px;border-right: 2px solid var(--stats-primary-ui-color);box-sizing: border-box;">
            <canvas width="640" height="280"></canvas>
        </div>
    </div>
    <div class="stats-section">
        <h3>Repeating <strong>Authors</strong> <span style="font-size:0.6em"></span></h3>
        <ul id="authorStatsList" class="stats-list-multicolumn-2"></ul>
    </div>
    <div class="stats-section" style="display: none;">
        <h3>Repeating <strong>Research Areas</strong> <span style="font-size:0.6em"></span></h3>
        <ul id="researchAreaStatsList" class="stats-list-multicolumn-2"></ul>
    </div>
    <div class="stats-section">
        <h3>Mentioned <strong>Models</strong> <span style="font-size:0.6em"></span></h3>
        <ul id="modelNamesStatsList" class="stats-list-multicolumn-2"></ul>
    </div>
    <div class="stats-section">
        <h3>Mentioned <strong>other features</strong> <span style="font-size:0.6em"></span></h3>
        <ul id="otherDetectedFeaturesStatsList" class="stats-list-multicolumn-2"></ul>
    </div>
    <!-- <div class="stats-section" style="grid-column: 1/3;"> -->
    <div class="stats-section">
        <h3><strong>Other</strong> Metrics</h3>
        <table id="metricsTableStatsList" class="stats-table"></table>
    </div>
</div>
        
<div class="stats-charts">
    <div class="stats-section">
        <h3><strong>Techniques</strong> Distribution             
            <span style="font-size:0.6em;padding-left: 30px;position: absolute; right: 6px;top: 16px;">
                <label style="padding: 10px;margin: 10px;">
                    Pie<input type="checkbox" id="pieToggle" style="transform: scale(2) translate(5px,-0.5px);">
                </label>
            </span>
        </h3>
        <div class="chart-container" style="height:calc(100% - 43px); width:305px; max-width: 305px; margin: auto;">
            <canvas id="techniquesPieChart"></canvas>
        </div>
    </div>
    <div class="stats-section">
        <h3><strong>Features</strong> Distribution</h3>
        <div class="chart-container" style="height:calc(100% - 43px); width:305px; max-width: 305px; margin: auto;">
            <canvas id="featuresPieChart"></canvas>
        </div>
    </div>
    <div class="stats-section">                
        <h3><strong>Publication Types</strong> per Year</h3>
        <div class="chart-container-fullwidth" style="height: calc(80% - 20px); margin: auto;">
            <canvas id="pubTypesPerYearLineChart"></canvas>
        </div>
    </div>
    <div class="stats-section">
        <h3><strong>Techniques</strong> per Year 
            <span style="font-size:0.6em">  Click on a label to show/hide its data and reflow the chart </span>
            <span style="font-size:0.6em;padding-left: 30px;position: absolute;right: 40px;top: 16px;">
                <label>
                    Cumulative<input type="checkbox" id="cumulativeToggle" style="transform: scale(2) translate(5px,-0.5px);">
                </label>
                <label style="padding: 0 20px;margin: 10px;">
                    Stacked<input type="checkbox" id="stackingToggle" style="transform: scale(2) translate(5px,-0.5px);">
                </label>
            </span>
        </h3>
        <div class="chart-container-fullwidth" style="height:calc(100% - 43px); margin: auto;">
            <canvas id="techniquesPerYearLineChart"></canvas>
        </div>
    </div>

    <div class="stats-section">
        <h3><strong>Features</strong> per Year  <span style="font-size:0.6em">  Data in this page is dynamically calculated based on <strong>currently visible</strong> papers.</span></h3>
        <div class="chart-container-fullwidth" style="height:calc(100% - 43px); margin: auto;">
            <canvas id="featuresPerYearLineChart"></canvas>
        </div>
    </div>
    <div class="stats-section">
        <h3><strong>Survey</strong> vs <strong>Implementation</strong> Papers per Year</h3>
        <div class="chart-container-fullwidth" style="height:calc(80% - 20px);  margin: auto;">
            <canvas id="surveyVsImplLineChart"></canvas>
        </div>
    </div>
</div>
```

